int main(void)
uint8_t i;
HAL_Init();
Stm32_Clock_Init(RCC_PLL_MUL9);
delay_init(72);
uart_init(115200);
LED_Init();
KEY_Init();
ADC1_Init();
EXTI_Init();
TIM3_Init(719, 199);
LCD_Init();
POINT_COLOR = RED;
LCD_Clear(BLUE);
LCD_Fill( 0, 0, 239, 160, WHITE);
LCD_DrawRectangle( 0, 0, 239, 160);
LCD_DrawRectangle( 1, 1, 238, 159);
LCD_DrawRectangle( 12, 8, 227, 152);
LCD_DrawRectangle( 66, 44, 173, 116);
LCD_DrawLine( 0, 80, 239, 80);
LCD_DrawLine( 119, 0, 119, 160);
BACK_COLOR = BLUE;
LCD_ShowString( 42, 161,240, 24, 24, "Paramter List");
POINT_COLOR = BROWN;
LCD_DrawRectangle( 14, 185, 225, 315);
LCD_DrawRectangle( 15, 186, 224, 314);
LCD_DrawRectangle( 16, 187, 223, 313);
LCD_Fill( 17, 188, 222, 312, WHITE);
POINT_COLOR = BLACK;
BACK_COLOR = WHITE;
LCD_ShowString( 20, 190, 240, 16, 16, "ADC1: ");
LCD_ShowString( 20, 206, 240, 16, 16, "ADC2: ");
LCD_ShowString( 20, 222, 240, 16, 16, "ADC3: ");
LCD_ShowString( 20, 238, 240, 16, 16, "x: ");
LCD_ShowString( 70, 238, 240, 16, 16, "mm");
LCD_ShowString( 20, 254, 240, 16, 16, "y: ");
LCD_ShowString( 70, 254, 240, 16, 16, "mm");
POINT_COLOR = MAGENTA;
LCD_ShowString( 20, 270, 240, 16, 16, "pen up      ");
POINT_COLOR = BLACK;
while(1)
LCD_ShowNum( 56, 190, Ladc1, 6, 16);
LCD_ShowNum( 56, 206, Ladc2, 6, 16);
LCD_ShowNum( 56, 222, Ladc3, 6, 16);
POINT_COLOR = MAGENTA;
if(Ladc3 > 695)
LCD_ShowString( 20, 270, 240, 16, 16, "pen down");
penState = 1;
else
LCD_ShowString( 20, 270, 240, 16, 16, "pen up      ");
penState = 0;
POINT_COLOR = BLACK;
if(penState == 1)
delay_ms(500);
x = fitted_position_x(Ladc1 - Ladc3, Ladc2);
y = - fitted_position_y(Ladc1 - Ladc3, Ladc2);
printf("%lf,%lf\\r\\n",x,y);
if(x < 0)
LCD_ShowString( 35, 238, 240, 16, 16, "-");
LCD_ShowNum( 40, 238, -x, 3, 16);
else
LCD_ShowString( 35, 238, 240, 16, 16, " ");
LCD_ShowNum( 40, 238, x, 3, 16);
if( y< 0)
LCD_ShowString( 40, 254, 240, 16, 16, "-");
LCD_ShowNum( 40, 254, -y, 3, 16);
else
LCD_ShowString( 40, 254, 240, 16, 16, " ");
LCD_ShowNum( 40, 254, y, 3, 16);
draw_point_graph( x, y, 119, 80, BLACK);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == GPIO_PIN_0)
newButtonState ^= 1;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_SPI1_Init();
MX_USB_PCD_Init();
MX_TIM16_Init();
HAL_TIM_Base_Start(&htim16);
while (1)
updateButtonState();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_I2C1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.Timing = 0x2000090E;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM16_Init(void)
htim16.Instance = TIM16;
htim16.Init.Prescaler = 48-1;
htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
htim16.Init.Period = 65535;
htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim16.Init.RepetitionCounter = 0;
htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
Error_Handler();
static void MX_USB_PCD_Init(void)
hpcd_USB_FS.Instance = USB;
hpcd_USB_FS.Init.dev_endpoints = 8;
hpcd_USB_FS.Init.speed = PCD_SPEED_FULL;
hpcd_USB_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
hpcd_USB_FS.Init.low_power_enable = DISABLE;
hpcd_USB_FS.Init.battery_charging_enable = DISABLE;
if (HAL_PCD_Init(&hpcd_USB_FS) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin
|LD7_Pin|LD9_Pin|LD10_Pin|LD8_Pin
|LD6_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = DRDY_Pin|MEMS_INT3_Pin|MEMS_INT4_Pin|MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|LD4_Pin|LD3_Pin|LD5_Pin
|LD7_Pin|LD9_Pin|LD10_Pin|LD8_Pin
|LD6_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_0;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_SPI1_Init();
MX_USB_PCD_Init();
doSomething();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_I2C1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
while(1)
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
uwPrescalerValue = (uint32_t)((SystemCoreClock) / 25000000) - 1;
TimHandle.Instance = TIMx;
TimHandle.Init.Period            = 0xFFFF;
TimHandle.Init.Prescaler         = uwPrescalerValue;
TimHandle.Init.ClockDivision     = 0;
TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimHandle.Init.RepetitionCounter = 0;
if (HAL_TIM_OnePulse_Init(&TimHandle, TIM_OPMODE_SINGLE) != HAL_OK)
Error_Handler();
sConfig.OCMode       = TIM_OCMODE_PWM2;
sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
sConfig.Pulse        = 16383;
sConfig.ICPolarity   = TIM_ICPOLARITY_RISING;
sConfig.ICSelection  = TIM_ICSELECTION_DIRECTTI;
sConfig.ICFilter     = 0;
sConfig.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
sConfig.OCIdleState  = TIM_OCIDLESTATE_RESET;
sConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_OnePulse_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_1, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
if (HAL_TIM_OnePulse_Start(&TimHandle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
while (1)
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_GPIO);
CAN_Config();
if(HAL_CAN_Receive_IT(&CanHandle, CAN_FIFO0) != HAL_OK)
Error_Handler();
CanHandle.pTxMsg->Data[0] = ubKeyNumber;
CanHandle.pTxMsg->Data[1] = 0xAD;
if(HAL_CAN_Transmit(&CanHandle, 10) != HAL_OK)
Error_Handler();
HAL_Delay(10);
while(1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
static void Error_Handler(void)
while(1)
static void CAN_Config(void)
CAN_FilterConfTypeDef sFilterConfig;
static CanTxMsgTypeDef TxMessage;
static CanRxMsgTypeDef RxMessage;
CanHandle.Instance = CAN1;
CanHandle.pTxMsg = &TxMessage;
CanHandle.pRxMsg = &RxMessage;
CanHandle.Init.TTCM = DISABLE;
CanHandle.Init.ABOM = DISABLE;
CanHandle.Init.AWUM = DISABLE;
CanHandle.Init.NART = DISABLE;
CanHandle.Init.RFLM = DISABLE;
CanHandle.Init.TXFP = DISABLE;
CanHandle.Init.Mode = CAN_MODE_NORMAL;
CanHandle.Init.SJW = CAN_SJW_1TQ;
CanHandle.Init.BS1 = CAN_BS1_6TQ;
CanHandle.Init.BS2 = CAN_BS2_8TQ;
CanHandle.Init.Prescaler = 2;
if(HAL_CAN_Init(&CanHandle) != HAL_OK)
Error_Handler();
sFilterConfig.FilterNumber = 0;
sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
sFilterConfig.FilterIdHigh = 0x0000;
sFilterConfig.FilterIdLow = 0x0000;
sFilterConfig.FilterMaskIdHigh = 0x0000;
sFilterConfig.FilterMaskIdLow = 0x0000;
sFilterConfig.FilterFIFOAssignment = 0;
sFilterConfig.FilterActivation = ENABLE;
sFilterConfig.BankNumber = 14;
if(HAL_CAN_ConfigFilter(&CanHandle, &sFilterConfig) != HAL_OK)
Error_Handler();
CanHandle.pTxMsg->StdId = 0x321;
CanHandle.pTxMsg->ExtId = 0x01;
CanHandle.pTxMsg->RTR = CAN_RTR_DATA;
CanHandle.pTxMsg->IDE = CAN_ID_STD;
CanHandle.pTxMsg->DLC = 2;
void HAL_CAN_RxCpltCallback(CAN_HandleTypeDef* CanHandle)
if ((CanHandle->pRxMsg->StdId == 0x321)&&(CanHandle->pRxMsg->IDE == CAN_ID_STD) && (CanHandle->pRxMsg->DLC == 2))
LED_Display(CanHandle->pRxMsg->Data[0]);
ubKeyNumber = CanHandle->pRxMsg->Data[0];
if(HAL_CAN_Receive_IT(CanHandle, CAN_FIFO0) != HAL_OK)
Error_Handler();
void LED_Display(uint8_t LedStatus)
HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOG, GPIO_PIN_14, GPIO_PIN_RESET);
switch(LedStatus)
case(1):
HAL_GPIO_WritePin(GPIOG, GPIO_PIN_13, GPIO_PIN_SET);
break;
case(2):
HAL_GPIO_WritePin(GPIOG, GPIO_PIN_14, GPIO_PIN_SET);
break;
default:
break;
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
LCD_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
HAL_RCCEx_EnableMSIPLLMode();
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
hcryp.Instance      = CRYP;
hcryp.Init.DataType = CRYP_DATATYPE_32B;
hcryp.Init.pKey     = TDESKey;
hcryp.Init.Algorithm = CRYP_TDES_ECB;
HAL_CRYP_Init(&hcryp);
HAL_CRYP_Encrypt(&hcryp, Plaintext, 8, Encryptedtext, TIMEOUT_VALUE);
if(memcmp(Encryptedtext, Ciphertext_ECB, 32) != 0)
Error_Handler();
HAL_CRYP_GetConfig(&hcryp, &Conf);
Conf.pInitVect = InitVector;
Conf.Algorithm = CRYP_TDES_CBC;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Encrypt(&hcryp, Plaintext, 8, Encryptedtext, TIMEOUT_VALUE);
if(memcmp(Encryptedtext, Ciphertext_CBC, 32) != 0)
Error_Handler();
Conf.Algorithm = CRYP_TDES_ECB;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Decrypt(&hcryp, Ciphertext_ECB , 8, Decryptedtext, TIMEOUT_VALUE);
if(memcmp(Decryptedtext, Plaintext, 32) != 0)
Error_Handler();
Conf.Algorithm = CRYP_TDES_CBC;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Decrypt(&hcryp, Ciphertext_CBC, 8, Decryptedtext, TIMEOUT_VALUE);
if(memcmp(Decryptedtext, Plaintext, 32) != 0)
Error_Handler();
else
BSP_LED_On(LED1);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
RTC_DateTypeDef  sdatestructure = {0};
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED4);
RtcHandle.Instance = RTC;
RtcHandle.Init.AsynchPrediv = RTC_AUTO_1_SECOND;
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET)
__HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_BLUE);
if(HAL_RTC_GetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
if ((sdatestructure.Date != 2) ||(sdatestructure.Year != 0x00) || \\
(sdatestructure.Month != RTC_MONTH_JANUARY))
BSP_LED_On(LED_BLUE);
else
BSP_LED_On(LED_GREEN);
sdatestructure.Month = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1);
sdatestructure.Date  = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR2);
sdatestructure.Year  = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR3);
RTC_DateUpdate(&sdatestructure, 1);
if ((sdatestructure.Date == 1) && (sdatestructure.Month == 11) \\
&& (sdatestructure.Year == 14))
BSP_LED_On(LED_BLUE);
else
RTC_AlarmConfig();
if(HAL_RTC_GetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, sdatestructure.Month);
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR2, sdatestructure.Date);
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR3, sdatestructure.Year);
__HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
HAL_PWR_EnterSTANDBYMode();
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV2;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
static void RTC_AlarmConfig(void)
RTC_DateTypeDef  sdatestructure_set = {0};
RTC_TimeTypeDef  stimestructure = {0};
RTC_AlarmTypeDef salarmstructure = {{0}, 0};
sdatestructure_set.Year = 0x14;
sdatestructure_set.Month = RTC_MONTH_OCTOBER;
sdatestructure_set.Date = 0x31;
if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure_set,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
stimestructure.Hours = 0x23;
stimestructure.Minutes = 0x59;
stimestructure.Seconds = 0x55;
if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
salarmstructure.Alarm = RTC_ALARM_A;
salarmstructure.AlarmTime.Hours = 0x00;
salarmstructure.AlarmTime.Minutes = 0x00;
salarmstructure.AlarmTime.Seconds = 0x10;
if(HAL_RTC_SetAlarm_IT(&RtcHandle,&salarmstructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
static void RTC_DateUpdate(RTC_DateTypeDef* pDate, uint32_t DayElapsed)
uint32_t year = 0, month = 0, day = 0;
uint32_t loop = 0;
year  = pDate->Year;
month = pDate->Month;
day   = pDate->Date;
for (loop = 0; loop < DayElapsed; loop++)
if((month == 1) || (month == 3) || (month == 5) || (month == 7) || \\
(month == 8) || (month == 10) || (month == 12))
if(day < 31)
day++;
else
if(month != 12)
month++;
day = 1;
else
month = 1;
day = 1;
year++;
else if((month == 4) || (month == 6) || (month == 9) || (month == 11))
if(day < 30)
day++;
else
month++;
day = 1;
else if(month == 2)
if(day < 28)
day++;
else if(day == 28)
if(RTC_IsLeapYear(year))
day++;
else
month++;
day = 1;
else if(day == 29)
month++;
day = 1;
pDate->Year = year;
pDate->Month = month;
pDate->Date = day;
pDate->WeekDay = RTC_WeekDayNum(year, month, day);
static uint8_t RTC_IsLeapYear(uint16_t nYear)
if((nYear % 4) != 0)
return 0;
if((nYear % 100) != 0)
return 1;
if((nYear % 400) == 0)
return 1;
else
return 0;
static uint8_t RTC_WeekDayNum(uint32_t nYear, uint8_t nMonth, uint8_t nDay)
uint32_t year = 0, weekday = 0;
year = 2000 + nYear;
if(nMonth < 3)
weekday = (((23 * nMonth)/9) + nDay + 4 + year + ((year-1)/4) - ((year-1)/100) + ((year-1)/400)) % 7;
else
weekday = (((23 * nMonth)/9) + nDay + 4 + year + (year/4) - (year/100) + (year/400) - 2 ) % 7;
return (uint8_t)weekday;
void Error_Handler(void)
while(1)
BSP_LED_Toggle(LED4);
HAL_Delay(100);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int32_t hal_uart_init(uart_dev_t *uart)
_uart_drv_t *pdrv = &_uart_drv[uart->port];
int reval;
if(pdrv->status == _UART_STATUS_CLOSED)
pdrv->rx_buf = (uint8_t *)aos_malloc(s_uart_buffersize_table[uart->port]);
if(NULL == pdrv->rx_buf){
while(1);
ring_buffer_init(&pdrv->rx_ringbuf, pdrv->rx_buf, s_uart_buffersize_table[uart->port]);
reval = aos_sem_new(&pdrv->rx_semphr, 0);
if(reval != 0)
while(1);
reval = aos_mutex_new(&pdrv->tx_mutex);
if(reval != 0)
while(1);
dev_uart_init(uart);
pdrv->status = _UART_STATUS_OPENED;
else{
while(1);
return 0;
void dev_uart_init(uart_dev_t *uart)
nvic_irq_enable(s_uart_irqn[uart->port], 0, 0);
rcu_periph_clock_enable(s_uart_gpio_clk_table[uart->port]);
rcu_periph_clock_enable(s_uart_clk_table[uart->port]);
gpio_af_set(s_uart_gpio_table[uart->port], GPIO_AF_1, s_uart_txpin_table[uart->port]);
gpio_af_set(s_uart_gpio_table[uart->port], GPIO_AF_1, s_uart_rxpin_table[uart->port]);
gpio_mode_set(s_uart_gpio_table[uart->port], GPIO_MODE_AF, GPIO_PUPD_PULLUP, s_uart_txpin_table[uart->port]);
gpio_output_options_set(s_uart_gpio_table[uart->port], GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, s_uart_txpin_table[uart->port]);
gpio_mode_set(s_uart_gpio_table[uart->port], GPIO_MODE_AF, GPIO_PUPD_PULLUP, s_uart_rxpin_table[uart->port]);
gpio_output_options_set(s_uart_gpio_table[uart->port], GPIO_OTYPE_PP, GPIO_OSPEED_50MHZ, s_uart_rxpin_table[uart->port]);
usart_deinit(s_uart_periph_table[uart->port]);
usart_baudrate_set(s_uart_periph_table[uart->port], uart->config.baud_rate);
usart_receive_config(s_uart_periph_table[uart->port], USART_RECEIVE_ENABLE);
usart_transmit_config(s_uart_periph_table[uart->port], USART_TRANSMIT_ENABLE);
switch(uart->config.data_width){
case DATA_WIDTH_9BIT:
usart_word_length_set(s_uart_periph_table[uart->port], USART_WL_9BIT);
break;
case DATA_WIDTH_8BIT:
usart_word_length_set(s_uart_periph_table[uart->port], USART_WL_8BIT);
break;
default:
while(1);
switch(uart->config.parity){
case NO_PARITY:
usart_parity_config(s_uart_periph_table[uart->port], USART_PM_NONE);
break;
case ODD_PARITY:
usart_parity_config(s_uart_periph_table[uart->port], USART_PM_ODD);
break;
case EVEN_PARITY:
usart_parity_config(s_uart_periph_table[uart->port], USART_PM_EVEN);
break;
default:
while(1);
switch(uart->config.stop_bits){
case STOP_BITS_1:
usart_stop_bit_set(s_uart_periph_table[uart->port], USART_STB_1BIT);
break;
case STOP_BITS_2:
usart_stop_bit_set(s_uart_periph_table[uart->port], USART_STB_2BIT);
break;
default:
break;
switch(uart->config.flow_control){
case FLOW_CONTROL_DISABLED:
usart_hardware_flow_rts_config(s_uart_periph_table[uart->port], USART_RTS_DISABLE);
usart_hardware_flow_cts_config(s_uart_periph_table[uart->port], USART_CTS_DISABLE);
break;
case FLOW_CONTROL_CTS:
usart_hardware_flow_rts_config(s_uart_periph_table[uart->port], USART_RTS_DISABLE);
usart_hardware_flow_cts_config(s_uart_periph_table[uart->port], USART_CTS_ENABLE);
break;
case FLOW_CONTROL_RTS:
usart_hardware_flow_rts_config(s_uart_periph_table[uart->port], USART_RTS_ENABLE);
usart_hardware_flow_cts_config(s_uart_periph_table[uart->port], USART_CTS_DISABLE);
break;
case FLOW_CONTROL_CTS_RTS:
usart_hardware_flow_rts_config(s_uart_periph_table[uart->port], USART_RTS_ENABLE);
usart_hardware_flow_cts_config(s_uart_periph_table[uart->port], USART_CTS_ENABLE);
break;
default:
break;
usart_enable(s_uart_periph_table[uart->port]);
usart_interrupt_enable(s_uart_periph_table[uart->port], USART_INT_RBNE);
static int _dev_uart_putchar(uart_dev_t *uart, int ch)
volatile uint32_t i;
while(RESET == usart_flag_get(s_uart_periph_table[uart->port], USART_FLAG_TBE));
for(i = 0; i < 200; i++);
usart_data_transmit(s_uart_periph_table[uart->port], (uint8_t)ch);
return ch;
int32_t hal_uart_send(uart_dev_t *uart, const void *data, uint32_t size, uint32_t timeout)
uint8_t* pTmp = (uint8_t*)data;
_uart_drv_t *pdrv = &_uart_drv[uart->port];
aos_mutex_lock(&pdrv->tx_mutex, AOS_WAIT_FOREVER);
for (int i = 0; i < size; i++) {
_dev_uart_putchar(uart, *pTmp++);
aos_mutex_unlock(&pdrv->tx_mutex);
return 0;
int32_t hal_uart_recv_II(uart_dev_t *uart, void *data, uint32_t expect_size, uint32_t *recv_size, uint32_t timeout)
uint32_t read_size, actual_size, tmp;
uint32_t ringbuf_size;
uint32_t start_time, expired_time;
_uart_drv_t *pdrv = &_uart_drv[uart->port];
uint8_t *p_data;
p_data = data;
recv_size = recv_size == NULL ? &actual_size : recv_size;
start_time = aos_now_ms();
expired_time = 0;
*recv_size = 0;
ringbuf_size = pdrv->rx_ringbuf.size - 1;
for(;;)
read_size = expect_size > ringbuf_size ? ringbuf_size : expect_size;
if(read_size > ring_buffer_used_space( &pdrv->rx_ringbuf ))
pdrv->rx_size = read_size;
if ( aos_sem_wait( &pdrv->rx_semphr, timeout - expired_time) != 0)
pdrv->rx_size = 0;
return -1;
ring_buffer_read(&pdrv->rx_ringbuf, p_data, read_size, &tmp);
p_data += read_size;
*recv_size += read_size;
expect_size -= read_size;
if(expect_size == 0)
break;
expired_time = aos_now_ms() - start_time;
if(expired_time > timeout)
return -1;
return 0;
int32_t hal_uart_finalize(uart_dev_t *uart)
_uart_drv_t *pdrv = &_uart_drv[uart->port];
while(usart_flag_get(s_uart_periph_table[uart->port], USART_FLAG_TBE) != SET);
usart_deinit(s_uart_clk_table[uart->port]);
rcu_periph_clock_disable(s_uart_clk_table[uart->port]);
ring_buffer_deinit(&pdrv->rx_ringbuf);
aos_free(pdrv->rx_buf);
aos_sem_free(&pdrv->rx_semphr);
aos_mutex_free(&pdrv->tx_mutex);
pdrv->status = _UART_STATUS_CLOSED;
return 0;
void uart_rx_cb(uint8_t port)
uint8_t rx_byte;
volatile uint32_t val;
_uart_drv_t *pdrv = &_uart_drv[port];
if(RESET != usart_flag_get(s_uart_periph_table[port], USART_FLAG_ORERR)){
usart_flag_clear(s_uart_periph_table[port], USART_FLAG_ORERR);
if(RESET != usart_flag_get(s_uart_periph_table[port], USART_FLAG_RBNE)){
rx_byte = usart_data_receive(s_uart_periph_table[port]);
if(0 == ring_buffer_write(&pdrv->rx_ringbuf, &rx_byte, 1)){
printf("ring buffer overflow!! \\r\\n");
while(1);
if ( pdrv->rx_size > 0 && ring_buffer_used_space( &pdrv->rx_ringbuf ) >= pdrv->rx_size )
aos_sem_signal( &pdrv->rx_semphr );
pdrv->rx_size = 0;
void USART0_IRQHandler(void)
krhino_intrpt_enter();
uart_rx_cb(0);
krhino_intrpt_exit();
void USART1_IRQHandler(void)
krhino_intrpt_enter();
uart_rx_cb(1);
krhino_intrpt_exit();
int main(void)
uint8_t  lcd_status = LCD_OK;
CameraResX = QVGA_RES_X;
CameraResY = QVGA_RES_Y;
LcdResX    = WVGA_RES_X;
LcdResY    = WVGA_RES_Y;
loopCnt = 0;
start_the_camera_capture = 0;
cam_frame_buffer_ready = 0;
offset_address_area_cam_in_lcd_buffer =  ((((LcdResY - CameraResY) / 2) * LcdResX)
+   ((LcdResX - CameraResX) / 2))
* ARGB8888_BYTE_PER_PIXEL;
LTDC_Layer1_Dbg =  LTDC_Layer1;
LTDC_Layer2_Dbg =  LTDC_Layer2;
HAL_Init();
SystemClock_Config();
HAL_Delay(100);
BSP_IO_Init();
BSP_LED_Init(LED3);
BSP_LCD_Init();
while(lcd_status != LCD_OK);
BSP_LCD_LayerDefaultInit(0, LCD_FB_START_ADDRESS);
BSP_LCD_SelectLayer(0);
if(BSP_LCD_GetXSize() > BSP_LCD_GetYSize())
lcd_display_orientation = LCD_ORIENTATION_LANDSCAPE;
else
lcd_display_orientation = LCD_ORIENTATION_PORTRAIT;
BSP_LCD_Clear(LCD_COLOR_BLACK);
BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
BSP_LCD_SetFont(&Font16);
BSP_LCD_DisplayStringAt(0, 440, (uint8_t *)"DCMI Capture example", CENTER_MODE);
HAL_Delay(100);
lcd_status = LCD_LTDC_PatchPitch();
OnError_Handler(lcd_status != LCD_OK);
lcd_status = CameraFrameBufferRgb565_Init(CameraResX, CameraResY, 0x55555555);
OnError_Handler(lcd_status != LCD_OK);
BSP_CAMERA_Init(CAMERA_R320x240);
HAL_Delay(1000);
BSP_CAMERA_ContinuousStart((uint8_t *)CAMERA_FRAME_BUFFER);
while(start_the_camera_capture == 0) {;}
while (1)
loopCnt++;
while (cam_frame_buffer_ready == 0) {       ;    }
lcd_status = CopyCamFrameBufferToLcdFrameBuffer((void*) CAMERA_FRAME_BUFFER,
(void*) (LCD_FRAME_BUFFER + offset_address_area_cam_in_lcd_buffer),
CameraResX, CameraResY);
OnError_Handler(lcd_status != LCD_OK);
cam_frame_buffer_ready = 0;
void BSP_CAMERA_FrameEventCallback(void)
if(start_the_camera_capture == 0)
start_the_camera_capture = 1;
if((start_the_camera_capture == 1) && (cam_frame_buffer_ready == 0))
cam_frame_buffer_ready = 1;
static uint8_t CopyCamFrameBufferToLcdFrameBuffer(void *pSrc, void *pDst, uint32_t xSize, uint32_t ySize)
DMA2D_HandleTypeDef hdma2d_eval;
HAL_StatusTypeDef hal_status = HAL_OK;
uint8_t lcd_status = LCD_ERROR;
hdma2d_eval.Init.Mode         = DMA2D_M2M_PFC;
hdma2d_eval.Init.ColorMode    = DMA2D_ARGB8888;
hdma2d_eval.Init.OutputOffset = (LcdResX - CameraResX);
hdma2d_eval.LayerCfg[1].AlphaMode = DMA2D_NO_MODIF_ALPHA;
hdma2d_eval.LayerCfg[1].InputAlpha = 0xFF;
hdma2d_eval.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
hdma2d_eval.LayerCfg[1].InputOffset = 0;
hdma2d_eval.Instance = DMA2D;
if(HAL_DMA2D_Init(&hdma2d_eval) == HAL_OK)
if(HAL_DMA2D_ConfigLayer(&hdma2d_eval, 1) == HAL_OK)
if (HAL_DMA2D_Start(&hdma2d_eval, (uint32_t)pSrc, (uint32_t)pDst, xSize, ySize) == HAL_OK)
hal_status = HAL_DMA2D_PollForTransfer(&hdma2d_eval, 10);
if(hal_status == HAL_OK)
lcd_status = LCD_OK;
return(lcd_status);
static uint8_t CameraFrameBufferRgb565_Init(uint32_t sizeX, uint32_t sizeY, uint32_t argb8888_Value)
HAL_StatusTypeDef hal_status = HAL_OK;
uint8_t lcd_status = LCD_ERROR;
DMA2D_HandleTypeDef hdma2d_eval;
if((sizeX <= CAMERA_VGA_RES_X) && (sizeY <= CAMERA_VGA_RES_Y))
hdma2d_eval.Init.Mode         = DMA2D_R2M;
hdma2d_eval.Init.ColorMode    = DMA2D_RGB565;
hdma2d_eval.Init.OutputOffset = 0x0;
hdma2d_eval.Instance = DMA2D;
hal_status = HAL_DMA2D_Init(&hdma2d_eval);
if(hal_status == HAL_OK)
if (HAL_DMA2D_Start(&hdma2d_eval, argb8888_Value, (uint32_t)CAMERA_FRAME_BUFFER, sizeX, sizeY) == HAL_OK)
HAL_DMA2D_PollForTransfer(&hdma2d_eval, 10);
lcd_status = LCD_OK;
return (lcd_status);
static uint8_t LCD_LTDC_PatchPitch(void)
uint8_t lcd_status = LCD_ERROR;
uint32_t pitch_update = ((LcdResX * ARGB8888_BYTE_PER_PIXEL) << 16);
LTDC_Layer2->CFBLR &= ~(LTDC_LxCFBLR_CFBP);
LTDC->SRCR |= LTDC_SRCR_IMR;
LTDC_Layer2->CFBLR |= pitch_update;
LTDC->SRCR |= LTDC_SRCR_IMR;
lcd_status = LCD_OK;
return(lcd_status);
static void OnError_Handler(uint32_t condition)
if(condition)
BSP_LED_On(LED3);
while(1) { ; }
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 6;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
osThreadDef(RAMDiskThread, StartThread, osPriorityNormal, 0, 2 * configMINIMAL_STACK_SIZE);
osThreadCreate(osThread(RAMDiskThread), NULL);
osKernelStart();
for( ;; );
static void StartThread(void const *argument)
FRESULT res;
uint32_t byteswritten, bytesread;
uint8_t wtext[] = "This is STM32 working with FatFs";
uint8_t rtext[100];
if(FATFS_LinkDriver(&SDRAMDISK_Driver, RAMDISKPath) == 0)
if(f_mount(&RAMDISKFatFs, (TCHAR const*)RAMDISKPath, 0) != FR_OK)
Error_Handler();
else
if(f_mkfs((TCHAR const*)RAMDISKPath, FM_ANY, 0, buffer, sizeof(buffer)) != FR_OK)
Error_Handler();
else
if(f_open(&MyFile, "STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
Error_Handler();
else
res = f_write(&MyFile, wtext, sizeof(wtext), (void *)&byteswritten);
if((byteswritten == 0) || (res != FR_OK))
Error_Handler();
else
f_close(&MyFile);
if(f_open(&MyFile, "STM32.TXT", FA_READ) != FR_OK)
Error_Handler();
else
res = f_read(&MyFile, rtext, sizeof(rtext), (void *)&bytesread);
if((bytesread == 0) || (res != FR_OK))
Error_Handler();
else
f_close(&MyFile);
if((bytesread != byteswritten))
Error_Handler();
else
BSP_LED_On(LED1);
FATFS_UnLinkDriver(RAMDISKPath);
for( ;; )
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
Error_Handler();
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C2_Init();
LCD_ini();
while (1)
LCD_SetPos(17,0);
spintf(str, "ABS");
LCD_String(str);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.ClockSpeed = 100000;
hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
uint16_t *getADCbuffer(void)
return AD_RES;
int main(void)
HAL_Init();
ProcessInit();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USB_DEVICE_Init();
MX_TIM7_Init();
MX_ADC1_Init();
HAL_TIM_Base_Start_IT(&htim7);
MX_USB_MIDI_INIT();
HAL_ADC_Start_DMA(&hadc1, (uint32_t*) AD_RES, 10);
if(FUNC_ERROR == midiInit() ){
while(1){
HAL_GPIO_WritePin(LD_PWR_GPIO_Port, LD_PWR_Pin, (GPIO_PinState)SET);
HAL_Delay(500);
HAL_GPIO_WritePin(LD_PWR_GPIO_Port, LD_PWR_Pin, (GPIO_PinState)RESET);
HAL_Delay(500);
while (1)
HAL_Delay(1);
ProcessExecute();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = ENABLE;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 10;
hadc1.Init.DMAContinuousRequests = ENABLE;
hadc1.Init.EOCSelection = ADC_EOC_SEQ_CONV;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_8;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_28CYCLES;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_9;
sConfig.Rank = 2;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_0;
sConfig.Rank = 3;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_1;
sConfig.Rank = 4;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_2;
sConfig.Rank = 5;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_3;
sConfig.Rank = 6;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_11;
sConfig.Rank = 7;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_12;
sConfig.Rank = 8;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_14;
sConfig.Rank = 9;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_15;
sConfig.Rank = 10;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_TIM7_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim7.Instance = TIM7;
htim7.Init.Prescaler = 999;
htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
htim7.Init.Period = 83;
htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA2_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOE, CS_I2C_SPI_Pin|LD_Exp2_Pin|LD_Exp1_Pin|LD_PWR_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, StompLED01_Pin|StompLED02_Pin|StompLED03_Pin|StompLED04_Pin
|StompLED05_Pin|StompLED07_Pin|StompLED08_Pin|StompLED09_Pin
|StompLED10_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin|StompLED06_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = StompBtn07_Pin|StompBtn08_Pin|StompBtn09_Pin|StompBtn10_Pin
|StompBtn01_Pin|StompBtn02_Pin|StompBtn03_Pin|StompBtn04_Pin
|StompBtn05_Pin|StompBtn06_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin|LD_Exp2_Pin|LD_Exp1_Pin|LD_PWR_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = I2S3_WS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(I2S3_WS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SPI1_SCK_Pin|SPI1_MISO_Pin|SPI1_MOSI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = StompLED01_Pin|StompLED02_Pin|StompLED03_Pin|StompLED04_Pin
|StompLED05_Pin|StompLED07_Pin|StompLED08_Pin|StompLED09_Pin
|StompLED10_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin|StompLED06_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = I2S3_MCK_Pin|I2S3_SCK_Pin|I2S3_SD_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART2_UART_Init();
MX_ADC1_Init();
while (1)
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = ENABLE;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 16;
hadc1.Init.DMAContinuousRequests = ENABLE;
hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 2;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 3;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 4;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 5;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 6;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 7;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 8;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 9;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 10;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 11;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 12;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 13;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 14;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 15;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfig.Rank = 16;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA2_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
SystemClock_Config();
BSP_LED_Toggle(LED3);
count_tasks_start(NULL);
vTaskStartScheduler();
while (1) ;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
BSP_LED_On(LED4);
static void Error_Handler(void)
BSP_LED_On(LED4);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
static void count_tasks_start(void * parameter)
TaskHandle_t manager_handle;
BaseType_t result = pdTRUE;
result = xTaskCreate(manager_task, "manager", MANAGER_STACK_DEPTH, (void *)NULL, 1, &manager_handle);
ASSERT(result == pdFALSE);
static void manager_task(void * parameter)
(void)parameter;
UART_HandleTypeDef *huart;
pkg_t *pkg;
BaseType_t result;
uint32_t i, len;
uint8_t buff[32];
huart = (UART_HandleTypeDef *)pvPortMalloc(sizeof(UART_HandleTypeDef));
ASSERT(huart == NULL);
pkg = (pkg_t *)pvPortMalloc(sizeof(pkg_t) * 4);
ASSERT(pkg == NULL);
huart->Instance          = USARTx;
huart->Init.BaudRate     = 9600;
huart->Init.WordLength   = UART_WORDLENGTH_8B;
huart->Init.StopBits     = UART_STOPBITS_1;
huart->Init.Parity       = UART_PARITY_NONE;
huart->Init.HwFlowCtl    = UART_HWCONTROL_NONE;
huart->Init.Mode         = UART_MODE_TX_RX;
huart->Init.OverSampling = UART_OVERSAMPLING_16;
ASSERT(HAL_UART_Init(huart) != HAL_OK);
for (i = 0;i < 4;++i) {
pkg[i].count = 0;
memset(pkg[i].task_name, '\\0', 16);
memcpy(pkg[i].task_name, "worker_", 7);
pkg[i].task_name[7] = '0' + i;
result = xTaskCreate(
work_task,
(char *)pkg[i].task_name,
WORKER_STACK_DEPTH,
(void *)&pkg[i].count,
0,
&pkg[i].task_handle);
ASSERT(result == pdFALSE);
while (1) {
vTaskDelay(40);
for (i = 0;i < 4;++i) {
memset(buff, '\\0', 32);
len = strlen((char *)pkg[i].task_name);
memcpy(buff, pkg[i].task_name, len);
buff[len++] = ':';
itoa(pkg[i].count, buff+len);
len += strlen((char *)buff+len);
memcpy(buff+len, "\\r\\n", 2);
len += 2;
uart_send(huart, buff, len);
static void work_task(void * parameter)
uint32_t old_tick = 0, new_tick = 0;
uint32_t *count_ptr;
count_ptr = (uint32_t *)parameter;
old_tick = new_tick = HAL_GetTick();
while (1) {
new_tick = HAL_GetTick();
if (old_tick != new_tick) {
old_tick = new_tick;
++(*count_ptr);
HAL_Delay(1);
static void uart_send(UART_HandleTypeDef *huart, uint8_t *buff, uint32_t len)
ASSERT(HAL_UART_Transmit(huart, buff, len, HAL_MAX_DELAY)!= HAL_OK);
static void itoa(int32_t num, uint8_t *str)
uint8_t *tmp = str,
sign = 0;
if (num < 0) {
sign = 1;
num = ~num + 1;
do {
*tmp = '0' + num % 10;
++tmp;
num /= 10;
} while (num) ;
if (sign) {
*tmp = '-';
++tmp;
reverse(str, tmp-1);
static void reverse(uint8_t *begin, uint8_t *end)
uint8_t tmp;
while (begin < end) {
tmp = *begin;
*begin = *end;
*end = tmp;
++begin;
--end;
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
USART2_UART_Init();
ssd1331_init();
printf("hello stm32\\r\\n");
ssd1331_gotoxy(10, 4);
ssd1331_puts("Hello STM32", &FontSet_10, SSD1331_COLOR_RED, 1);
ssd1331_gotoxy(15, 25);
ssd1331_puts("OLED출력테스트", &FontSet_16, SSD1331_COLOR_GREEN, 1);
ssd1331_drawcircle(60, 40, 10, SSD1331_COLOR_YELLOW);
ssd1331_drawcircle(60, 40, 20, SSD1331_COLOR_ORANGE);
ssd1331_drawcircle(60, 40, 30, SSD1331_COLOR_WHITE);
for(;;) {
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void USART2_UART_Init(void)
__GPIOA_CLK_ENABLE();
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&huart2);
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
GPIO_InitTypeDef GPIO_InitStruct;
if (huart->Instance==USART2) {
__USART2_CLK_ENABLE();
GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART2_IRQn);
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
if (huart->Instance==USART2) {
__USART2_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOA, USART_TX_Pin|USART_RX_Pin);
HAL_NVIC_DisableIRQ(USART2_IRQn);
void MX_TIM3_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim3.Instance = TIM3;
htim3.Init.Prescaler = 8000;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 50000;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
Error_Handler();
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* tim_baseHandle)
if(tim_baseHandle->Instance==TIM3)
__HAL_RCC_TIM3_CLK_ENABLE();
void HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle)
if(tim_baseHandle->Instance==TIM3)
__HAL_RCC_TIM3_CLK_DISABLE();
void TIM3_IRQHandler(void)
HAL_TIM_IRQHandler(&htim3);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_I2S3_Init();
MX_SPI1_Init();
MX_USB_DEVICE_Init();
HAL_GPIO_WritePin( LD4_GPIO_Port, LD4_Pin, GPIO_PIN_SET );
while (1)
if ( data_out_flag ) {
extern int8_t CDC_is_busy(void);
HAL_GPIO_TogglePin( LD3_GPIO_Port, LD3_Pin);
if ( CDC_is_busy()) continue;
data_out_flag = 0;
data_sent = data_received;
memmove( TxData, RxData, data_received );
data_received = 0;
CDC_Transmit_FS( TxData, data_sent );
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_I2S3_Init(void)
hi2s3.Instance = SPI3;
hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
hi2s3.Init.CPOL = I2S_CPOL_LOW;
hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
if (HAL_I2S_Init(&hi2s3) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
LL_SPI_Enable(hspi1.Instance);
while(ubNbDataToReceive > 0)
if(( LL_SPI_IsActiveFlag_TXE(hspi1.Instance)) && (ubNbDataToTransmit > 0))
LL_SPI_TransmitData16(hspi1.Instance, aTxBuffer[ubTransmitIndex++]);
ubNbDataToTransmit--;
if(LL_SPI_IsActiveFlag_RXNE(hspi1.Instance))
aRxBuffer[ubReceiveIndex++] = LL_SPI_ReceiveData16(hspi1.Instance);
ubNbDataToReceive--;
if (Buffercmp((uint8_t *)aTxBuffer, (uint8_t *)aRxBuffer, COUNTOF(aTxBuffer)))
Error_Handler();
else
BSP_LED_On(LED1);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_SLAVE;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_16BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOA_CLK_ENABLE();
static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
while (BufferLength--)
if((*pBuffer1) != *pBuffer2)
return BufferLength;
pBuffer1++;
pBuffer2++;
return 0;
void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t *file, uint32_t line)
for (int i = 0; i < picc.size; i++)
sprintf(str + strlen(str), "%02X", picc.uidByte[i]);
print(str, line);
} else {
print("No Card found", line);
for (int i = 0 ; i < 20 ; i++)
buff[i] = cpos == i ? '^' : ' ';
buff[20] = 0;
if (!count) strcpy(datetimestring, "20yy-mm-dd HH:MM:SS");
if (key_pressed) {
if (key_pressed == 'D') {
count--;
switch (count) {
case 0:
if (key_pressed >= '0' && key_pressed <= '9') {
datetimestring[cpos] = key_pressed;
count++;
break;
case 1:
if (key_pressed >= '0' && key_pressed <= '9') {
datetimestring[cpos] = key_pressed;
count++;
break;
case 2:
if (key_pressed >= '0' && key_pressed <= '1') {
datetimestring[cpos] = key_pressed;
count++;
break;
case 3:
if ((datetimestring[5] == '1' && key_pressed >= '0'
&& key_pressed <= '2')
|| (datetimestring[5] == '0' && key_pressed >= '1'
&& key_pressed <= '9')) {
datetimestring[cpos] = key_pressed;
count++;
break;
case 4:
if ((key_pressed != '3' || !
(datetimestring[5] == '0' && datetimestring[6] == '2')
)
&& (key_pressed >= '0' && key_pressed <= '3'))
datetimestring[cpos] = key_pressed;
count++;
break;
case 5:
if (key_pressed >= '0' && key_pressed <= '9') {
datetimestring[cpos] = key_pressed;
count++;
break;
break;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_SPI1_Init();
uint8_t address = 0x20;
uint8_t data = 0x67;
uint8_t x, y, z;
char debugTxt[50];
HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi1, &address, 1, 50);
HAL_SPI_Transmit(&hspi1, &data, 1, 50);
HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_SET);
int rotateThreshold = 20;
while (1) {
address = 0x29 | 0x80;
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi1, &address, 1, 50);
HAL_SPI_Receive(&hspi1, &x, 1, 50);
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_SET);
address = 0x2B | 0x80;
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi1, &address, 1, 50);
HAL_SPI_Receive(&hspi1, &y, 1, 50);
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_SET);
address = 0x2C | 0x80;
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_RESET);
HAL_SPI_Transmit(&hspi1, &address, 1, 50);
HAL_SPI_Receive(&hspi1, &z, 1, 50);
HAL_GPIO_WritePin(GPIOE,GPIO_PIN_3,GPIO_PIN_SET);
if (x < 255 - rotateThreshold && x > 128) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET);
} else if (x <= 128 && x > rotateThreshold) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET);
} else {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET);
if (y > rotateThreshold && y < 128) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);
} else if (y >= 128 && y < 255 - rotateThreshold) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
} else {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);
for(int i = 0; i < 50; ++i) debugTxt[i] = 0;
sprintf(debugTxt, "\\r\\nAccelerometer - x: %d, y: %d, z: %d", x, y, z);
HAL_UART_Transmit(&huart2, (uint8_t*)debugTxt, 50, 100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 50;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_7|I2S3_SCK_Pin|GPIO_PIN_12;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = VBUS_FS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
while (1) {
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
hcryp.Instance       = CRYP;
hcryp.Init.DataType  = CRYP_DATATYPE_32B;
hcryp.Init.pKey      = TDESKey;
hcryp.Init.Algorithm = CRYP_TDES_ECB;
HAL_CRYP_Init(&hcryp);
HAL_CRYP_Encrypt(&hcryp, Plaintext, 8, Encryptedtext, TIMEOUT_VALUE);
if(memcmp(Encryptedtext, Ciphertext_ECB, 32) != 0)
Error_Handler();
HAL_CRYP_GetConfig(&hcryp, &Conf);
Conf.pInitVect = InitVector;
Conf.Algorithm = CRYP_TDES_CBC;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Encrypt(&hcryp, Plaintext, 8, Encryptedtext, TIMEOUT_VALUE);
if(memcmp(Encryptedtext, Ciphertext_CBC, 32) != 0)
Error_Handler();
Conf.Algorithm = CRYP_TDES_ECB;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Decrypt(&hcryp, Ciphertext_ECB , 8, Decryptedtext, TIMEOUT_VALUE);
if(memcmp(Decryptedtext, Plaintext, 32) != 0)
Error_Handler();
Conf.Algorithm = CRYP_TDES_CBC;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Decrypt(&hcryp, Ciphertext_CBC, 8, Decryptedtext, TIMEOUT_VALUE);
if(memcmp(Decryptedtext, Plaintext, 32) != 0)
Error_Handler();
else
BSP_LED_On(LED1);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
if(HAL_Init()!= HAL_OK)
Error_Handler();
SystemClock_Config();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
uwPrescalerValue = (uint32_t) ((SystemCoreClock / 10000) - 1);
TimHandle.Instance = TIMx;
TimHandle.Init.Period = 10000 - 1;
TimHandle.Init.Prescaler = uwPrescalerValue;
TimHandle.Init.ClockDivision = 0;
TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK)
Error_Handler();
if(HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK)
Error_Handler();
while (1)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
BSP_LED_Toggle(LED4);
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
UartHandle.Instance        = USARTx;
UartHandle.Init.BaudRate   = 9600;
UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits   = UART_STOPBITS_1;
UartHandle.Init.Parity     = UART_PARITY_ODD;
UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
UartHandle.Init.Mode       = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
printf("\\n\\r UART Printf Example: retarget the C library printf function to the UART\\n\\r");
printf("** Test finished successfully. ** \\n\\r");
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED2);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LED_Init(LED5);
BSP_LED_Init(LED6);
SystemClock_Config();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
while (!UserPressButton)
Toggle_Leds();
BSP_LED_Off(LED3);
BSP_LED_Off(LED4);
BSP_LED_Off(LED5);
BSP_LED_Off(LED6);
while(1)
UserPressButton = 0;
BSP_examples[DemoIndex++].DemoFunc();
if(DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples))
DemoIndex = 0;
UserPressButton = 0;
while (!UserPressButton) Toggle_Leds();
BSP_LED_Off(LED3);
BSP_LED_Off(LED4);
BSP_LED_Off(LED5);
BSP_LED_Off(LED6);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (KEY_BUTTON_PIN == GPIO_Pin)
while (BSP_PB_GetState(BUTTON_KEY) != RESET);
UserPressButton = 1;
if(ACCELERO_INT2_PIN == GPIO_Pin)
BSP_ACCELERO_Click_ITClear();
if (PressCount == 1)
PauseResumeStatus = RESUME_STATUS;
PressCount = 0;
else
PauseResumeStatus = PAUSE_STATUS;
PressCount = 1;
void Toggle_Leds(void)
BSP_LED_Toggle(LED3);
HAL_Delay(100);
BSP_LED_Toggle(LED4);
HAL_Delay(100);
BSP_LED_Toggle(LED5);
HAL_Delay(100);
BSP_LED_Toggle(LED6);
HAL_Delay(100);
void Error_Handler(void)
BSP_LED_On(LED5);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
SystemClock_Config();
UartHandle.Instance          = USARTx;
UartHandle.Init.BaudRate     = 9600;
UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits     = UART_STOPBITS_1;
UartHandle.Init.Parity       = UART_PARITY_NONE;
UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
UartHandle.Init.Mode         = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
while (BSP_PB_GetState(BUTTON_KEY) == RESET)
if(HAL_UART_Transmit_DMA(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE)!= HAL_OK)
Error_Handler();
while (UartReady != SET)
UartReady = RESET;
BSP_LED_Off(LED3);
if(HAL_UART_Receive_DMA(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE) != HAL_OK)
Error_Handler();
if(HAL_UART_Receive_DMA(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE) != HAL_OK)
Error_Handler();
while (UartReady != SET)
UartReady = RESET;
BSP_LED_Off(LED3);
if(HAL_UART_Transmit_DMA(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE)!= HAL_OK)
Error_Handler();
while (UartReady != SET)
UartReady = RESET;
if(Buffercmp((uint8_t*)aTxBuffer,(uint8_t*)aRxBuffer,RXBUFFERSIZE))
Error_Handler();
while (1)
BSP_LED_Toggle(LED3);
HAL_Delay(40);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
UartReady = SET;
BSP_LED_On(LED3);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle)
UartReady = SET;
BSP_LED_On(LED3);
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
BSP_LED_On(LED3);
static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
while (BufferLength--)
if ((*pBuffer1) != *pBuffer2)
return BufferLength;
pBuffer1++;
pBuffer2++;
return 0;
static void Error_Handler(void)
BSP_LED_On(LED4);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART2_UART_Init();
MX_USART1_UART_Init();
MX_USB_DEVICE_Init();
SBUS_Init(&sbus, &huart1);
while (1)
int8_t report[8];
if (sbus.flags != SBUS_FAILSAFE_ACTIVE) {
for (int x = 0; x < 8; x++) {
report[x] = _constrain(_map(sbus.ch[x], SBUS_DIGITAL_CHANNEL_MIN, SBUS_DIGITAL_CHANNEL_MAX, -127, 127), -127, 127);
} else {
for (int x = 0; x < 8; x++) {
report[x] = 0;
USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, (uint8_t*) report, 8);
HAL_Delay(2);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
|RCC_PERIPHCLK_USB;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_RCCEx_EnableMSIPLLMode();
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
void StartDefaultTask(void const * argument)
for(;;)
osDelay(1000);
void StartDialogTask(void const * argument)
Dialog_Init(&huart1);
osDelay(500);
printf("StartComTask\\r\\n");
for(;;)
Dialog_Process();
void StartBlinkLedTask(void const * argument)
for(;;)
HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET);
osDelay(250);
HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET);
osDelay(250);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
UartHandle.Instance        = USARTx;
UartHandle.Init.BaudRate     = 115200;
UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits     = UART_STOPBITS_1;
UartHandle.Init.Parity       = UART_PARITY_NONE;
UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
UartHandle.Init.Mode         = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_DeInit(&UartHandle) != HAL_OK)
Error_Handler();
if(HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
while(UserButtonStatus == 0)
BSP_LED_Toggle(LED2);
HAL_Delay(100);
BSP_LED_Off(LED2);
if(HAL_UART_Transmit(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE, 5000)!= HAL_OK)
Error_Handler();
BSP_LED_On(LED2);
if(HAL_UART_Receive(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE, 5000) != HAL_OK)
Error_Handler();
BSP_LED_On(LED2);
if(HAL_UART_Receive(&UartHandle, (uint8_t *)aRxBuffer, RXBUFFERSIZE, 0x1FFFFFF) != HAL_OK)
Error_Handler();
BSP_LED_On(LED2);
if(HAL_UART_Transmit(&UartHandle, (uint8_t*)aTxBuffer, TXBUFFERSIZE, 5000)!= HAL_OK)
Error_Handler();
BSP_LED_On(LED2);
if(Buffercmp((uint8_t*)aTxBuffer,(uint8_t*)aRxBuffer,RXBUFFERSIZE))
Error_Handler();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
BSP_LED_On(LED2);
HAL_Delay(1000);
BSP_LED_Off(LED2);
HAL_Delay(1000);
while(1)
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == KEY_BUTTON_PIN)
UserButtonStatus = 1;
static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength)
while (BufferLength--)
if ((*pBuffer1) != *pBuffer2)
return BufferLength;
pBuffer1++;
pBuffer2++;
return 0;
static void Error_Handler(void)
BSP_LED_On(LED2);
HAL_Delay(1000);
BSP_LED_Off(LED2);
HAL_Delay(1000);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SUBGHZ_Init();
SMPSClockDetectionEnable();
HAL_PWREx_SMPS_SetMode(PWR_SMPS_STEP_DOWN);
smps_requested_mode = PWR_SMPS_STEP_DOWN;
while (1)
BSP_LED_Toggle(LED2);
smps_effective_mode = HAL_PWREx_SMPS_GetEffectiveMode();
if(smps_effective_mode == PWR_SMPS_STEP_DOWN)
HAL_Delay(50);
else
HAL_Delay(500);
if (ubUserButtonEvent == 1)
ubUserButtonEvent = 0;
if (smps_requested_mode == PWR_SMPS_BYPASS)
HAL_PWREx_SMPS_SetMode(PWR_SMPS_STEP_DOWN);
smps_requested_mode = PWR_SMPS_STEP_DOWN;
else
HAL_PWREx_SMPS_SetMode(PWR_SMPS_BYPASS);
smps_requested_mode = PWR_SMPS_BYPASS;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_SUBGHZ_Init(void)
hsubghz.Init.BaudratePrescaler = SUBGHZSPI_BAUDRATEPRESCALER_8;
if (HAL_SUBGHZ_Init(&hsubghz) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED2_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
void SMPSClockDetectionEnable(void)
uint8_t radio_register_data;
uint8_t radio_register_data_readback;
uint8_t radio_command;
HAL_SUBGHZ_ReadRegister(&hsubghz, SUBGHZ_SMPSC0R, &radio_register_data);
radio_register_data |= SUBGHZ_SMPSC0R_CLKDE;
HAL_SUBGHZ_WriteRegister(&hsubghz, SUBGHZ_SMPSC0R, radio_register_data);
HAL_SUBGHZ_ReadRegister(&hsubghz, SUBGHZ_SMPSC0R, &radio_register_data_readback);
if(radio_register_data != radio_register_data_readback)
Error_Handler();
radio_command = 4;
HAL_SUBGHZ_ExecSetCmd( &hsubghz, RADIO_SET_SLEEP, ( uint8_t* )&radio_command, 1 );
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == BUTTON_SW1_PIN)
ubUserButtonEvent = 1;
void Error_Handler(void)
while(1)
HAL_GPIO_WritePin(LED2_GPIO_PORT, LED2_PIN, GPIO_PIN_SET);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
SystemClock_Config(CPU_CLK_240M);
printf("enter main\\r\\n");
GPIO_Init();
SPI_Init();
LCD_Init();
while (1)
LCD_ShowPicture(0, 40, 240, 240, gImage_pikaqiu);
HAL_Delay(1000);
LCD_ShowPicture(0, 40, 240, 240, gImage_lufei);
HAL_Delay(1000);
static void GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIO_CLK_ENABLE();
GPIO_InitStruct.Pin = S_LEDA1_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(S_LEDA1_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(S_LEDA1_PORT, S_LEDA1_PIN, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = S_LEDA2_PIN;
HAL_GPIO_Init(S_LEDA2_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(S_LEDA2_PORT, S_LEDA2_PIN, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = S_CD_PIN;
HAL_GPIO_Init(S_CD_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(S_CD_PORT, S_CD_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = S_RESET_PIN;
HAL_GPIO_Init(S_RESET_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(S_RESET_PORT, S_RESET_PIN, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = S_FMARK_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
HAL_GPIO_Init(S_FMARK_PORT, &GPIO_InitStruct);
GPIO_InitStruct.Pin = P_LEDA_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(P_LEDA_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_LEDA_PORT, P_LEDA_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = P_RD_PIN;
HAL_GPIO_Init(P_RD_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_RD_PORT, P_RD_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = P_WR_PIN;
HAL_GPIO_Init(P_WR_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_WR_PORT, P_WR_PIN, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = P_CD_PIN;
HAL_GPIO_Init(P_CD_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_CD_PORT, P_CD_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = P_CS_PIN;
HAL_GPIO_Init(P_CS_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_CS_PORT, P_CS_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = P_RESET_PIN;
HAL_GPIO_Init(P_RESET_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_RESET_PORT, P_RESET_PIN, GPIO_PIN_SET);
GPIO_InitStruct.Pin = P_DATA_PIN;
HAL_GPIO_Init(P_DATA_PORT, &GPIO_InitStruct);
HAL_GPIO_WritePin(P_DATA_PORT, P_DATA_PIN, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = P_FMARK_PIN;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
HAL_GPIO_Init(P_FMARK_PORT, &GPIO_InitStruct);
static void SPI_Init(void)
hspi.Instance = SPI;
hspi.Init.Mode = SPI_MODE_MASTER;
hspi.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi.Init.NSS = SPI_NSS_SOFT;
hspi.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi.Init.FirstByte = SPI_LITTLEENDIAN;
if (HAL_SPI_Init(&hspi) != HAL_OK)
Error_Handler();
void Error_Handler(void)
while (1)
void assert_failed(uint8_t *file, uint32_t line)
printf("Wrong parameters value: file %s on line %d\\r\\n", file, line);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_IWDG_Init();
MX_SPI1_Init();
MX_TIM7_Init();
MX_USART2_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_LSE
|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
HAL_RCCEx_EnableMSIPLLMode();
static void MX_IWDG_Init(void)
hiwdg.Instance = IWDG;
hiwdg.Init.Prescaler = IWDG_PRESCALER_4;
hiwdg.Init.Window = 4095;
hiwdg.Init.Reload = 4095;
if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM7_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim7.Instance = TIM7;
htim7.Init.Prescaler = 0;
htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
htim7.Init.Period = 65535;
htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD3_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD3_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI4_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI4_IRQn);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM1) {
HAL_IncTick();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_PB_Init(BUTTON_SW1,BUTTON_MODE_GPIO);
SystemClock_Config();
MX_GPIO_Init();
MX_RTC_Init();
MX_TIM16_Init();
if (HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR1) == WAKEUP_TIMER_ENABLE)
if (HAL_RTCEx_DeactivateWakeUpTimer(&hrtc) != HAL_OK)
Error_Handler();
HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 0x0, RTC_WAKEUPCLOCK_CK_SPRE_16BITS,0);
HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR1, WAKEUP_TIMER_ENABLE);
while(BSP_PB_GetState(BUTTON_SW1) != GPIO_PIN_SET)
while(BSP_PB_GetState(BUTTON_SW1) != GPIO_PIN_RESET)
uwLsiFreq = GetLSIFrequency();
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 0x7F;
hrtc.Init.SynchPrediv = (uwLsiFreq/128) - 1;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if(HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
RTCStatus = 1;
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_RTC_Init(void)
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
hrtc.Init.SynchPrediv = RTC_SYNCH_PREDIV;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
hrtc.Init.BinMode = RTC_BINARY_NONE;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
if (HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 0, RTC_WAKEUPCLOCK_RTCCLK_DIV16, 0) != HAL_OK)
Error_Handler();
static void MX_TIM16_Init(void)
TIM_IC_InitTypeDef sConfigIC = {0};
htim16.Instance = TIM16;
htim16.Init.Prescaler = 0;
htim16.Init.CounterMode = TIM_COUNTERMODE_UP;
htim16.Init.Period = 0xFFFF;
htim16.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim16.Init.RepetitionCounter = 0;
htim16.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim16) != HAL_OK)
Error_Handler();
if (HAL_TIM_IC_Init(&htim16) != HAL_OK)
Error_Handler();
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
sConfigIC.ICFilter = 0;
if (HAL_TIM_IC_ConfigChannel(&htim16, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOB_CLK_ENABLE();
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
tmpCCTIM_CHANNEL[uwCaptureNumber++] = HAL_TIM_ReadCapturedValue(&htim16, TIM_CHANNEL_1);
if (uwCaptureNumber >= 2)
if ( tmpCCTIM_CHANNEL[0] > tmpCCTIM_CHANNEL[1] )
uwPeriodValue = (uint16_t)(0xFFFF - tmpCCTIM_CHANNEL[0] + tmpCCTIM_CHANNEL[1] + 1);
else
uwPeriodValue = (uint16_t)(tmpCCTIM_CHANNEL[1] - tmpCCTIM_CHANNEL[0]);
uwLsiFreq = (uint32_t) SystemCoreClock / uwPeriodValue;
uwLsiFreq *= 8;
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
BSP_LED_Toggle(LED2);
static uint32_t GetLSIFrequency(void)
TIM_IC_InitTypeDef    TIMInput_Config;
htim16.Instance = TIM16;
htim16.Init.Prescaler         = 0;
htim16.Init.CounterMode       = TIM_COUNTERMODE_UP;
htim16.Init.Period            = 0xFFFF;
htim16.Init.ClockDivision     = 0;
if(HAL_TIM_IC_Init(&htim16) != HAL_OK)
Error_Handler();
HAL_TIMEx_RemapConfig(&htim16, TIM_TIM16_TI1_LSI);
TIMInput_Config.ICPolarity  = TIM_ICPOLARITY_RISING;
TIMInput_Config.ICSelection = TIM_ICSELECTION_DIRECTTI;
TIMInput_Config.ICPrescaler = TIM_ICPSC_DIV8;
TIMInput_Config.ICFilter    = 0;
if(HAL_TIM_IC_ConfigChannel(&htim16, &TIMInput_Config, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if(HAL_TIM_IC_Start_IT(&htim16, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
while(uwCaptureNumber != 2)
HAL_TIM_IC_Stop_IT(&htim16, TIM_CHANNEL_1);
HAL_TIM_IC_DeInit(&htim16);
return uwLsiFreq;
void Error_Handler(void)
RTCStatus = 0xE;
while (1)
BSP_LED_On(LED3);
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
SystemClock_Config();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
if(BSP_PB_GetState(BUTTON_KEY) == 0x00)
HAL_FLASHEx_OBGetConfig(&FLASH_OBInitStruct);
if((FLASH_OBInitStruct.BORLevel & 0x0C) != BOR_LEVEL)
HAL_FLASH_OB_Unlock();
FLASH_OBInitStruct.OptionType = OPTIONBYTE_BOR;
FLASH_OBInitStruct.BORLevel = BOR_LEVEL;
HAL_FLASHEx_OBProgram(&FLASH_OBInitStruct);
HAL_FLASH_OB_Launch();
HAL_FLASH_OB_Lock();
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(50);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
void draw(void)
int i;
ucg_SetColor(&ucg, 0, 0, 0, 0);
ucg_DrawBox(&ucg, 0, 0, 96, 64);
ucg_SetColor(&ucg, 0, 255, 0, 0);
ucg_SetFont(&ucg,ucg_font_profont10_8f);
ucg_DrawString(&ucg, 2, 12, 0, "Hello!");
ucg_DrawBitmapLine(&ucg, 9,0, 0,16, bitmap);
ucg_DrawBitmapLine(&ucg, 10,1, 0,16, bitmap);
ucg_DrawBitmapLine(&ucg, 0,9, 1,16, bitmap);
ucg_DrawBitmapLine(&ucg, 1,10, 1,16, bitmap);
for( i = 0; i < ucg_GetWidth(&ucg); i+= 2 )
ucg_DrawPixel(&ucg, i, 30);
for( i = 0; i < ucg_GetHeight(&ucg); i+= 2 )
ucg_DrawPixel(&ucg, 30, i);
ucg_SetClipRange(&ucg, 10, 10, 25, 25);
ucg_SetColor(&ucg, 0, 0, 255, 0);
for( i = 1; i < ucg_GetWidth(&ucg); i+= 2 )
ucg_DrawPixel(&ucg, i, 30);
for( i = 1; i < ucg_GetHeight(&ucg); i+= 2 )
ucg_DrawPixel(&ucg, 30, i);
ucg_SetColor(&ucg, 0, 80, 80, 255);
ucg_DrawHLine(&ucg, 8, 9, 5);
ucg_DrawHLine(&ucg, 8, 10, 5);
ucg_DrawHLine(&ucg, 8, 11, 5);
ucg_DrawHLine(&ucg, 8, 12, 100);
ucg_DrawHLine(&ucg, 12, 13, 5);
ucg_DrawHLine(&ucg, 12, 14, 100);
ucg_DrawHLine(&ucg, 2, 15, 5);
ucg_DrawHLine(&ucg, 40, 16, 5);
ucg_DrawHRLine(&ucg, 12, 17, 1);
ucg_DrawHRLine(&ucg, 12, 18, 2);
ucg_DrawHRLine(&ucg, 12, 19, 3);
ucg_DrawHRLine(&ucg, 12, 20, 4);
ucg_DrawHRLine(&ucg, 36, 17, 1);
ucg_DrawHRLine(&ucg, 36, 18, 2);
ucg_DrawBitmapLine(&ucg, 9,22, 0,16, bitmap);
ucg_DrawBitmapLine(&ucg, 10,23, 0,16, bitmap);
ucg_SetClipRange(&ucg, 70-9, 20-9, 20, 20);
ucg_DrawGlyph(&ucg, 70, 20, 0, 'A');
ucg_DrawGlyph(&ucg, 70, 20, 1, 'A');
ucg_DrawGlyph(&ucg, 70, 20, 2, 'A');
ucg_DrawGlyph(&ucg, 70, 20, 3, 'A');
ucg_SetMaxClipRange(&ucg);
ucg_SetColor(&ucg, 0, 255, 0, 0);
ucg_SetColor(&ucg, 1, 0, 255, 0);
ucg_SetColor(&ucg, 0, 255, 0, 0);
ucg_SetColor(&ucg, 1, 0, 255, 0);
ucg_SetColor(&ucg, 2, 255, 0, 255);
ucg_SetColor(&ucg, 3, 0, 255, 255);
ucg_DrawGradientLine(&ucg, 10, 40, 100, 0);
ucg_DrawGradientBox(&ucg, 10, 43, 100, 20);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
MX_USART2_UART_Init();
printf("Hello stm32\\r\\n");
ucg_Init(&ucg, ucg_dev_ssd1331_18x96x64_univision, ucg_ext_ssd1331_18, ucg_com_ssd1331_hw_spi_fn);
ucg_SetFontMode(&ucg, 1);
draw();
while (1)
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(PIN_DC_GPIO_Port, PIN_DC_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(PIN_RST_GPIO_Port, PIN_RST_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(PIN_CS_GPIO_Port, PIN_CS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PIN_DC_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(PIN_DC_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PIN_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(PIN_RST_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PIN_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(PIN_CS_GPIO_Port, &GPIO_InitStruct);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 72;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM6) {
HAL_IncTick();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
UartHandle.Instance          = USARTx;
UartHandle.Init.BaudRate     = 9600;
UartHandle.Init.WordLength   = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits     = UART_STOPBITS_1;
UartHandle.Init.Parity       = UART_PARITY_ODD;
UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE;
UartHandle.Init.Mode         = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
printf("\\n\\r UART Printf Example: retarget the C library printf function to the UART\\n\\r");
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED2);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
MPU_Config();
MPU_AccessPermConfig();
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV1;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
while(1);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void DataProcessingCallback(adc_measures_t* result)
volatile m4_to_m7_data_t* data = &sharedData->m4Tom7;
int index = (data->recordIndex + 1) & (MEASURE_SAVE_COUNT - 1);
uint64_t* resultU64 = (uint64_t*)result;
uint64_t* copyU64 = (uint64_t*)&data->dataRecord[index];
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64++ = *resultU64++;
*copyU64 = *resultU64;
data->recordIndex = index;
data->lastDataPointer = &data->dataRecord[index];
data->sts = true;
int main(void)
memset((void*)&(sharedData->m4Tom7), 0, sizeof(m4_to_m7_data_t));
sharedData->m4Tom7.lastDataPointer = sharedData->m4Tom7.dataRecord;
__HAL_RCC_HSEM_CLK_ENABLE();
HAL_HSEM_ActivateNotification(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
HAL_PWREx_ClearPendingEvent();
HAL_PWREx_EnterSTOPMode(PWR_MAINREGULATOR_ON, PWR_STOPENTRY_WFE, PWR_D2_DOMAIN);
__HAL_HSEM_CLEAR_FLAG(__HAL_HSEM_SEMID_TO_MASK(HSEM_ID_0));
HAL_Init();
MX_GPIO_Init();
MX_TIM17_Init();
MX_I2C2_Init();
BSP_Display_Init();
BSP_Display_ShowLogo();
HAL_TIM_PWM_Start(&htim17,TIM_CHANNEL_1);
adc_cont_config_t adcConfig = {
.callback = DataProcessingCallback,
.conversionCycleTimeUs = sharedData->m7Tom4.periodUs };
BSP_MAX11046_Init(ADC_MODE_CONT, &adcConfig);
BSP_MAX11046_Run();
while (1)
intelliSENS.Poll();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.Timing = 0x307075B1;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
Error_Handler();
static void MX_TIM17_Init(void)
TIM_OC_InitTypeDef sConfigOC = {0};
TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
htim17.Instance = TIM17;
htim17.Init.Prescaler = 10;
htim17.Init.CounterMode = TIM_COUNTERMODE_UP;
htim17.Init.Period = 960;
htim17.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim17.Init.RepetitionCounter = 0;
htim17.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim17) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim17) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 950;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&htim17, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
sBreakDeadTimeConfig.DeadTime = 0;
sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
sBreakDeadTimeConfig.BreakFilter = 0;
sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
if (HAL_TIMEx_ConfigBreakDeadTime(&htim17, &sBreakDeadTimeConfig) != HAL_OK)
Error_Handler();
sConfigOC.Pulse = (htim17.Init.Prescaler - 1) * LCD_BRIGHTNESS;
if (HAL_TIM_PWM_ConfigChannel(&htim17, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim17);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOI_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOK_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOE, maxCS1_Pin|maxCS2_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOI, maxWrite_Pin|LCD_Disp_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(maxRead_GPIO_Port, maxRead_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(CTP_RST_GPIO_Port, CTP_RST_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = maxCS1_Pin|maxCS2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = maxWrite_Pin|LCD_Disp_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOI, &GPIO_InitStruct);
GPIO_InitStruct.Pin = maxRead_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(maxRead_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = maxBusy1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(maxBusy1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = maxBusy2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(maxBusy2_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = maxD0_Pin|maxD1_Pin|maxD2_Pin|maxD3_Pin
|maxD4_Pin|maxD5_Pin|maxD6_Pin|maxD7_Pin
|maxD8_Pin|maxD9_Pin|maxD10_Pin|maxD11_Pin
|maxD12_Pin|maxD13_Pin|maxD14_Pin|maxD15_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CTP_INT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(CTP_INT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CTP_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CTP_RST_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
HAL_Init();
SystemClock_Config();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x20010000;
MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_USART2_UART_Init();
MX_USART3_UART_Init();
HAL_UART_Receive_IT(&huart3, (uint8_t *)RxBuff, 1);
HAL_UART_Transmit_IT(&huart3, (uint8_t *)"END\\n", 5);
while (1)
trc1 = HAL_GPIO_ReadPin(Trace1_GPIO_Port, Trace1_Pin);
trc2 = HAL_GPIO_ReadPin(Trace2_GPIO_Port, Trace2_Pin);
trc3 = HAL_GPIO_ReadPin(Trace3_GPIO_Port, Trace3_Pin);
trc4 = HAL_GPIO_ReadPin(Trace5_GPIO_Port, Trace5_Pin);
trc5 = HAL_GPIO_ReadPin(Trace4_GPIO_Port, Trace4_Pin);
case1_1 = trc1==1 && trc2==0 && trc3==0 && trc4==1 && trc5==1;
case1_2 = trc1==1 && trc2==1 && trc3==0 && trc4==0 && trc5==1;
case1_3 = trc1==1 && trc2==0 && trc3==0 && trc4==0 && trc5==1;
case2_1 = trc1==0 && trc2==0 && trc3==1 && trc4==1 && trc5==1;
case2_2 = trc1==0 && trc2==1 && trc3==1 && trc4==1 && trc5==1;
case2_3 = trc1==1 && trc2==0 && trc3==1 && trc4==1 && trc5==1;
case2_4 = trc1==0 && trc2==0 && trc3==0 && trc4==1 && trc5==1;
case2_5 = trc1==0 && trc2==0 && trc3==0 && trc4==0 && trc5==1;
case2_6 = trc1==0 && trc2==1 && trc3==0 && trc4==1 && trc5==1;
case3_1 = trc1==1 && trc2==1 && trc3==1 && trc4==0 && trc5==0;
case3_2 = trc1==1 && trc2==1 && trc3==1 && trc4==1 && trc5==0;
case3_3 = trc1==1 && trc2==1 && trc3==1 && trc4==0 && trc5==1;
case3_4 = trc1==1 && trc2==1 && trc3==0 && trc4==0 && trc5==0;
case3_5 = trc1==1 && trc2==0 && trc3==0 && trc4==0 && trc5==0;
case3_6 = trc1==1 && trc2==1 && trc3==0 && trc4==0 && trc5==0;
case4 = trc1==0 && trc2==0 && trc3==0 && trc4==0 && trc5==0;
case5 = trc1==1 && trc2==1 && trc3==1 && trc4==1 && trc5==1;
if (StartFlag){
StartMotor();
StartFlag = 0;
HAL_UART_Transmit_IT(&huart3, (uint8_t *)"STA\\n", 5);
if (EndFlag==0 && endpoint >=5){
EndFlag = 1;
HAL_UART_Transmit_IT(&huart3, (uint8_t *)"END\\n", 5);
if (EndFlag){
Motor_Rotate(1,1500,2000);
Motor_Rotate(2,1500,2000);
Motor_Rotate(3,1500,2000);
Motor_Rotate(4,1500,2000);
}else{
if (case1_1 || case1_2 || case1_3){
Foward();
}else if(case2_1 || case2_2 || case2_3 || case2_4 || case2_5 ){
RotateLeft();
}else if(case3_1 || case3_2 || case3_3 || case3_4 || case3_5 ){
RotateRight();
}else if(case5){
TurnBack();
printf("Back!\\r\\n");
}else if(case4){
endpoint = endpoint + 1;
Foward();
HAL_Delay(100);
}else{
Foward();
HAL_Delay(1);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 9;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOMEDIUM;
RCC_OscInitStruct.PLL.PLLFRACN = 3072;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
|RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_USART2
|RCC_PERIPHCLK_USART1;
PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
void Communicate_Upper()
if (Recieve_flag == 1 && RxLine != 0)
Process_Buffer();
memset(DataBuff, 0, sizeof(DataBuff));
RxLine = 0;
Recieve_flag = 0;
void Process_Buffer()
sscanf((const char *)(&DataBuff[0]), "%f", &Recieve_val);
SetVelocity(Recieve_val);
HAL_UART_Transmit_IT(&huart3, (uint8_t *)"REC\\n", 4);
Recieve_val = 0;
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
if (huart->Instance == huart3.Instance)
if (RxBuff[0] == 'A')
Recieve_flag = 1;
else
RxLine++;
DataBuff[RxLine - 1] = RxBuff[0];
RxBuff[0] = 0;
HAL_UART_Receive_IT(&huart3, (uint8_t *)RxBuff, 1);
void TurnRight(void)
Motor_Rotate(1,1100,2000);
Motor_Rotate(2,1100,2000);
Motor_Rotate(3,2000,2000);
Motor_Rotate(4,2000,2000);
void TurnLeft(void)
Motor_Rotate(1,1000,2000);
Motor_Rotate(2,1000,2000);
Motor_Rotate(3,1700,2000);
Motor_Rotate(4,1700,2000);
void Foward(void)
Motor_Rotate(1,1000,2000);
Motor_Rotate(2,1000,2000);
Motor_Rotate(3,2000,2000);
Motor_Rotate(4,2000,2000);
void TurnBack(void)
Motor_Rotate(1,2100,2000);
Motor_Rotate(2,2100,2000);
Motor_Rotate(3,900,2000);
Motor_Rotate(4,900,2000);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_CAN1_Init();
CAN_Rx_filter();
if(HAL_CAN_Start(&hcan1)!=HAL_OK)
Error_Handler();
if(HAL_CAN_ActivateNotification(&hcan1,CAN_IT_RX_FIFO0_MSG_PENDING)!=HAL_OK)
Error_Handler();
while (1)
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_SET);
HAL_Delay(400);
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_RESET);
HAL_Delay(400);
CAN_TX1();
HAL_Delay(50);
CAN_TX2();
HAL_Delay(50);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
static void MX_CAN1_Init(void)
hcan1.Instance = CAN1;
hcan1.Init.Prescaler = 64;
hcan1.Init.Mode = CAN_MODE_NORMAL;
hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ;
hcan1.Init.TimeSeg1 = CAN_BS1_1TQ;
hcan1.Init.TimeSeg2 = CAN_BS2_1TQ;
hcan1.Init.TimeTriggeredMode = DISABLE;
hcan1.Init.AutoBusOff = DISABLE;
hcan1.Init.AutoWakeUp = DISABLE;
hcan1.Init.AutoRetransmission = DISABLE;
hcan1.Init.ReceiveFifoLocked = DISABLE;
hcan1.Init.TransmitFifoPriority = DISABLE;
if (HAL_CAN_Init(&hcan1) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void CAN_Rx_filter(void)
CAN_FilterTypeDef hcan_filter;
hcan_filter.FilterActivation  =CAN_FILTER_ENABLE;
hcan_filter.FilterBank         =0;
hcan_filter.FilterFIFOAssignment =CAN_RX_FIFO0;
hcan_filter.FilterIdHigh       =0x0000;
hcan_filter.FilterIdLow		   =0x0000;
hcan_filter.FilterMaskIdHigh   =0x0000;
hcan_filter.FilterMaskIdLow	   =0x0000;
hcan_filter.FilterMode         =CAN_FILTERMODE_IDMASK;
hcan_filter.FilterScale		   =CAN_FILTERSCALE_32BIT;
if((HAL_CAN_ConfigFilter(&hcan1, &hcan_filter)!=HAL_OK))
Error_Handler();
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
uint8_t rcvd_msg[8];
if(HAL_CAN_GetRxMessage(&hcan1,CAN_RX_FIFO0,&hcan_rx,(uint8_t*)rcvd_msg)!=HAL_OK)
Error_Handler();
if(hcan_rx.ExtId==0x10261022)
datacheck_1=1;
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_SET);
HAL_Delay(500);
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_RESET);
HAL_Delay(500);
else if(hcan_rx.ExtId==0x10261023)
datacheck_2=1;
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_SET);
HAL_Delay(200);
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_RESET);
HAL_Delay(200);
else
datacheck_1=0;
datacheck_2=0;
HAL_GPIO_WritePin(LD2_GPIO_Port,LD2_Pin,GPIO_PIN_RESET);
void CAN_TX1(void)
CAN_TxHeaderTypeDef hcan_tx1;
uint32_t mailbox1;
uint8_t msg1[8]={'0','0','0','0','0','0','0','0'};
hcan_tx1.DLC	=8;
hcan_tx1.ExtId	=0x1026105A;
hcan_tx1.IDE	=CAN_ID_EXT;
hcan_tx1.RTR	=CAN_RTR_DATA;
if(HAL_CAN_AddTxMessage(&hcan1,&hcan_tx1,(uint8_t*)msg1,&mailbox1)!=HAL_OK)
Error_Handler();
char can_sent[11]="Data_Sent-1";
while(HAL_CAN_IsTxMessagePending(&hcan1,mailbox1));
HAL_UART_Transmit(&huart2,(uint8_t*)can_sent,11,HAL_MAX_DELAY);
void CAN_TX2(void)
CAN_TxHeaderTypeDef hcan_tx2;
uint32_t mailbox2;
uint8_t msg2[8]={'0','0','0','0','0','0','0','0'};
hcan_tx2.DLC	=8;
hcan_tx2.ExtId	=0x10261101;
hcan_tx2.IDE	=CAN_ID_EXT;
hcan_tx2.RTR	=CAN_RTR_DATA;
if(HAL_CAN_AddTxMessage(&hcan1,&hcan_tx2,(uint8_t*)msg2,&mailbox2)!=HAL_OK)
Error_Handler();
char can_sent[11]="Data_Sent-2";
while(HAL_CAN_IsTxMessagePending(&hcan1,mailbox2));
HAL_UART_Transmit(&huart2,(uint8_t*)can_sent,11,HAL_MAX_DELAY);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
while(1)
HAL_Delay(500);
BSP_LED_Toggle(LED1);
BSP_LED_Toggle(LED2);
BSP_LED_Toggle(LED3);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == KEY_BUTTON_PIN)
if (uwIncrementState == 0)
HAL_SuspendTick();
uwIncrementState = 1;
else
HAL_ResumeTick();
uwIncrementState = 0;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
int8_t ThresholdHigh = 100;
int8_t ThresholdLow = -100;
MX_GPIO_Init();
MX_I2C1_Init();
MX_I2S3_Init();
MX_SPI1_Init();
MX_USART3_UART_Init();
MX_USB_HOST_Init();
while (1)
MX_USB_HOST_Process();
if(BSP_ACCELERO_Init() != HAL_OK)
Error_Handler();
while(1)
int8_t buffer[3] = {0};
int8_t xval, yval = 0x00;
BSP_ACCELERO_GetXYZ(buffer);
xval = buffer[0];
yval = buffer[1];
if((ABS(xval))>(ABS(yval)))
if(xval > ThresholdHigh)
HAL_UART_Transmit( &huart3, ["X", (char)100], 1, 1000 );
HAL_Delay(10);
else if(xval < ThresholdLow)
HAL_UART_Transmit( &huart3, ["X", (char)-100], 1, 1000 );
HAL_Delay(10);
else
HAL_UART_Transmit( &huart3, ["X", (char)xval], 1, 1000 );
HAL_Delay(10);
else
if(yval < ThresholdLow)
HAL_UART_Transmit( &huart3, ["Y", (char)100], 1, 1000 );
HAL_Delay(10);
else if(yval > ThresholdHigh)
HAL_UART_Transmit( &huart3, ["Y", (char)-100], 1, 1000 );
HAL_Delay(10);
else
HAL_UART_Transmit( &huart3, ["Y", (char)yval], 1, 1000 );
HAL_Delay(10);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_I2S3_Init(void)
hi2s3.Instance = SPI3;
hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
hi2s3.Init.CPOL = I2S_CPOL_LOW;
hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
if (HAL_I2S_Init(&hi2s3) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
uwPrescalerValue = (uint32_t)((SystemCoreClock / 2) / 10000) - 1;
TimHandle.Instance = TIMx;
TimHandle.Init.Period            = 10000 - 1;
TimHandle.Init.Prescaler         = uwPrescalerValue;
TimHandle.Init.ClockDivision     = 0;
TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimHandle.Init.RepetitionCounter = 0;
TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&TimHandle) != HAL_OK)
Error_Handler();
if (HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK)
Error_Handler();
while (1)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
BSP_LED_Toggle(LED1);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1) {};
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
while(1) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
while(1) {};
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
while (1)
HAL_GPIO_TogglePin(USER_LED_GPIO_Port, USER_LED_Pin);
test();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin|HV_EN_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = USER_LED_Pin|SPI1_CS_Pin|HV_EN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC1_Init();
MX_USART3_UART_Init();
while (1)
HAL_ADC_Start(&hadc1);
HAL_ADC_PollForConversion(&hadc1, 50);
float vol=0;
if(HAL_IS_BIT_SET(HAL_ADC_GetState(&hadc1), HAL_ADC_STATE_REG_EOC))
ADC_Value = HAL_ADC_GetValue(&hadc1);
printf("ADC2 Reading : %d \\r\\n",ADC_Value);
vol =((float)ADC_Value*3.3)/4096;
printf("vol : %f \\r\\n",vol);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 12;
RCC_OscInitStruct.PLL.PLLN = 192;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
ADC_InjectionConfTypeDef sConfigInjected = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV2;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = DISABLE;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
hadc1.Init.DMAContinuousRequests = DISABLE;
hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_13;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
sConfigInjected.InjectedChannel = ADC_CHANNEL_13;
sConfigInjected.InjectedRank = 1;
sConfigInjected.InjectedNbrOfConversion = 1;
sConfigInjected.InjectedSamplingTime = ADC_SAMPLETIME_3CYCLES;
sConfigInjected.ExternalTrigInjecConvEdge = ADC_EXTERNALTRIGINJECCONVEDGE_NONE;
sConfigInjected.ExternalTrigInjecConv = ADC_INJECTED_SOFTWARE_START;
sConfigInjected.AutoInjectedConv = DISABLE;
sConfigInjected.InjectedDiscontinuousConvMode = DISABLE;
sConfigInjected.InjectedOffset = 0;
if (HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART1_UART_Init();
MX_TIM14_Init();
MX_I2C2_Init();
MX_SPI1_Init();
MX_ADC_Init();
MX_TIM6_Init();
MX_TIM7_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
HAL_RCC_EnableCSS();
static void MX_ADC_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc.Instance = ADC1;
hadc.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV4;
hadc.Init.Resolution = ADC_RESOLUTION_12B;
hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
hadc.Init.LowPowerAutoWait = DISABLE;
hadc.Init.LowPowerAutoPowerOff = DISABLE;
hadc.Init.ContinuousConvMode = ENABLE;
hadc.Init.DiscontinuousConvMode = DISABLE;
hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc.Init.DMAContinuousRequests = ENABLE;
hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
if (HAL_ADC_Init(&hadc) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_13;
sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
sConfig.SamplingTime = ADC_SAMPLETIME_7CYCLES_5;
if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
Error_Handler();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.Timing = 0x20303E5D;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM6_Init(void)
htim6.Instance = TIM6;
htim6.Init.Prescaler = 9;
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
htim6.Init.Period = 47999;
htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
Error_Handler();
static void MX_TIM7_Init(void)
htim7.Instance = TIM7;
htim7.Init.Prescaler = 999;
htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
htim7.Init.Period = 47999;
htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
Error_Handler();
static void MX_TIM14_Init(void)
TIM_OC_InitTypeDef sConfigOC = {0};
htim14.Instance = TIM14;
htim14.Init.Prescaler = 0;
htim14.Init.CounterMode = TIM_COUNTERMODE_UP;
htim14.Init.Period = 0;
htim14.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim14.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim14) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim14) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim14, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim14);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_MultiProcessor_Init(&huart1, 0, UART_WAKEUPMETHOD_IDLELINE) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, PWR_State1_Pin|PWR_State2_Pin|Display_Enable_Pin|CH2_EXTI_Pin
|CH1_EXTI_Pin|CH4_State1_Pin|CH3_State2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, Display_CS_Pin|CH4_State2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, TSC_XRES_Pin|CH4_EXTI_Pin|CH3_EXTI_Pin|CH2_State2_Pin
|CH2_State1_Pin|CH1_State2_Pin|CH1_State1_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(CH3_State1_GPIO_Port, CH3_State1_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = Calibrate_Pin|PWR_Pin|CH1_Start_Pin|CH2_Start_Pin
|CH2_FAIL_Pin|CH1_FAIL_Pin|CH4_Select_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_14;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PWR_State1_Pin|PWR_State2_Pin|Display_Enable_Pin|CH2_EXTI_Pin
|CH1_EXTI_Pin|CH4_State1_Pin|CH3_State2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = TSC_HI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(TSC_HI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_11;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Display_CS_Pin|CH4_State2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CH3_Start_Pin|CH4_Start_Pin|CH4_FAIL_Pin|CH3_FAIL_Pin
|CH3_Select_Pin|CH2_Select_Pin|CH1_Select_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = TSC_XRES_Pin|CH4_EXTI_Pin|CH3_EXTI_Pin|CH2_State2_Pin
|CH2_State1_Pin|CH1_State2_Pin|CH1_State1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = STOP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(STOP_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CH3_State1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CH3_State1_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
HAL_NVIC_SetPriority(EXTI4_15_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
int main(void)
ADC_ChannelConfTypeDef sConfig;
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
AdcHandle.Instance          = ADCx;
AdcHandle.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV2;
AdcHandle.Init.Resolution = ADC_RESOLUTION_12B;
AdcHandle.Init.ScanConvMode = DISABLE;
AdcHandle.Init.ContinuousConvMode = ENABLE;
AdcHandle.Init.DiscontinuousConvMode = DISABLE;
AdcHandle.Init.NbrOfDiscConversion = 0;
AdcHandle.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
AdcHandle.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1;
AdcHandle.Init.DataAlign = ADC_DATAALIGN_RIGHT;
AdcHandle.Init.NbrOfConversion = 1;
AdcHandle.Init.DMAContinuousRequests = ENABLE;
AdcHandle.Init.EOCSelection = DISABLE;
if(HAL_ADC_Init(&AdcHandle) != HAL_OK)
Error_Handler();
sConfig.Channel = ADCx_CHANNEL;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
sConfig.Offset = 0;
if(HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK)
Error_Handler();
if(HAL_ADC_Start_DMA(&AdcHandle, (uint32_t*)&uhADCxConvertedValue, 1) != HAL_OK)
Error_Handler();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 288;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 6;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
BSP_LED_On(LED1);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
IRQn_Type uart_irq;
GPIO_InitTypeDef uart_tx;
GPIO_InitTypeDef uart_rx;
GPIO_TypeDef *uart_uart;
uart_tx.Mode = GPIO_MODE_AF_PP;
uart_tx.Speed = GPIO_SPEED_FREQ_HIGH;
uart_rx.Mode = GPIO_MODE_INPUT;
uart_rx.Pull = GPIO_NOPULL;
uart_irq = USART1_IRQn;
uart_uart = GPIOA;
uart_tx.Pin = GPIO_PIN_9;
uart_rx.Pin = GPIO_PIN_10;
__HAL_RCC_USART1_CLK_ENABLE();
uart_irq = USART2_IRQn;
uart_uart = GPIOA;
uart_tx.Pin = GPIO_PIN_2;
uart_rx.Pin = GPIO_PIN_3;
__HAL_RCC_USART2_CLK_ENABLE();
uart_irq = USART3_IRQn;
uart_uart = GPIOB;
uart_tx.Pin = GPIO_PIN_10;
uart_rx.Pin = GPIO_PIN_11;
__HAL_RCC_USART3_CLK_ENABLE();
HAL_GPIO_Init(uart_uart, &uart_tx);
HAL_GPIO_Init(uart_uart, &uart_rx);
HAL_NVIC_SetPriority(uart_irq, 0, 0);
HAL_NVIC_EnableIRQ(uart_irq);
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
IRQn_Type uart_irq;
uint32_t uart_pins;
GPIO_TypeDef *uart_uart;
__HAL_RCC_USART1_CLK_DISABLE();
uart_uart = GPIOA;
uart_pins = GPIO_PIN_9 | GPIO_PIN_10;
uart_irq = USART1_IRQn;
__HAL_RCC_USART2_CLK_DISABLE();
uart_uart = GPIOA;
uart_pins = GPIO_PIN_2 | GPIO_PIN_3;
uart_irq = USART2_IRQn;
__HAL_RCC_USART3_CLK_DISABLE();
uart_uart = GPIOB;
uart_pins = GPIO_PIN_10 | GPIO_PIN_11;
uart_irq = USART3_IRQn;
HAL_GPIO_DeInit(uart_uart, uart_pins);
HAL_NVIC_DisableIRQ(uart_irq);
void USART1_IRQHandler(void)
void USART2_IRQHandler(void)
void USART3_IRQHandler(void)
uint32_t sr = uart->SR;
if (sr & USART_SR_RXNE) {
uint8_t ch = uart->DR;
rbuf_write(&rx_rbuf, ch);
return;
if (sr & USART_SR_TXE) {
if (rbuf_is_empty(&tx_rbuf))
uart->CR1 &= ~USART_CR1_TXEIE;
else
uart->DR = rbuf_read(&tx_rbuf);
int serial_init(uint32_t baud)
rbuf_init(&rx_rbuf, rx_buffer, UART_RX_BUF_SIZE);
rbuf_init(&tx_rbuf, tx_buffer, UART_TX_BUF_SIZE);
huart.Instance = USART1;
uart = USART1;
huart.Instance = USART2;
uart = USART2;
huart.Instance = USART3;
uart = USART3;
huart.Init.BaudRate = baud;
huart.Init.WordLength = UART_WORDLENGTH_8B;
huart.Init.StopBits = UART_STOPBITS_1;
huart.Init.Parity = UART_PARITY_NONE;
huart.Init.Mode = UART_MODE_TX_RX;
huart.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&huart);
uart->CR1 |= USART_CR1_RXNEIE;
return 0;
static inline uint16_t _serial_getc(void)
uint16_t ch = 0xFF00;
if (!rbuf_is_empty(&rx_rbuf))
ch = rbuf_read(&rx_rbuf);
return ch;
int serial_is_sending(void)
return !rbuf_is_empty(&tx_rbuf);
uint16_t serial_getc(void)
static uint8_t esc = ESC_CHAR;
static uint8_t idx = 0;
uint16_t ch;
ch = _serial_getc();
if (ch & 0xFF00)
return 0;
if (ch == 27) {
esc = ESC_BRACKET;
return 0;
if (esc == ESC_BRACKET) {
if (ch == '[') {
esc = ESC_BRCHAR;
return 0;
if (esc == ESC_BRCHAR) {
esc = ESC_CHAR;
if (ch >= 'A' && ch <= 'D') {
ch |= EXTRA_KEY;
return ch;
if ((ch >= '1') && (ch <= '6')) {
esc = ESC_TILDA;
idx = ch - '0';
return 0;
return ch;
if (esc == ESC_TILDA) {
esc = ESC_CHAR;
if (ch == '~') {
ch = EXTRA_KEY | idx;
return ch;
return 0;
if (ch == '\\r') {
esc = ESC_CRLF;
return '\\n';
if (ch == '\\n') {
if (esc == ESC_CRLF) {
esc = ESC_CHAR;
return 0;
esc = ESC_CHAR;
return ch;
void serial_putc(uint8_t ch)
while (rbuf_is_full(&tx_rbuf));
rbuf_write(&tx_rbuf, ch);
uart->CR1 |= USART_CR1_TXEIE;
void serial_puts(const char *str)
for(unsigned i = 0; str[i]; i++) {
if (str[i] == '\\n')
serial_putc('\\r');
serial_putc(str[i]);
void serial_print(const char *format, ...)
char buffer[UART_TX_BUF_SIZE];
va_list args;
va_start(args, format);
vsprintf(buffer, format, args);
serial_puts(buffer);
va_end(args);
void serial_putb(uint32_t val, uint8_t len)
if (len > 32)
len = 32;
uint32_t mask = 0x00000001 << (len - 1);
while(mask) {
serial_putc(!!(val & mask) + '0');
mask >>= 1;
void serial_puth(uint8_t val)
uint8_t hex = val >> 4;
hex += '0';
if (hex > '9')
hex += 7;
serial_putc(hex);
hex = val & 0x0F;
hex += '0';
if (hex > '9')
hex += 7;
serial_putc(hex);
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
HAL_HASH_DeInit(&HashHandle);
HashHandle.Init.DataType = HASH_DATATYPE_8B;
if (HAL_HASH_Init(&HashHandle) != HAL_OK)
Error_Handler();
if (HAL_HASH_SHA1_Start_DMA(&HashHandle, (uint8_t *)aInput, strlen((char const *)aInput)) != HAL_OK)
Error_Handler();
if (HAL_HASH_SHA1_Finish(&HashHandle, aSHA1Digest, 0xFF) != HAL_OK)
Error_Handler();
if (memcmp(aSHA1Digest, aExpectSHA1Digest, sizeof(aExpectSHA1Digest) / sizeof(aExpectSHA1Digest[0])) != 0)
Error_Handler();
else
BSP_LED_On(LED1);
HAL_HASH_DeInit(&HashHandle);
HashHandle.Init.DataType = HASH_DATATYPE_8B;
if (HAL_HASH_Init(&HashHandle) != HAL_OK)
Error_Handler();
if (HAL_HASH_MD5_Start_DMA(&HashHandle, (uint8_t *)aInput, strlen((char const *)aInput)) != HAL_OK)
Error_Handler();
if (HAL_HASH_MD5_Finish(&HashHandle, aMD5Digest, 0xFF) != HAL_OK)
Error_Handler();
if (memcmp(aMD5Digest, aExpectMD5Digest, sizeof(aExpectMD5Digest) / sizeof(aExpectMD5Digest[0])) != 0)
Error_Handler();
else
BSP_LED_On(LED4);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef  ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.PLL.PLLR = 7;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
SCB->VTOR = (uint32_t)(&g_pfnVectors) & 0xFFFF;
reenumerate_usb();
HAL_Init();
SystemClock_Config();
TICK_Init();
osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_USB;
PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void StartDefaultTask(void const * argument)
app_setup();
vTaskDelete( NULL );
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM4) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
EPD_Reset();
EPD_Init();
EPD_Paint_Screen(black);
EPD_Paint_Screen(white);
EPD_string_paint("F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.F.E.A.R.   1234567890   ЙЦУКЕНГШЩЗХЪФЫВЁАПРОЛДЖЭЯЧСМИТЬБЮ QWERTYUIOPASDFGHJKLZXCVBNM йцукенгшщзхъфывапролджэячсмитьбю qwertyuiopasdfghjklzxcvbnm");
asm("nop");
while (1)
void SystemClock_Config(void)
LL_FLASH_SetLatency(LL_FLASH_LATENCY_1);
if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_1)
Error_Handler();
LL_RCC_HSE_Enable();
while(LL_RCC_HSE_IsReady() != 1)
LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_6);
LL_RCC_PLL_Enable();
while(LL_RCC_PLL_IsReady() != 1)
LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
LL_Init1msTick(48000000);
LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
LL_SetSystemCoreClock(48000000);
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_TIM2_Init();
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 10;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
static void MX_TIM2_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
htim2.Instance = TIM2;
htim2.Init.Prescaler = 0;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 1023;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 25;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim2);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, SMPS_EN_Pin|SMPS_V1_Pin|SMPS_SW_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LD4_GPIO_Port, LD4_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SMPS_EN_Pin|SMPS_V1_Pin|SMPS_SW_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SMPS_PG_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(SMPS_PG_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD4_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1) {
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC_Init();
MX_TIM3_Init();
MX_TIM14_Init();
MX_USART1_UART_Init();
MX_SPI1_Init();
MX_TIM1_Init();
Init_Retarget(&huart1);
Init_ADC();
Init_SPI();
Disable_All_Digits();
Init_Fan();
Denit_Fan();
Init_Delay_Timer();
while (1)
ds1820_read();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI14;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.HSI14CalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
bool gpioInit(void)
bool ret = true;
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
for (int i=0; i<GPIO_MAX_CH; i++)
gpioPinMode(i, gpio_tbl[i].mode);
gpioPinWrite(i, gpio_tbl[i].init_value);
cliAdd("gpio", cliGpio);
return ret;
bool gpioPinMode(uint8_t ch, uint8_t mode)
bool ret = true;
GPIO_InitTypeDef GPIO_InitStruct = {0};
if (ch >= GPIO_MAX_CH)
return false;
switch(mode)
case _DEF_INPUT:
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
break;
case _DEF_INPUT_PULLUP:
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
break;
case _DEF_INPUT_PULLDOWN:
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
break;
case _DEF_OUTPUT:
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
break;
case _DEF_OUTPUT_PULLUP:
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
break;
case _DEF_OUTPUT_PULLDOWN:
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
break;
GPIO_InitStruct.Pin = gpio_tbl[ch].pin;
HAL_GPIO_Init(gpio_tbl[ch].port, &GPIO_InitStruct);
return ret;
void gpioPinWrite(uint8_t ch, bool value)
if (ch >= GPIO_MAX_CH)
return;
if (value)
HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].on_state);
else
HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].off_state);
bool gpioPinRead(uint8_t ch)
bool ret = false;
if (ch >= GPIO_MAX_CH)
return false;
if (HAL_GPIO_ReadPin(gpio_tbl[ch].port, gpio_tbl[ch].pin) == gpio_tbl[ch].on_state)
ret = true;
return ret;
void gpioPinToggle(uint8_t ch)
if (ch >= GPIO_MAX_CH)
return;
HAL_GPIO_TogglePin(gpio_tbl[ch].port, gpio_tbl[ch].pin);
void cliGpio(cli_args_t *args)
bool ret = false;
if (args->argc == 1 && args->isStr(0, "show") == true)
while(cliKeepLoop())
for (int i=0; i<GPIO_MAX_CH; i++)
cliPrintf("%d", gpioPinRead(i));
cliPrintf("\\n");
delay(100);
ret = true;
if (args->argc == 2 && args->isStr(0, "read") == true)
uint8_t ch;
ch = (uint8_t)args->getData(1);
while(cliKeepLoop())
cliPrintf("gpio read %d : %d\\n", ch, gpioPinRead(ch));
delay(100);
ret = true;
if (args->argc == 3 && args->isStr(0, "write") == true)
uint8_t ch;
uint8_t data;
ch   = (uint8_t)args->getData(1);
data = (uint8_t)args->getData(2);
gpioPinWrite(ch, data);
cliPrintf("gpio write %d : %d\\n", ch, data);
ret = true;
if (ret != true)
cliPrintf("gpio show\\n");
cliPrintf("gpio read ch[0~%d]\\n", GPIO_MAX_CH-1);
cliPrintf("gpio write ch[0~%d] 0:1\\n", GPIO_MAX_CH-1);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
hcryp.Instance        = CRYP;
hcryp.Init.DataType   = CRYP_DATATYPE_32B;
hcryp.Init.KeySize    = CRYP_KEYSIZE_128B;
hcryp.Init.pKey       = AESKey128;
hcryp.Init.Algorithm  = CRYP_AES_ECB;
HAL_CRYP_Init(&hcryp);
HAL_CRYP_Encrypt(&hcryp, Plaintext, 16, Encryptedtext, TIMEOUT_VALUE);
if(memcmp(Encryptedtext, CiphertextAESECB128, 64) != 0)
Error_Handler();
HAL_CRYP_Decrypt(&hcryp, CiphertextAESECB128 , 16, Decryptedtext, TIMEOUT_VALUE);
if(memcmp(Decryptedtext, Plaintext, 64) != 0)
Error_Handler();
HAL_CRYP_GetConfig(&hcryp, &Conf);
Conf.DataType = CRYP_DATATYPE_32B;
Conf.KeySize  = CRYP_KEYSIZE_192B;
Conf.pKey     = AESKey192;
Conf.Algorithm = CRYP_AES_CBC;
Conf.pInitVect=AESIV_CBC;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Encrypt_DMA(&hcryp, Plaintext, 16, Encryptedtext);
while(CrypCompleteDetected == 0)
if(memcmp(Encryptedtext, CiphertextAESCBC192, 64) != 0)
Error_Handler();
CrypCompleteDetected = 0;
HAL_CRYP_Decrypt_DMA(&hcryp, CiphertextAESCBC192, 16, Decryptedtext);
while(CrypCompleteDetected == 0)
CrypCompleteDetected = 0;
if(memcmp(Decryptedtext, Plaintext, 64) != 0)
Error_Handler();
Conf.pInitVect=AESIV_CTR;
Conf.KeySize  = CRYP_KEYSIZE_256B;
Conf.pKey     = AESKey256;
Conf.Algorithm = CRYP_AES_CTR;
HAL_CRYP_SetConfig(&hcryp, &Conf);
HAL_CRYP_Encrypt_IT(&hcryp, Plaintext, 16, Encryptedtext);
while(CrypCompleteDetected == 0)
CrypCompleteDetected = 0;
if(memcmp(Encryptedtext, CiphertextAESCTR256, 64) != 0)
Error_Handler();
HAL_CRYP_Decrypt_IT(&hcryp, CiphertextAESCTR256, 16, Decryptedtext);
while(CrypCompleteDetected == 0)
{ }
CrypCompleteDetected = 0;
if(memcmp(Decryptedtext, Plaintext, 64) != 0)
Error_Handler();
else
BSP_LED_On(LED1);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
void HAL_CRYP_OutCpltCallback(CRYP_HandleTypeDef *hcryp)
CrypCompleteDetected = 1;
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_RED);
SystemClock_Config();
MX_ICACHE_Init();
MX_GPIO_Init();
MX_COMP1_Init();
MX_COMP2_Init();
if(HAL_COMP_Start(&hcomp1) != HAL_OK)
Error_Handler();
if(HAL_COMP_Start(&hcomp2) != HAL_OK)
Error_Handler();
InputVoltageLevel_Check();
while (1)
if (State == STATE_OVER_THRESHOLD)
if (EnterInStopMode == 1)
SystemClock_Config();
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_RED);
EnterInStopMode = 0;
while(State == STATE_OVER_THRESHOLD)
BSP_LED_Toggle(LED_GREEN);
HAL_Delay(500);
else if (State == STATE_WITHIN_THRESHOLD)
BSP_LED_Off(LED_GREEN);
StopSequence_Config();
else
if (EnterInStopMode == 1)
SystemClock_Config();
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_RED);
EnterInStopMode = 0;
while(State == STATE_UNDER_THRESHOLD)
BSP_LED_Toggle(LED_GREEN);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_COMP1_Init(void)
hcomp1.Instance = COMP1;
hcomp1.Init.InputMinus = COMP_INPUT_MINUS_VREFINT;
hcomp1.Init.InputPlus = COMP_INPUT_PLUS_IO2;
hcomp1.Init.OutputPol = COMP_OUTPUTPOL_NONINVERTED;
hcomp1.Init.Hysteresis = COMP_HYSTERESIS_LOW;
hcomp1.Init.BlankingSrce = COMP_BLANKINGSRC_NONE;
hcomp1.Init.Mode = COMP_POWERMODE_MEDIUMSPEED;
hcomp1.Init.WindowMode = COMP_WINDOWMODE_DISABLE;
hcomp1.Init.TriggerMode = COMP_TRIGGERMODE_IT_RISING_FALLING;
if (HAL_COMP_Init(&hcomp1) != HAL_OK)
Error_Handler();
static void MX_COMP2_Init(void)
hcomp2.Instance = COMP2;
hcomp2.Init.InputMinus = COMP_INPUT_MINUS_1_4VREFINT;
hcomp2.Init.InputPlus = COMP_INPUT_PLUS_IO1;
hcomp2.Init.OutputPol = COMP_OUTPUTPOL_NONINVERTED;
hcomp2.Init.Hysteresis = COMP_HYSTERESIS_LOW;
hcomp2.Init.BlankingSrce = COMP_BLANKINGSRC_NONE;
hcomp2.Init.Mode = COMP_POWERMODE_MEDIUMSPEED;
hcomp2.Init.WindowMode = COMP_WINDOWMODE_COMP1_INPUT_PLUS_COMMON;
hcomp2.Init.TriggerMode = COMP_TRIGGERMODE_IT_RISING_FALLING;
if (HAL_COMP_Init(&hcomp2) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOB_CLK_ENABLE();
static void InputVoltageLevel_Check(void)
if (((HAL_COMP_GetOutputLevel(&hcomp1)) == COMP_OUTPUT_LEVEL_HIGH)
&& ((HAL_COMP_GetOutputLevel(&hcomp2)) == COMP_OUTPUT_LEVEL_HIGH))
State = STATE_OVER_THRESHOLD;
else if (((HAL_COMP_GetOutputLevel(&hcomp1)) == COMP_OUTPUT_LEVEL_LOW)
&& ((HAL_COMP_GetOutputLevel(&hcomp2)) == COMP_OUTPUT_LEVEL_HIGH))
State = STATE_WITHIN_THRESHOLD;
else if (((HAL_COMP_GetOutputLevel(&hcomp1)) == COMP_OUTPUT_LEVEL_LOW)
&& ((HAL_COMP_GetOutputLevel(&hcomp2)) == COMP_OUTPUT_LEVEL_LOW))
State = STATE_UNDER_THRESHOLD;
static void StopSequence_Config(void)
EnterInStopMode = 1;
HAL_PWREx_EnterSTOP1Mode(PWR_STOPENTRY_WFI);
void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp)
InputVoltageLevel_Check();
void Error_Handler(void)
BSP_LED_On(LED_RED);
while(1)
void assert_failed(uint8_t *file, uint32_t line)
Error_Handler();
int main (void)
uint8_t lens = 0;
HAL_Init ();
SystemClock_Config ();
MX_GPIO_Init ();
MX_USART1_UART_Init ();
MX_CAN1_Init ();
printf ("Start\\r\\n");
sFilterConfig.FilterBank = 0;
sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK;
sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT;
sFilterConfig.FilterIdHigh = 0x0000;
sFilterConfig.FilterIdLow = 0x0000;
sFilterConfig.FilterMaskIdHigh = 0x0000;
sFilterConfig.FilterMaskIdLow = 0x0000;
sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0;
sFilterConfig.FilterActivation = ENABLE;
sFilterConfig.SlaveStartFilterBank = 14;
if (HAL_CAN_ConfigFilter (&hcan1, &sFilterConfig) != HAL_OK)
printf ("config error\\r\\n");
if (HAL_CAN_Start (&hcan1) != HAL_OK)
printf ("start error\\r\\n");
TxData[1] = 0x22;
TxData[2] = 0x33;
TxData[3] = 0x44;
TxData[4] = 0x55;
TxData[5] = 0x66;
TxData[6] = 0x77;
TxData[7] = 0x88;
x = 0;
y = 0;
while (1)
if (x++ == 200)
x = 0;
for (y = 0; y < 8; y++)
TxData[y] = x+y;
CAN_TX (&hcan1, TxData, 8, 0x18);
CAN_RX (&hcan1, RxData, &lens);
printf ("send done\\r\\n");
for (temp = 0; temp < 8; temp++)
printf ("0X%x\\t ", RxData[temp]);
printf ("\\r\\nreceive done\\r\\n");
void SystemClock_Config (void)
RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 15;
RCC_OscInitStruct.PLL.PLLN = 216;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig (&RCC_OscInitStruct) != HAL_OK)
Error_Handler ();
if (HAL_PWREx_EnableOverDrive () != HAL_OK)
Error_Handler ();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig (&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler ();
HAL_StatusTypeDef CAN_TX (CAN_HandleTypeDef*hcan,uint8_t*txbuf,uint8_t len,uint8_t StdID)
CAN_TxHeaderTypeDef txHeader;
uint32_t txmailbox;
txHeader.StdId = StdID;
txHeader.RTR = CAN_RTR_DATA;
txHeader.IDE = CAN_ID_STD;
txHeader.DLC = len;
TxHeader.TransmitGlobalTime = DISABLE;
if (HAL_CAN_AddTxMessage (hcan, &txHeader, txbuf, &txmailbox) != HAL_OK)
printf ("add error\\r\\n");
return HAL_ERROR;
while (HAL_CAN_GetTxMailboxesFreeLevel (&hcan1) != 3)
return HAL_OK;
HAL_StatusTypeDef CAN_RX (CAN_HandleTypeDef*hcan,uint8_t*rxbuf,uint8_t*len)
CAN_TxHeaderTypeDef rxHeader;
if (HAL_CAN_GetRxFifoFillLevel (hcan, CAN_RX_FIFO0) != 1)
printf ("rx error\\r\\n");
if (HAL_CAN_GetRxMessage (hcan, CAN_RX_FIFO0, &rxHeader, rxbuf) != HAL_OK)
printf ("get rx error\\r\\n");
*len = rxHeader.DLC;
return HAL_OK;
void Error_Handler (void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
u8 len;
u16 times = 0;
HAL_Init();
Stm32_Clock_Init(RCC_PLL_MUL9);
delay_init(72);
uart_init(115200);
LED_Init();
KEY_Init();
while(1)
if(USART_RX_STA & 0x8000)
len = USART_RX_STA & 0x3fff;
printf("\\r\\n您发送的消息为:\\r\\n");
HAL_UART_Transmit(&UART1_Handler, (uint8_t *)USART_RX_BUF, len, 1000);
while(__HAL_UART_GET_FLAG(&UART1_Handler, UART_FLAG_TC) != SET);
printf("\\r\\n\\r\\n");
USART_RX_STA = 0;
else
times++;
if(times % 5000 == 0)
printf("\\r\\nALIENTEK 战舰STM32开发板 串口实验\\r\\n");
printf("正点原子@ALIENTEK\\r\\n\\r\\n\\r\\n");
if(times % 200 == 0)printf("请输入数据,以回车键结束\\r\\n");
if(times % 30 == 0)LED0 = !LED0;
delay_ms(10);
int main(void)
uint8_t Data;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_UART_Init(115200);
trace_printf("Hello\\n");
while (1)
if(HAL_UART_Receive_IT(&huart6,&Data,1) == HAL_OK)
HAL_UART_Transmit_IT(&huart6,&Data,1);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LED_On(LED3);
BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_GPIO);
BSP_LCD_Init();
Display_DemoDescription();
while (1)
if(BSP_PB_GetState(BUTTON_WAKEUP) != GPIO_PIN_RESET)
while (BSP_PB_GetState(BUTTON_WAKEUP) != GPIO_PIN_RESET);
BSP_examples[DemoIndex++].DemoFunc();
if(DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples))
NbLoop++;
DemoIndex = 0;
Display_DemoDescription();
static void Error_Handler(void)
BSP_LED_Off(LED3);
BSP_LED_On(LED4);
while(1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
Error_Handler();
static void Display_DemoDescription(void)
uint8_t desc[50];
BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
BSP_LCD_Clear(LCD_COLOR_WHITE);
BSP_LCD_SetTextColor(LCD_COLOR_DARKBLUE);
BSP_LCD_DisplayStringAt(0, 2, (uint8_t *)"STM32F413H BSP", CENTER_MODE);
BSP_LCD_DisplayStringAt(0, 14, (uint8_t *)"Drivers examples", CENTER_MODE);
BSP_LCD_DrawBitmap((BSP_LCD_GetXSize() - 80)/2, 30, (uint8_t *)stlogo);
BSP_LCD_SetFont(&Font12);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()-12, (uint8_t *)"STMicroelectronics 2017", CENTER_MODE);
BSP_LCD_SetFont(&Font12);
BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
BSP_LCD_FillRect(0, BSP_LCD_GetYSize()/2 + 1, BSP_LCD_GetXSize(), 60);
BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()/2 + 20, (uint8_t *)"Press button to start :", CENTER_MODE);
sprintf((char *)desc,"%s example", BSP_examples[DemoIndex].DemoName);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()/2 + 35, (uint8_t *)desc, CENTER_MODE);
uint8_t CheckForUserInput(void)
if(BSP_PB_GetState(BUTTON_WAKEUP) != GPIO_PIN_RESET)
while (BSP_PB_GetState(BUTTON_WAKEUP) != GPIO_PIN_RESET);
return 1 ;
return 0;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
static uint32_t debounce_time = 0;
if(GPIO_Pin == BUTTON_WAKEUP)
if((HAL_GetTick() - debounce_time) > 50)
debounce_time = HAL_GetTick();
else if(GPIO_Pin == SD_DETECT_PIN)
SDDetectIT = 1;
void assert_failed(uint8_t* file, uint32_t line)
while (1)
static int32_t platform_write(void *handle, uint8_t Reg, uint8_t *Bufp,
uint16_t len)
if (handle == &hi2c1)
HAL_I2C_Mem_Write(handle, slave_address, Reg,
I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000);
else if (handle == &hspi2)
HAL_GPIO_WritePin(CS_SPI2_GPIO_Port, CS_SPI2_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Transmit(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_SPI2_GPIO_Port, CS_SPI2_Pin, GPIO_PIN_SET);
else if (handle == &hspi1)
HAL_GPIO_WritePin(CS_SPI1_GPIO_Port, CS_SPI1_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Transmit(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_SPI1_GPIO_Port, CS_SPI1_Pin, GPIO_PIN_SET);
return 0;
static int32_t platform_read(void *handle, uint8_t Reg, uint8_t *Bufp,
uint16_t len)
if (handle == &hi2c1)
HAL_I2C_Mem_Read(handle, slave_address, Reg,
I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000);
else if (handle == &hspi2)
Reg |= 0x80;
HAL_GPIO_WritePin(CS_DEV_GPIO_Port, CS_DEV_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Receive(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_DEV_GPIO_Port, CS_DEV_Pin, GPIO_PIN_SET);
else
Reg |= 0x80;
HAL_GPIO_WritePin(CS_RF_GPIO_Port, CS_RF_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Receive(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_RF_GPIO_Port, CS_RF_Pin, GPIO_PIN_SET);
return 0;
static void tx_com(uint8_t *tx_buffer, uint16_t len)
HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
CDC_Transmit_FS(tx_buffer, len);
static void platform_delay(uint32_t timeout)
volatile uint32_t i;
for(i = 0; i < timeout; i++);
static void platform_init(void)
uint8_t i;
GPIO_InitTypeDef GPIO_InitStruct;
GPIO_InitStruct.Pin = GPIO_PIN_8;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
for (i = 0; i < 9; i++) {
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
platform_delay(100);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
platform_delay(100);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
MX_I2C1_Init();
void example_main_lsm6dsox(void)
lsm6dsox_ctx_t dev_ctx;
dev_ctx.write_reg = platform_write;
dev_ctx.read_reg = platform_read;
dev_ctx.handle = &hi2c1;
platform_init();
lsm6dsox_device_id_get(&dev_ctx, &whoamI);
if (whoamI != LSM6DSOX_ID)
while(1);
lsm6dsox_reset_set(&dev_ctx, PROPERTY_ENABLE);
do {
lsm6dsox_reset_get(&dev_ctx, &rst);
} while (rst);
lsm6dsox_i3c_disable_set(&dev_ctx, LSM6DSOX_I3C_DISABLE);
lsm6dsox_block_data_update_set(&dev_ctx, PROPERTY_ENABLE);
lsm6dsox_xl_data_rate_set(&dev_ctx, LSM6DSOX_XL_ODR_12Hz5);
lsm6dsox_gy_data_rate_set(&dev_ctx, LSM6DSOX_GY_ODR_12Hz5);
lsm6dsox_xl_full_scale_set(&dev_ctx, LSM6DSOX_2g);
lsm6dsox_gy_full_scale_set(&dev_ctx, LSM6DSOX_2000dps);
lsm6dsox_xl_hp_path_on_out_set(&dev_ctx, LSM6DSOX_LP_ODR_DIV_100);
lsm6dsox_xl_filter_lp2_set(&dev_ctx, PROPERTY_ENABLE);
while(1)
lsm6dsox_reg_t reg;
lsm6dsox_status_reg_get(&dev_ctx, &reg.status_reg);
if (reg.status_reg.xlda)
memset(data_raw_acceleration.u8bit, 0x00, 3 * sizeof(int16_t));
lsm6dsox_acceleration_raw_get(&dev_ctx, data_raw_acceleration.u8bit);
acceleration_mg[0] =
lsm6dsox_from_fs2_to_mg(data_raw_acceleration.i16bit[0]);
acceleration_mg[1] =
lsm6dsox_from_fs2_to_mg(data_raw_acceleration.i16bit[1]);
acceleration_mg[2] =
lsm6dsox_from_fs2_to_mg(data_raw_acceleration.i16bit[2]);
sprintf((char*)tx_buffer, "Acceleration [mg]:%4.2f\\t%4.2f\\t%4.2f\\r\\n",
acceleration_mg[0], acceleration_mg[1], acceleration_mg[2]);
tx_com(tx_buffer, strlen((char const*)tx_buffer));
if (reg.status_reg.gda)
memset(data_raw_angular_rate.u8bit, 0x00, 3 * sizeof(int16_t));
lsm6dsox_angular_rate_raw_get(&dev_ctx, data_raw_angular_rate.u8bit);
angular_rate_mdps[0] =
lsm6dsox_from_fs2000_to_mdps(data_raw_angular_rate.i16bit[0]);
angular_rate_mdps[1] =
lsm6dsox_from_fs2000_to_mdps(data_raw_angular_rate.i16bit[1]);
angular_rate_mdps[2] =
lsm6dsox_from_fs2000_to_mdps(data_raw_angular_rate.i16bit[2]);
sprintf((char*)tx_buffer, "Angular rate [mdps]:%4.2f\\t%4.2f\\t%4.2f\\r\\n",
angular_rate_mdps[0], angular_rate_mdps[1], angular_rate_mdps[2]);
tx_com(tx_buffer, strlen((char const*)tx_buffer));
if (reg.status_reg.tda)
memset(data_raw_temperature.u8bit, 0x00, sizeof(int16_t));
lsm6dsox_temperature_raw_get(&dev_ctx, data_raw_temperature.u8bit);
temperature_degC = lsm6dsox_from_lsb_to_celsius(data_raw_temperature.i16bit);
sprintf((char*)tx_buffer,
"Temperature [degC]:%6.2f\\r\\n",
temperature_degC);
tx_com(tx_buffer, strlen((char const*)tx_buffer));
int main( void )
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
while( BSP_NFCTAG_Init( ) != NFCTAG_OK );
MX_GPIO_Init();
MX_SPI1_Init();
NFC02A1_LED_Init( );
Enable_EnergyHarvesting();
NFC02A1_LED_ON( BLUE_LED );
NDEF_BUFFER1[0] = 0;
BSP_NFCTAG_WriteData(NDEF_BUFFER1, 0, 2 );
while( 1 )
espComm();
androidComm();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_SLAVE;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
void Enable_EnergyHarvesting( void )
if( BSP_NFCTAG_GetExtended_Drv() != NULL )
BSP_NFCTAG_GetExtended_Drv()->SetEH( );
BSP_NFCTAG_GetExtended_Drv()->Enable_EH_mode();
BSP_NFCTAG_GetExtended_Drv()->WriteEH_Cfg( M24LR_EH_Cfg_6MA );
void Disable_EnergyHarvesting( void )
if( BSP_NFCTAG_GetExtended_Drv() != NULL )
BSP_NFCTAG_GetExtended_Drv()->ResetEH( );
BSP_NFCTAG_GetExtended_Drv()->Enable_EH_mode();
BSP_NFCTAG_GetExtended_Drv()->WriteEH_Cfg( M24LR_EH_Cfg_6MA );
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitStruct.Pin = PushButton_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(PushButton_GPIO_Port, &GPIO_InitStruct);
void assert_failed( uint8_t* file, uint32_t line )
while( 1 )
int main(void)
GPIO_InitTypeDef  GPIO_InitStruct;
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
GPIO_InitStruct.Pin = GPIO_PIN_12;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
NVIC_SetPriority((IRQn_Type)(EXTI4_15_IRQn), 0x03);
HAL_NVIC_EnableIRQ((IRQn_Type)(EXTI4_15_IRQn));
osSemaphoreDef(SEM);
osSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1);
osThreadDef(SEM_Thread, SemaphoreTest, osPriorityNormal, 0, semtstSTACK_SIZE);
osThreadCreate(osThread(SEM_Thread), (void *) osSemaphore);
osKernelStart();
for (;;);
static void SemaphoreTest(void const *argument)
for (;;)
if (osSemaphore != NULL)
if (osSemaphoreWait(osSemaphore , 0) == osOK)
BSP_LED_Toggle(LED3);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
osSemaphoreRelease(osSemaphore);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
__HAL_RTC_RESET_HANDLE_STATE(&RtcHandle);
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
BSP_LED_On(LED1);
if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1) != 0x32F2)
RTC_CalendarConfig();
else
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
BSP_LED_On(LED2);
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
BSP_LED_On(LED1);
__HAL_RCC_CLEAR_RESET_FLAGS();
while (1)
RTC_CalendarShow(aShowTime, aShowDate);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void RTC_CalendarConfig(void)
RTC_DateTypeDef sdatestructure;
RTC_TimeTypeDef stimestructure;
sdatestructure.Year = 0x14;
sdatestructure.Month = RTC_MONTH_FEBRUARY;
sdatestructure.Date = 0x18;
sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
stimestructure.Hours = 0x02;
stimestructure.Minutes = 0x00;
stimestructure.Seconds = 0x00;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
static void RTC_CalendarShow(uint8_t *showtime, uint8_t *showdate)
RTC_DateTypeDef sdatestructureget;
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char *)showtime, "%2d:%2d:%2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
sprintf((char *)showdate, "%2d-%2d-%2d", sdatestructureget.Month, sdatestructureget.Date, 2000 + sdatestructureget.Year);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
CrcHandle.Instance = CRC;
if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
Error_Handler();
uwCRCValue = HAL_CRC_Accumulate(&CrcHandle, (uint32_t *)aDataBuffer, BUFFER_SIZE);
if (uwCRCValue != uwExpectedCRCValue)
Error_Handler();
else
BSP_LED_On(LED3);
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV2;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
static void Error_Handler(void)
while (1)
BSP_LED_Toggle(LED4);
HAL_Delay(1000);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
while (1)
HAL_Delay(1000);
BSP_LED_Toggle(LED2);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == BUTTON_SW1_PIN)
if (uwIncrementState == 0)
HAL_SuspendTick();
uwIncrementState = 1;
else
HAL_ResumeTick();
uwIncrementState = 0;
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM2) {
HAL_IncTick();
void Error_Handler(void)
while(1)
void assert_failed(uint8_t *file, uint32_t line)
void syncir_exit(void)
syncir_disable();
HAL_GPIO_DeInit(IRx_SYNC_GPIO_PORT, IRx_SYNC_PIN);
pfnSyncIrq_l = NULL;
void syncir_acknowledge(void)
void syncir_enable(void)
__HAL_GPIO_EXTI_CLEAR_IT(IRx_SYNC_PIN);
HAL_NVIC_ClearPendingIRQ(Rx_SYNC_IRQn);
NVIC_EnableIRQ(Rx_SYNC_IRQn);
void syncir_disable(void)
NVIC_DisableIRQ(Rx_SYNC_IRQn);
void syncir_enterCriticalSection(UINT8 fEnable_p)
if(fEnable_p)
__enable_irq();
else
__disable_irq();
tPlatformSyncIrq syncir_getSyncCallback(void)
return pfnSyncIrq_l;
void syncir_setSyncCallback(tPlatformSyncIrq pfnSyncCb_p)
pfnSyncIrq_l = pfnSyncCb_p;
void HAL_GPIO_EXTI_Callback(uint16_t gpioPin_p)
if(gpioPin_p == IRx_SYNC_PIN)
if(pfnSyncIrq_l != NULL)
pfnSyncIrq_l(NULL);
void IRx_SYNC_IRQHandler(void)
HAL_GPIO_EXTI_IRQHandler(IRx_SYNC_PIN);
int main(void)
int32_t timeout;
timeout = 0xFFFF;
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
if ( timeout < 0 )
Error_Handler();
HAL_Init();
SystemClock_Config();
__HAL_RCC_HSEM_CLK_ENABLE();
HAL_HSEM_FastTake(HSEM_ID_0);
HAL_HSEM_Release(HSEM_ID_0,0);
timeout = 0xFFFF;
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
if ( timeout < 0 )
Error_Handler();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART1_UART_Init();
MX_QUADSPI_Init();
MX_RTC_Init();
MX_TIM1_Init();
MX_TIM13_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);
while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
__HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI
|RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 192;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
|RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1
|RCC_PERIPHCLK_UART8|RCC_PERIPHCLK_SPDIFRX
|RCC_PERIPHCLK_SPI5|RCC_PERIPHCLK_SPI2
|RCC_PERIPHCLK_SAI1|RCC_PERIPHCLK_SDMMC
|RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_CEC
|RCC_PERIPHCLK_QSPI;
PeriphClkInitStruct.PLL2.PLL2M = 2;
PeriphClkInitStruct.PLL2.PLL2N = 12;
PeriphClkInitStruct.PLL2.PLL2P = 1;
PeriphClkInitStruct.PLL2.PLL2Q = 2;
PeriphClkInitStruct.PLL2.PLL2R = 2;
PeriphClkInitStruct.PLL2.PLL2RGE = RCC_PLL2VCIRANGE_3;
PeriphClkInitStruct.PLL2.PLL2VCOSEL = RCC_PLL2VCOMEDIUM;
PeriphClkInitStruct.PLL2.PLL2FRACN = 0;
PeriphClkInitStruct.QspiClockSelection = RCC_QSPICLKSOURCE_D1HCLK;
PeriphClkInitStruct.SdmmcClockSelection = RCC_SDMMCCLKSOURCE_PLL;
PeriphClkInitStruct.Sai1ClockSelection = RCC_SAI1CLKSOURCE_PLL;
PeriphClkInitStruct.Spi123ClockSelection = RCC_SPI123CLKSOURCE_PLL;
PeriphClkInitStruct.Spi45ClockSelection = RCC_SPI45CLKSOURCE_D2PCLK1;
PeriphClkInitStruct.SpdifrxClockSelection = RCC_SPDIFRXCLKSOURCE_PLL;
PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;
PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;
PeriphClkInitStruct.CecClockSelection = RCC_CECCLKSOURCE_LSI;
PeriphClkInitStruct.AdcClockSelection = RCC_ADCCLKSOURCE_PLL2;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSI, RCC_MCODIV_1);
void MX_IWDG1_Init(void)
hiwdg1.Instance = IWDG1;
hiwdg1.Init.Prescaler = IWDG_PRESCALER_64;
hiwdg1.Init.Window = 4095;
hiwdg1.Init.Reload = 4095;
if (HAL_IWDG_Init(&hiwdg1) != HAL_OK)
Error_Handler();
static void MX_QUADSPI_Init(void)
hqspi.Instance = QUADSPI;
hqspi.Init.ClockPrescaler = 255;
hqspi.Init.FifoThreshold = 1;
hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_NONE;
hqspi.Init.FlashSize = 1;
hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_1_CYCLE;
hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
hqspi.Init.DualFlash = QSPI_DUALFLASH_ENABLE;
if (HAL_QSPI_Init(&hqspi) != HAL_OK)
Error_Handler();
static void MX_RTC_Init(void)
RTC_TamperTypeDef sTamper = {0};
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
sTamper.Tamper = RTC_TAMPER_1;
sTamper.Trigger = RTC_TAMPERTRIGGER_RISINGEDGE;
sTamper.NoErase = RTC_TAMPER_ERASE_BACKUP_ENABLE;
sTamper.MaskFlag = RTC_TAMPERMASK_FLAG_DISABLE;
sTamper.Filter = RTC_TAMPERFILTER_DISABLE;
sTamper.SamplingFrequency = RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768;
sTamper.PrechargeDuration = RTC_TAMPERPRECHARGEDURATION_1RTCCLK;
sTamper.TamperPullUp = RTC_TAMPER_PULLUP_ENABLE;
sTamper.TimeStampOnTamperDetection = RTC_TIMESTAMPONTAMPERDETECTION_ENABLE;
if (HAL_RTCEx_SetTamper(&hrtc, &sTamper) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = 0;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 65535;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_TIM13_Init(void)
htim13.Instance = TIM13;
htim13.Init.Prescaler = 0;
htim13.Init.CounterMode = TIM_COUNTERMODE_UP;
htim13.Init.Period = 65535;
htim13.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim13.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim13) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOG_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
GPIO_InitStruct.Pin = CEC_CK_MCO1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF0_MCO;
HAL_GPIO_Init(CEC_CK_MCO1_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void HW_Init( void )
if( McuInitialized == false )
SCB->VTOR = FLASH_BASE | 0x3000;
HW_AdcInit( );
Radio.IoInit( );
HW_SPI_Init( );
HW_RTC_Init( );
MX_I2C1_Init();
McuInitialized = true;
void HW_DeInit( void )
HW_SPI_DeInit( );
Radio.IoDeInit( );
vcom_DeInit( );
McuInitialized = false;
static void HW_IoInit( void )
vcom_Init();
vcom_IoInit( );
HW_SPI_IoInit( );
Radio.IoInit( );
static void HW_IoDeInit( void )
HW_SPI_IoDeInit( );
Radio.IoDeInit( );
vcom_IoDeInit( );
void HW_GpioInit(void)
void SystemClock_Config( void )
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSEState            = RCC_HSE_OFF;
RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLLMUL_6;
RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLLDIV_3;
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_HIGH);
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while (__HAL_PWR_GET_FLAG(PWR_FLAG_VOS) != RESET) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
uint32_t HW_GetRandomSeed( void )
return ( ( *( uint32_t* )ID1 ) ^ ( *( uint32_t* )ID2 ) ^ ( *( uint32_t* )ID3 ) );
void HW_GetUniqueId( uint8_t *id )
id[7] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 24;
id[6] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 16;
id[5] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 8;
id[4] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) );
id[3] = ( ( *( uint32_t* )ID2 ) ) >> 24;
id[2] = ( ( *( uint32_t* )ID2 ) ) >> 16;
id[1] = ( ( *( uint32_t* )ID2 ) ) >> 8;
id[0] = ( ( *( uint32_t* )ID2 ) );
uint16_t HW_GetTemperatureLevel( void )
uint16_t measuredLevel =0;
uint32_t batteryLevelmV;
uint16_t temperatureDegreeC;
measuredLevel = HW_AdcReadChannel( ADC_CHANNEL_VREFINT );
if (measuredLevel ==0)
batteryLevelmV =0;
else
batteryLevelmV= (( (uint32_t) VDDA_VREFINT_CAL * (*VREFINT_CAL ) )/ measuredLevel);
PRINTF("VDDA= %d\\n\\r", batteryLevelmV);
measuredLevel = HW_AdcReadChannel( ADC_CHANNEL_TEMPSENSOR );
temperatureDegreeC = COMPUTE_TEMPERATURE( measuredLevel, batteryLevelmV);
uint16_t temperatureDegreeC_Int= (temperatureDegreeC)>>8;
uint16_t temperatureDegreeC_Frac= ((temperatureDegreeC-(temperatureDegreeC_Int<<8))*100)>>8;
PRINTF("temp= %d, %d,%d\\n\\r", temperatureDegreeC, temperatureDegreeC_Int, temperatureDegreeC_Frac);
return (uint16_t) temperatureDegreeC;
uint8_t HW_GetBatteryLevel( void )
uint8_t batteryLevel = 0;
uint16_t measuredLevel = 0;
uint32_t batteryLevelmV;
measuredLevel = HW_AdcReadChannel( ADC_CHANNEL_VREFINT );
if (measuredLevel == 0)
batteryLevelmV = 0;
else
batteryLevelmV= (( (uint32_t) VDDA_VREFINT_CAL * (*VREFINT_CAL ) )/ measuredLevel);
if (batteryLevelmV > VDD_BAT)
batteryLevel = LORAWAN_MAX_BAT;
else if (batteryLevelmV < VDD_MIN)
batteryLevel = 0;
else
batteryLevel = (( (uint32_t) (batteryLevelmV - VDD_MIN)*LORAWAN_MAX_BAT) /(VDD_BAT-VDD_MIN) );
return batteryLevel;
void HW_AdcInit( void )
if( AdcInitialized == false )
AdcInitialized = true;
GPIO_InitTypeDef initStruct;
hadc.Instance  = ADC1;
hadc.Init.OversamplingMode      = DISABLE;
hadc.Init.ClockPrescaler        = ADC_CLOCK_SYNC_PCLK_DIV4;
hadc.Init.LowPowerAutoPowerOff  = DISABLE;
hadc.Init.LowPowerFrequencyMode = ENABLE;
hadc.Init.LowPowerAutoWait      = DISABLE;
hadc.Init.Resolution            = ADC_RESOLUTION_12B;
hadc.Init.SamplingTime          = ADC_SAMPLETIME_160CYCLES_5;
hadc.Init.ScanConvMode          = ADC_SCAN_DIRECTION_FORWARD;
hadc.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
hadc.Init.ContinuousConvMode    = DISABLE;
hadc.Init.DiscontinuousConvMode = DISABLE;
hadc.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc.Init.EOCSelection          = ADC_EOC_SINGLE_CONV;
hadc.Init.DMAContinuousRequests = DISABLE;
ADCCLK_ENABLE();
HAL_ADC_Init( &hadc );
initStruct.Mode =GPIO_MODE_ANALOG;
initStruct.Pull = GPIO_NOPULL;
initStruct.Speed = GPIO_SPEED_HIGH;
HW_GPIO_Init( BAT_LEVEL_PORT, BAT_LEVEL_PIN, &initStruct );
void HW_AdcDeInit( void )
AdcInitialized = false;
uint16_t HW_AdcReadChannel( uint32_t Channel )
ADC_ChannelConfTypeDef adcConf;
uint16_t adcData = 0;
if( AdcInitialized == true )
while (__HAL_PWR_GET_FLAG(PWR_FLAG_VREFINTRDY) == RESET) {};
ADCCLK_ENABLE();
HAL_ADCEx_Calibration_Start(&hadc, ADC_SINGLE_ENDED );
adcConf.Channel = ADC_CHANNEL_MASK;
adcConf.Rank = ADC_RANK_NONE;
HAL_ADC_ConfigChannel( &hadc, &adcConf);
adcConf.Channel = Channel;
adcConf.Rank = ADC_RANK_CHANNEL_NUMBER;
HAL_ADC_ConfigChannel( &hadc, &adcConf);
HAL_ADC_Start( &hadc);
HAL_ADC_PollForConversion( &hadc, HAL_MAX_DELAY );
adcData = HAL_ADC_GetValue ( &hadc);
__HAL_ADC_DISABLE( &hadc) ;
ADCCLK_DISABLE();
return adcData;
void LPM_EnterStopMode( void)
BACKUP_PRIMASK();
DISABLE_IRQ( );
HW_IoDeInit( );
SET_BIT(PWR->CR, PWR_CR_CWUF);
RESTORE_PRIMASK( );
HAL_PWR_EnterSTOPMode ( PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI );
void LPM_ExitStopMode( void)
BACKUP_PRIMASK();
DISABLE_IRQ( );
__HAL_RCC_HSI_ENABLE();
while( __HAL_RCC_GET_FLAG(RCC_FLAG_HSIRDY) == RESET ) {}
__HAL_RCC_PLL_ENABLE();
while( __HAL_RCC_GET_FLAG( RCC_FLAG_PLLRDY ) == RESET ) {}
__HAL_RCC_SYSCLK_CONFIG ( RCC_SYSCLKSOURCE_PLLCLK );
while( __HAL_RCC_GET_SYSCLK_SOURCE( ) != RCC_SYSCLKSOURCE_STATUS_PLLCLK ) {}
HW_IoInit( );
RESTORE_PRIMASK( );
void LPM_EnterSleepMode( void)
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
printf("Hello World!\\r\\n");
HAL_UART_Receive_IT(&huart1,(uint8_t*)aRxBuffer,1);
HAL_SuspendTick();
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
HAL_ResumeTick();
while (1)
printf("Hello\\r\\n");
HAL_Delay(1500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 72;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 3;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
int fputc(int ch, FILE *f)
uint8_t temp[1] = {ch};
HAL_UART_Transmit(&huart1, temp, 1, 2);
return ch;
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
printf("%c\\r\\n", aRxBuffer[0]);
HAL_UART_Receive_IT(&huart1,(uint8_t*)aRxBuffer,1);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_UART_Init(115200);
ASK25_LCD_Init(Inc, DispShiftOff);
ASK25_LCD_Display_String("EDUTECH",1,1,Off);
trace_printf("Hello\\n");
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 210;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
osThreadDef(LED1, LED_Thread1, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
osThreadDef(LED2, LED_Thread2, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
LEDThread1Handle = osThreadCreate(osThread(LED1), NULL);
LEDThread2Handle = osThreadCreate(osThread(LED2), NULL);
osKernelStart();
for (;;);
static void LED_Thread1(void const *argument)
uint32_t count = 0;
(void) argument;
for (;;)
count = osKernelSysTick() + 5000;
while (count >= osKernelSysTick())
BSP_LED_Toggle(LED1);
osDelay(200);
BSP_LED_Off(LED1);
osThreadSuspend(NULL);
count = osKernelSysTick() + 5000;
while (count >= osKernelSysTick())
BSP_LED_Toggle(LED1);
osDelay(400);
osThreadResume(LEDThread2Handle);
static void LED_Thread2(void const *argument)
uint32_t count;
(void) argument;
for (;;)
count = osKernelSysTick() + 10000;
while (count >= osKernelSysTick())
BSP_LED_Toggle(LED2);
osDelay(500);
BSP_LED_Off(LED2);
osThreadResume(LEDThread1Handle);
osThreadSuspend(NULL);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 20;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
while(1);
void assert_failed(char *file, uint32_t line)
while (1)
{}
int main(void)
IWDG_StopDebugMCU();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM7_Init();
MX_USART2_UART_Init();
MX_IWDG_Init();
MX_NVIC_Init();
BLDR_IfUartEnter(NULL);
NO_RETURN_NEVER_COME_HERE();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_NVIC_Init(void)
HAL_NVIC_SetPriority(TIM7_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(TIM7_IRQn);
static void MX_IWDG_Init(void)
hiwdg.Instance = IWDG;
hiwdg.Init.Prescaler = IWDG_PRESCALER_256;
hiwdg.Init.Reload = 0xfff;
if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
Error_Handler();
static void MX_TIM7_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim7.Instance = TIM7;
htim7.Init.Prescaler = 18000;
htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
htim7.Init.Period = 4999;
htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = PB_BLUE_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(PB_BLUE_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_GREEN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_GPIO);
if(BSP_PB_GetState(BUTTON_WAKEUP) == 0x00)
if(((*(__IO uint32_t*)USBD_DFU_APP_DEFAULT_ADD) & 0x2FF80000 ) == 0x20000000)
JumpAddress = *(__IO uint32_t*) (USBD_DFU_APP_DEFAULT_ADD + 4);
JumpToApplication = (pFunction) JumpAddress;
__set_MSP(*(__IO uint32_t*) USBD_DFU_APP_DEFAULT_ADD);
JumpToApplication();
USBD_Init(&USBD_Device, &DFU_Desc, 0);
USBD_RegisterClass(&USBD_Device, USBD_DFU_CLASS);
USBD_DFU_RegisterMedia(&USBD_Device, &USBD_DFU_Flash_fops);
USBD_Start(&USBD_Device);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLSAIP;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
void HAL_Delay(__IO uint32_t Delay)
while(Delay)
if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
Delay--;
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int fputc(int ch, FILE *f)
HAL_UART_Transmit(&huart2, (unsigned char *)&ch, 1, 10);
return ch;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_SPI1_Init();
MX_USB_DEVICE_Init();
printf("initializing NRF...\\n");
nrf24_init();
nrf24_config(NRF_CHANNEL, NRF_PAYLOAD_SIZE);
nrf24_tx_address(tx_address);
nrf24_rx_address(rx_address);
printf("done\\n");
while (1)
if(nrf24_dataReady())
HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_SET);
nrf24_getData(received_data);
printf("received: ");
for (int i = 0; i < NRF_PAYLOAD_SIZE; ++i)
printf("%d ", received_data[i]);
printf("\\n");
HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_HalfDuplex_Init(&huart2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(NRF_CE_GPIO_Port, NRF_CE_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USER_BUTTON_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SW_D_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
HAL_GPIO_Init(SW_D_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SW_B_Pin|PCB_JUMPER_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SPI1_CS_Pin|USER_LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = NRF_CE_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(NRF_CE_GPIO_Port, &GPIO_InitStruct);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
__GPIOA_CLK_ENABLE();
GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull  = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_HIGH;
GPIO_InitStruct.Pin = GPIO_PIN_4;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Mode  = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull  = GPIO_PULLUP;
GPIO_InitStruct.Pin = GPIO_PIN_3;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
while (1){
if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_3) == GPIO_PIN_RESET){
HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_SET);
}else{
HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_RESET);
static void SystemClock_Config(void)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
char Message[]="Counter: ";
char newLine[]="\\r\\n";
uint8_t clearInstruction[]={0x7C, 0x2D};
HAL_UART_Transmit(&huart1, (uint8_t *) clearInstruction, sizeof(clearInstruction), HAL_MAX_DELAY);
uint8_t inc = 0;
while (1)
char print[3];
itoa(inc,print,10);
HAL_UART_Transmit(&huart1, (uint8_t *) Message, strlen(Message), HAL_MAX_DELAY);
HAL_UART_Transmit(&huart1, (uint8_t *) print, strlen(print), HAL_MAX_DELAY);
HAL_UART_Transmit(&huart1, (uint8_t *) newLine, strlen(newLine), HAL_MAX_DELAY);
HAL_Delay(1000);
inc++;
if(screenState == 1){
screenClear();
screenState = 0;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 9600;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USART_TX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(USART_TX_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(USART_RX_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
uint8_t count = 0;
HAL_Init();
SystemClock_Config();
SystemCoreClock = HAL_RCC_GetHCLKFreq();
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
if(TFT_ShieldDetect() == SHIELD_DETECTED)
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_LCD_Init();
Display_DemoDescription();
while (1)
BSP_LED_Toggle(LED2);
HAL_Delay(100);
if(BSP_PB_GetState(BUTTON_USER) != RESET)
HAL_Delay(10);
while (BSP_PB_GetState(BUTTON_USER) != RESET);
BSP_examples[DemoIndex++].DemoFunc();
if(DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples))
DemoIndex = 0;
Display_DemoDescription();
else
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
while (BSP_PB_GetState(BUTTON_USER) != KEY_PRESSED)
BSP_LED_Toggle(LED2);
HAL_Delay(200);
while (BSP_PB_GetState(BUTTON_USER) != KEY_NOT_PRESSED)
{}
BSP_LED_Off(LED3);
while (1)
if(UserButtonPressed==0x01)
count++;
LedToggleDelay += 20*count;
UserButtonPressed = 0x00;
if(LedToggleDelay>500)
LedToggleDelay = 20;
count = 0;
BSP_LED_Toggle(LED1);
HAL_Delay(LedToggleDelay);
BSP_LED_Toggle(LED2);
HAL_Delay(LedToggleDelay);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 350;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
static void Display_DemoDescription(void)
uint8_t desc[50];
BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
BSP_LCD_Clear(LCD_COLOR_WHITE);
BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
BSP_LCD_DisplayStringAt(0, 10, (uint8_t *)"STM32F429ZI BSP", CENTER_MODE);
BSP_LCD_DisplayStringAt(0, 25, (uint8_t *)"Drivers examples", CENTER_MODE);
BSP_LCD_DrawBitmap((BSP_LCD_GetXSize() - 80)/2, 35, (uint8_t *)stlogo);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()- 15, (uint8_t *)"Copyright (c) STM 2015", CENTER_MODE);
BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
BSP_LCD_FillRect(0, BSP_LCD_GetYSize()/2 + 15, BSP_LCD_GetXSize(), 40);
BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()/2 + 25, (uint8_t *)"Use User Button to start", CENTER_MODE);
sprintf((char *)desc,"%s example", BSP_examples[DemoIndex].DemoName);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()/2 + 40, (uint8_t *)desc, CENTER_MODE);
uint8_t CheckForUserInput(void)
if(BSP_PB_GetState(BUTTON_USER) != RESET)
HAL_Delay(10);
while (BSP_PB_GetState(BUTTON_USER) != RESET);
return 1 ;
return 0;
static ShieldStatus TFT_ShieldDetect(void)
GPIO_InitTypeDef  GPIO_InitStruct;
NUCLEO_ADCx_GPIO_CLK_ENABLE();
GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN ;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT , &GPIO_InitStruct);
if(HAL_GPIO_ReadPin(NUCLEO_ADCx_GPIO_PORT , NUCLEO_ADCx_GPIO_PIN) != 0)
return SHIELD_DETECTED;
else
return SHIELD_NOT_DETECTED;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin==USER_BUTTON_PIN)
UserButtonPressed = 0x01;
void Error_Handler(void)
while(1)
BSP_LED_On(LED2);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USB_DEVICE_Init();
MX_SPI1_Init();
HAL_GPIO_WritePin(SPI1_WP_GPIO_Port, SPI1_WP_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(SPI1_RST_GPIO_Port, SPI1_RST_Pin, GPIO_PIN_SET);
W25qxx_Init();
while (1)
if(has_data()){
ProcessByte(get_data());
increase_counter();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;
PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI;
PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
PeriphClkInit.PLLSAI1.PLLSAI1N = 24;
PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_2|SPI1_WP_Pin|SPI1_CS_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(SPI1_RST_GPIO_Port, SPI1_RST_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_2|SPI1_WP_Pin|SPI1_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SPI1_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(SPI1_RST_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
SystemPower_Config();
while (1)
HAL_Delay(5000);
BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
SystemClock_Config();
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct ={0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
__HAL_RCC_PWR_CLK_DISABLE();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLState    = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLMUL      = RCC_PLL_MUL8;
RCC_OscInitStruct.PLL.PLLDIV      = RCC_PLL_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1)!= HAL_OK)
while(1);
static void SystemPower_Config(void)
GPIO_InitTypeDef GPIO_InitStructure;
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWREx_EnableUltraLowPower();
HAL_PWREx_EnableFastWakeUp();
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG (RCC_STOP_WAKEUPCLOCK_MSI);
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOE_CLK_ENABLE();
GPIO_InitStructure.Pin = GPIO_PIN_All;
GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
GPIO_InitStructure.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
HAL_GPIO_Init(GPIOH, &GPIO_InitStructure);
HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
__HAL_RCC_GPIOA_CLK_DISABLE();
__HAL_RCC_GPIOB_CLK_DISABLE();
__HAL_RCC_GPIOC_CLK_DISABLE();
__HAL_RCC_GPIOD_CLK_DISABLE();
__HAL_RCC_GPIOH_CLK_DISABLE();
__HAL_RCC_GPIOE_CLK_DISABLE();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
__HAL_PWR_CLEAR_FLAG(PWR_FLAG_WU);
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
uint8_t *frame_buffer = (uint8_t *) calloc(8192, sizeof(uint8_t));
delay_initialize();
ssd1322_initialize();
ssd1322_fill_ram(0x00);
if (frame_buffer != NULL)
ssd1322_fill_fb(frame_buffer, 0xFF);
ssd1322_display_fb(frame_buffer);
delay_ms(40000);
ssd1322_fill_fb(frame_buffer, 0x00);
ssd1322_display_fb(frame_buffer);
ssd1322_put_rectangle_fb(frame_buffer, 0, 0, 127, 63);
ssd1322_put_rectangle_fb(frame_buffer, 10, 10, 117, 53);
ssd1322_display_fb(frame_buffer);
delay_ms(20000);
ssd1322_fill_fb(frame_buffer, 0x00);
ssd1322_put_bitmap_fb(frame_buffer, 0,  0, (const bitmap_t *) &einstein_0);
ssd1322_put_bitmap_fb(frame_buffer, 33, 0, (const bitmap_t *) &einstein_1);
ssd1322_put_bitmap_fb(frame_buffer, 60, 0, (const bitmap_t *) &einstein_2);
ssd1322_put_bitmap_fb(frame_buffer, 91, 0, (const bitmap_t *) &einstein_3);
ssd1322_display_fb(frame_buffer);
delay_ms(20000);
ssd1322_set_font((const font_t *) &PTM55FT);
ssd1322_fill_fb(frame_buffer, 0x00);
ssd1322_put_string_fb(frame_buffer, 0, 0,  "SSD1322 OLED Fun:");
ssd1322_put_string_fb(frame_buffer, 0, 32, "Part Two");
ssd1322_display_fb(frame_buffer);
delay_ms(20000);
ssd1322_fill_fb(frame_buffer, 0x00);
ssd1322_put_bitmap_fb(frame_buffer, 34, 0, (const bitmap_t *) &CN);
ssd1322_display_fb(frame_buffer);
while (1)
void Error_Handler(void)
while (1);
int main(void)
HAL_Init();
Stm32_Clock_Init(RCC_PLL_MUL9);
delay_init(72);
LED_Init();
BEEP_Init();
while(1)
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
delay_ms(300);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
delay_ms(300);
int main(void)
uint32_t timeToBlink = 0;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
while (1)
if(HAL_GetTick() >= timeToBlink){
HAL_GPIO_TogglePin(LD4_GPIO_Port, LD4_Pin);
timeToBlink = HAL_GetTick() + BLINK_TIME_MS;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
void SystemInit(void)
SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));
RCC->CR |= (uint32_t)0x00000001;
RCC->CFGR = 0x00000000;
RCC->CR &= (uint32_t)0xFEF6FFFF;
RCC->PLLCFGR = 0x24003010;
RCC->CR &= (uint32_t)0xFFFBFFFF;
RCC->CIR = 0x00000000;
__HAL_RCC_PWR_CLK_ENABLE();
SystemInit_ExtMemCtl();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.OscillatorType    = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState          = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue  = 16;
RCC_OscInitStruct.PLL.PLLState      = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource     = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM          = 16;
RCC_OscInitStruct.PLL.PLLN          = 432;
RCC_OscInitStruct.PLL.PLLP          = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ          = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if (ret != HAL_OK) {
while (1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if (ret != HAL_OK) {
while (1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if (ret != HAL_OK) {
while (1) { ; }
void stm32_rng_init(void)
RNG_HandleTypeDef rng_handle = { 0 };
__HAL_RCC_RNG_CLK_ENABLE();
rng_handle.Instance = RNG;
HAL_StatusTypeDef status = HAL_RNG_Init(&rng_handle);
if (status != HAL_OK) {
panic("error initializing random number hardware\\n");
uint32_t r;
status = HAL_RNG_GenerateRandomNumber(&rng_handle, &r);
if (status != HAL_OK) {
panic("error getting random number from hardware\\n");
status = HAL_RNG_GenerateRandomNumber(&rng_handle, &r);
if (status != HAL_OK) {
panic("error getting random number from hardware\\n");
srand(r);
void platform_early_init(void)
SystemInit();
SystemClock_Config();
__HAL_FLASH_ART_ENABLE();
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
stm32_unique_id[0] = *REG32(0x1ff0f420);
stm32_unique_id[1] = *REG32(0x1ff0f424);
stm32_unique_id[2] = *REG32(0x1ff0f428);
srand(stm32_unique_id[0] ^ stm32_unique_id[1] ^ stm32_unique_id[2]);
uint32_t sysclk = HAL_RCC_GetSysClockFreq();
arm_cm_systick_init(sysclk);
stm32_timer_early_init();
stm32_gpio_early_init();
stm32_flash_early_init();
stm32_rng_init();
RCC->CSR |= (1<<24);
void platform_init(void)
printf("clocks:\\n");
printf("\\tsysclk %u\\n", HAL_RCC_GetSysClockFreq());
printf("\\thclk %u\\n", HAL_RCC_GetHCLKFreq());
printf("\\tpclk1 %u\\n", HAL_RCC_GetPCLK1Freq());
printf("\\tpclk2 %u\\n", HAL_RCC_GetPCLK2Freq());
printf("unique id: 0x%08x%08x%08x\\n", stm32_unique_id[0], stm32_unique_id[1], stm32_unique_id[2]);
stm32_timer_init();
stm32_flash_init();
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
osKernelInitialize();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
RCC_OscInitStruct.PLL.PLLN = 85;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM17) {
HAL_IncTick();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI2_Init();
MX_TIM6_Init();
MX_USART1_UART_Init();
HAL_TIM_Base_Start_IT(&htim6);
bInit();
int fd;
uint32_t tick;
fd = bOpen(SUART, BCORE_FLAG_RW);
while (1)
if(fd >= 0)
if(bHalGetTick() - tick > (5 * _TICK_FRQ_HZ))
tick = bHalGetTick();
bWrite(fd, (uint8_t *)"hello world\\r\\n", strlen("hello world\\r\\n"));
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI2_Init(void)
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_MASTER;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_SOFT;
hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi2.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_TIM6_Init(void)
TIM_MasterConfigTypeDef sMasterConfig;
htim6.Instance = TIM6;
htim6.Init.Prescaler = 71;
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
htim6.Init.Period = 103;
htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(SUART_TX_GPIO_Port, SUART_TX_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(W25X_CS_GPIO_Port, W25X_CS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = SUART_TX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(SUART_TX_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SUART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(SUART_RX_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = W25X_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM;
HAL_GPIO_Init(W25X_CS_GPIO_Port, &GPIO_InitStruct);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if(htim == &htim6)
S_UartRxTimerHandler();
S_UartTxTimerHandler();
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
while (1)
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
HAL_Delay(100);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_CRC_Init();
MX_USART1_UART_Init();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM1) {
HAL_IncTick();
void Error_Handler(void)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
void user_pwm_setvalue(uint16_t value)
TIM_OC_InitTypeDef sConfigOC;
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = value;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM2_Init();
MX_TIM15_Init();
volatile uint16_t counter = 0;
uint16_t pwm_value = 0;
int16_t step = 0;
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim15, TIM_CHANNEL_1);
while (1)
if(current_state == RESET_OFF)
GPIOA->MODER |= GPIO_MODER_MODE5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE5_1;
GPIOA->MODER |= GPIO_MODER_MODE14_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_1;
GPIOA->ODR &= GPIO_ODR_OD5;
GPIOB->ODR &= GPIO_ODR_OD14;
else if(current_state == ON_SOLID)
GPIOA->MODER |= GPIO_MODER_MODE5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE5_1;
GPIOA->MODER |= GPIO_MODER_MODE14_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_1;
GPIOA->ODR |= GPIO_ODR_OD5;
GPIOB->ODR |= GPIO_ODR_OD14;
else if(current_state == BLINK_SLOW)
GPIOA->MODER |= GPIO_MODER_MODE5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE5_1;
GPIOA->MODER |= GPIO_MODER_MODE14_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_1;
GPIOA->ODR ^= GPIO_ODR_OD5;
GPIOB->ODR ^= GPIO_ODR_OD14;
else if(current_state == BLINK_FAST)
GPIOA->MODER |= GPIO_MODER_MODE5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE5_1;
GPIOA->MODER |= GPIO_MODER_MODE14_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_1;
GPIOA->ODR ^= ~GPIO_ODR_OD5;
GPIOB->ODR ^= ~GPIO_ODR_OD14;
HAL_Delay(100);
else if(current_state == DIM_SLOW)
GPIOA->MODER &= ~GPIO_MODER_MODE5_0;
GPIOA->MODER |= GPIO_MODER_MODE5_1;
GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL5_Msk;
GPIOA->AFR[0] |= GPIO_AFRL_AFSEL5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_0;
GPIOA->MODER |= GPIO_MODER_MODE14_1;
GPIOA->AFR[1] &= ~GPIO_AFRH_AFSEL14_Msk;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_1;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_2;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_3;
HAL_Delay(50);
if(pwm_value == 0) step = 100;
if(pwm_value == 2000) step = -100;
pwm_value += step;
user_pwm_setvalue(pwm_value);
else if(current_state == DIM_FAST)
GPIOA->MODER &= ~GPIO_MODER_MODE5_0;
GPIOA->MODER |= GPIO_MODER_MODE5_1;
GPIOA->AFR[0] &= ~GPIO_AFRL_AFSEL5_Msk;
GPIOA->AFR[0] |= GPIO_AFRL_AFSEL5_0;
GPIOA->MODER &= ~GPIO_MODER_MODE14_0;
GPIOA->MODER |= GPIO_MODER_MODE14_1;
GPIOA->AFR[1] &= ~GPIO_AFRH_AFSEL14_Msk;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_1;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_2;
GPIOA->AFR[1] |= GPIO_AFRH_AFSEL14_3;
HAL_Delay(25);
if(pwm_value == 0) step = 500;
if(pwm_value == 2000) step = -500;
pwm_value += step;
user_pwm_setvalue(pwm_value);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_TIM2_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
htim2.Instance = TIM2;
htim2.Init.Prescaler = 160-1;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 2000-1;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim2);
static void MX_TIM15_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
htim15.Instance = TIM15;
htim15.Init.Prescaler = 160-1;
htim15.Init.CounterMode = TIM_COUNTERMODE_UP;
htim15.Init.Period = 2000-1;
htim15.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim15.Init.RepetitionCounter = 0;
htim15.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim15) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim15, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim15) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim15, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&htim15, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
sBreakDeadTimeConfig.DeadTime = 0;
sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
if (HAL_TIMEx_ConfigBreakDeadTime(&htim15, &sBreakDeadTimeConfig) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim15);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM17) {
HAL_IncTick();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
void vApplicationStackOverflowHook(TaskHandle_t xTask, signed char *pcTaskName)
while(1);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI5_Init();
lcd_init();
lcd_draw_text_at_line("Synchrone         ", 0, BLACK, 2, WHITE);
lcd_draw_text_at_line("Programmierung in ", 1, BLACK, 2, WHITE);
lcd_draw_text_at_line("eingebetteten     ", 2, BLACK, 2, WHITE);
lcd_draw_text_at_line("Systemen SoSe 2020", 3, BLACK, 2, WHITE);
lcd_draw_text_at_line("            ", 3, WHITE, 3, BLACK);
lcd_draw_text_at_line("  TEMPLATE  ", 4, WHITE, 3, BLACK);
lcd_draw_text_at_line("            ", 5, WHITE, 3, BLACK);
osKernelInitialize();
defaultTaskHandle = osThreadNew(RunDefaultTask, NULL, &defaultTask_attributes);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_SPI5_Init(void)
hspi5.Instance = SPI5;
hspi5.Init.Mode = SPI_MODE_MASTER;
hspi5.Init.Direction = SPI_DIRECTION_2LINES;
hspi5.Init.DataSize = SPI_DATASIZE_8BIT;
hspi5.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi5.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi5.Init.NSS = SPI_NSS_SOFT;
hspi5.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi5.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi5.Init.TIMode = SPI_TIMODE_DISABLE;
hspi5.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi5.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi5) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
HAL_GPIO_WritePin(LCD_CS_GPIO_Port, LCD_CS_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LCD_DC_GPIO_Port, LCD_DC_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LCD_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LCD_CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LCD_DC_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LCD_DC_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_GREEN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GREEN_GPIO_Port, &GPIO_InitStruct);
void RunDefaultTask(void *argument)
blc_blech_control_init();
led_state = HAL_GPIO_ReadPin(LED_GREEN_GPIO_Port, LED_GREEN_Pin);
blc_blech_control_tick(&led_state);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, (led_state) ? GPIO_PIN_SET : GPIO_PIN_RESET);
for(;;)
osDelay(1000);
led_state = HAL_GPIO_ReadPin(LED_GREEN_GPIO_Port, LED_GREEN_Pin);
blc_blech_control_tick(&led_state);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, (led_state) ? GPIO_PIN_SET : GPIO_PIN_RESET);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM1) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void DBG_Init(void)
GPIO_InitTypeDef  gpioinitstruct = {0};
__HAL_RCC_GPIOB_CLK_ENABLE();
gpioinitstruct.Mode   = GPIO_MODE_OUTPUT_PP;
gpioinitstruct.Pull   = GPIO_PULLUP;
gpioinitstruct.Speed  = GPIO_SPEED_HIGH;
gpioinitstruct.Pin    = (GPIO_PIN_12 | GPIO_PIN_13| GPIO_PIN_14 | GPIO_PIN_15);
HAL_GPIO_Init(GPIOB, &gpioinitstruct);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);
__HAL_RCC_DBGMCU_CLK_ENABLE( );
HAL_DBGMCU_EnableDBGSleepMode( );
HAL_DBGMCU_EnableDBGStopMode( );
HAL_DBGMCU_EnableDBGStandbyMode( );
GPIO_InitTypeDef GPIO_InitStructure ={0};
GPIO_InitStructure.Mode   = GPIO_MODE_ANALOG;
GPIO_InitStructure.Pull   = GPIO_NOPULL;
GPIO_InitStructure.Pin    = (GPIO_PIN_13 | GPIO_PIN_14);
__GPIOA_CLK_ENABLE() ;
HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
__GPIOA_CLK_DISABLE() ;
__HAL_RCC_DBGMCU_CLK_ENABLE( );
HAL_DBGMCU_DisableDBGSleepMode( );
HAL_DBGMCU_DisableDBGStopMode( );
HAL_DBGMCU_DisableDBGStandbyMode( );
__HAL_RCC_DBGMCU_CLK_DISABLE( );
void Error_Handler(void)
DBG_PRINTF("Error_Handler\\n\\r");
while(1);
int main(void)
HAL_Init();
SystemClock_Config();
SECURE_RegisterCallback(SECURE_FAULT_CB_ID, (void *)SecureFault_Callback);
SECURE_RegisterCallback(GTZC_ERROR_CB_ID, (void *)SecureError_Callback);
MX_DMA_Init();
if (BSP_LED_Init(LED3) != BSP_ERROR_NONE)
Error_Handler();
if (BSP_LED_Init(LED1) != BSP_ERROR_NONE)
Error_Handler();
HAL_Delay(1000);
if (SECURE_HASH_SHA1_8BITS((uint8_t *)aInput, strlen((char const *)aInput), (uint8_t *)aSHA1Digest) == SUCCESS)
if (memcmp(aSHA1Digest, aExpectSHA1Digest, sizeof(aExpectSHA1Digest) / sizeof(aExpectSHA1Digest[0])) != 0)
BSP_LED_On(LED3);
else
BSP_LED_On(LED1);
else
Error_Handler();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMAMUX1_CLK_ENABLE();
__HAL_RCC_DMA2_CLK_ENABLE();
void SecureFault_Callback(void)
Error_Handler();
void SecureError_Callback(void)
Error_Handler();
void Error_Handler(void)
__disable_irq();
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_I2S3_Init();
MX_SPI1_Init();
MX_TIM6_Init();
HAL_TIM_Base_Start_IT(&htim6);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_I2S3_Init(void)
hi2s3.Instance = SPI3;
hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_ENABLE;
hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_96K;
hi2s3.Init.CPOL = I2S_CPOL_LOW;
hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_DISABLE;
if (HAL_I2S_Init(&hi2s3) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM6_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim6.Instance = TIM6;
htim6.Init.Prescaler = 637;
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
htim6.Init.Period = 65500;
htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(CS_I2C_SPI_GPIO_Port, CS_I2C_SPI_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(OTG_FS_PowerSwitchOn_GPIO_Port, OTG_FS_PowerSwitchOn_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = VBUS_FS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
trace_printf("Hello\\n");
RTC_TimeTypeDef Tim;
RTC_DateTypeDef Dat;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_LED_Init(LED4);
BSP_RTC_Init();
BSP_RTC_TimeStamp_Init(RTC_TIMESTAMPEDGE_RISING);
BSP_UART_Init(115200);
while (1)
__HAL_RTC_TIMESTAMP_CLEAR_FLAG(&hrtc_bsp,RTC_ISR_TSF);
HAL_RTC_GetTime(&hrtc_bsp,&Tim,FORMAT_BIN);
HAL_RTC_GetDate(&hrtc_bsp,&Dat,FORMAT_BIN);
Tim.SubSeconds = 1000 - ((hrtc_bsp.Instance->SSR*1000)/hrtc_bsp.Init.SynchPrediv);
uprintf("\\x1b[3;1H %d02 : %d02 : %d02 : %d04",Tim.Hours,Tim.Minutes,Tim.Seconds,Tim.SubSeconds);
uprintf("\\x1b[4;1H %d02 / %d02 / %d04", Dat.Date,Dat.Month,Dat.Year);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_HSE_DIV8;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc)
BSP_LED_Toggle(LED4);
void assert_failed(uint8_t* file, uint32_t line)
int main()
HAL_Init();
init_sysclk_216MHz();
init_random();
init_gpio(led1, OUTPUT);
init_gpio(led2, OUTPUT);
init_gpio(led3, OUTPUT);
init_gpio(led4, OUTPUT);
init_gpio(led5, OUTPUT);
init_gpio(led6, OUTPUT);
init_gpio(but1, INPUT);
leds_off();
while(1)
uint32_t rnd = (get_random_int() % 6) + 1;
leds_off();
switch (rnd)
case 1:
write_gpio(led1, HIGH);
break;
case 2:
write_gpio(led1, HIGH);
write_gpio(led2, HIGH);
break;
case 3:
write_gpio(led1, HIGH);
write_gpio(led2, HIGH);
write_gpio(led3, HIGH);
break;
case 4:
write_gpio(led1, HIGH);
write_gpio(led2, HIGH);
write_gpio(led3, HIGH);
write_gpio(led4, HIGH);
break;
case 5:
write_gpio(led1, HIGH);
write_gpio(led2, HIGH);
write_gpio(led3, HIGH);
write_gpio(led4, HIGH);
write_gpio(led5, HIGH);
break;
case 6:
write_gpio(led1, HIGH);
write_gpio(led2, HIGH);
write_gpio(led3, HIGH);
write_gpio(led4, HIGH);
write_gpio(led5, HIGH);
write_gpio(led6, HIGH);
break;
HAL_Delay(3000);
void leds_off (void)
write_gpio(led1, LOW);
write_gpio(led2, LOW);
write_gpio(led3, LOW);
write_gpio(led4, LOW);
write_gpio(led5, LOW);
write_gpio(led6, LOW);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_UART_Init(115200);
ASK25_LED_Init(ALEDALL);
ASK25_LED_Off(ALEDALL);
trace_printf("Hello\\n");
while (1)
ASK25_LED_Toggle(ALEDALL);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 210;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM2_Init();
MX_TIM5_Init();
MX_DAC_Init();
uint32_t BpM = 120;
Q_Duration = 60000/BpM;
H_Duration = 2*60000/BpM;
while (1)
play_note(C4,Q_Duration);
play_note(C4,Q_Duration);
play_note(G4,Q_Duration);
play_note(G4,Q_Duration);
play_note(A4,Q_Duration);
play_note(A4,Q_Duration);
play_note(G4,H_Duration);
play_note(F4,Q_Duration);
play_note(F4,Q_Duration);
play_note(E4,Q_Duration);
play_note(E4,Q_Duration);
play_note(D4,Q_Duration);
play_note(D4,Q_Duration);
play_note(C4,H_Duration);
play_note(G4,Q_Duration);
play_note(G4,Q_Duration);
play_note(F4,Q_Duration);
play_note(F4,Q_Duration);
play_note(E4,Q_Duration);
play_note(E4,Q_Duration);
play_note(D4,H_Duration);
play_note(G4,Q_Duration);
play_note(G4,Q_Duration);
play_note(F4,Q_Duration);
play_note(F4,Q_Duration);
play_note(E4,Q_Duration);
play_note(E4,Q_Duration);
play_note(D4,H_Duration);
play_note(C4,Q_Duration);
play_note(C4,Q_Duration);
play_note(G4,Q_Duration);
play_note(G4,Q_Duration);
play_note(A4,Q_Duration);
play_note(A4,Q_Duration);
play_note(G4,H_Duration);
play_note(F4,Q_Duration);
play_note(F4,Q_Duration);
play_note(E4,Q_Duration);
play_note(E4,Q_Duration);
play_note(D4,Q_Duration);
play_note(D4,Q_Duration);
play_note(C4,H_Duration);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void play_note(int note_freq,uint32_t note_duration)
if(note_freq==C4)
HAL_GPIO_WritePin(GPIOA,ledC4_Pin,GPIO_PIN_SET);
if(note_freq==G4)
HAL_GPIO_WritePin(GPIOC,ledG4_Pin,GPIO_PIN_SET);
if(note_freq==D4)
HAL_GPIO_WritePin(GPIOA,ledD4_Pin,GPIO_PIN_SET);
if(note_freq==A4)
HAL_GPIO_WritePin(GPIOC,ledA4_Pin,GPIO_PIN_SET);
if(note_freq==E4)
HAL_GPIO_WritePin(GPIOA,ledE4_Pin,GPIO_PIN_SET);
if(note_freq==F4)
HAL_GPIO_WritePin(GPIOA,ledF4_Pin,GPIO_PIN_SET);
Note_Flag =0;
Sine_Index = 0;
uint32_t Time_Comparator2 = (uint32_t) 84000000/(note_freq*N);
uint32_t Time_Comparator5 = (uint32_t) (84000000  / 1000) * note_duration ;
HAL_TIM_OC_Start_IT(&htim2,TIM_CHANNEL_2);
HAL_TIM_OC_Start_IT(&htim5,TIM_CHANNEL_1);
__HAL_TIM_SET_COMPARE(&htim2,TIM_CHANNEL_2,Time_Comparator2);
__HAL_TIM_SET_COMPARE(&htim5,TIM_CHANNEL_1,Time_Comparator5);
__HAL_TIM_SET_COUNTER(&htim2,0);
__HAL_TIM_SET_COUNTER(&htim5,0);
HAL_DAC_Start(&hdac,DAC_CHANNEL_1);
while(Note_Flag==0)
if(Dac_Flag==1)
HAL_DAC_SetValue(&hdac,DAC_CHANNEL_1,DAC_ALIGN_12B_R,SINE_WAVE[Sine_Index]);
__HAL_TIM_SET_COUNTER(&htim2,0);
Sine_Index++;
if(Sine_Index==N)
Sine_Index = 0;
Dac_Flag = 0;
__HAL_TIM_SetCounter(&htim5,0);
HAL_TIM_OC_Stop_IT(&htim2,TIM_CHANNEL_2);
HAL_TIM_OC_Stop_IT(&htim5,TIM_CHANNEL_1);
HAL_DAC_Stop(&hdac,DAC_CHANNEL_1);
if(note_freq==C4)
HAL_GPIO_WritePin(GPIOA,ledC4_Pin,GPIO_PIN_RESET);
if(note_freq==G4)
HAL_GPIO_WritePin(GPIOC,ledG4_Pin,GPIO_PIN_RESET);
if(note_freq==D4)
HAL_GPIO_WritePin(GPIOA,ledD4_Pin,GPIO_PIN_RESET);
if(note_freq==A4)
HAL_GPIO_WritePin(GPIOC,ledA4_Pin,GPIO_PIN_RESET);
if(note_freq==E4)
HAL_GPIO_WritePin(GPIOA,ledE4_Pin,GPIO_PIN_RESET);
if(note_freq==F4)
HAL_GPIO_WritePin(GPIOA,ledF4_Pin,GPIO_PIN_RESET);
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2)
Dac_Flag = 1;
else if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
Note_Flag = 1;
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main (void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_CRC_Init();
MX_USART2_UART_Init();
MX_TIM2_Init();
ndebug_printf("FreeRTOS Modification.\\n");
example_run();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config (void)
RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
__HAL_RCC_PWR_CLK_ENABLE()
;
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig( &RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
| RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void HAL_TIM_PeriodElapsedCallback (TIM_HandleTypeDef *htim)
if (htim->Instance == TIM14)
HAL_IncTick();
void Error_Handler (void)
void assert_failed (uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM6_Init();
MX_USART2_UART_Init();
HAL_TIM_Base_Start_IT(&htim6);
unsigned char first_msg[] = "\\r\\n--- Raspberry / STM32 Communication ---\\r\\n";
HAL_UART_Transmit(&huart2, first_msg, sizeof(first_msg), 1000);
while (1)
if (HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET) {
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_14);
do {
HAL_Delay(200);
} while(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_0) == GPIO_PIN_SET);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
unsigned char init[] = "TR";
unsigned char start[] = "AA";
unsigned char end[] = "ZZ";
int data = 0x555555;
uint8_t bytesDataLen = sizeof(data);
uint8_t filter = 0xFF;
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_15);
HAL_UART_Transmit(&huart2, init, sizeof(init), 100);
HAL_UART_Transmit(&huart2, start, sizeof(start), 1000);
data &= filter;
char buffer[10];
sprintf(buffer, "%04d", data);
HAL_UART_Transmit(&huart2, (uint8_t*)buffer, 15, 100);
HAL_UART_Transmit(&huart2, end, sizeof(end), 1000);
HAL_UART_Transmit(&huart2, (uint8_t*)"\\n", 1, 1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 50;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_TIM6_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim6.Instance = TIM6;
htim6.Init.Prescaler = 100;
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
htim6.Init.Period = 64000 - 1;
htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim6, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_0;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
bool uartInit(void)
uint8_t i;
for (i=0; i<UART_MAX_CH; i++)
uart_tbl[i].is_open  = false;
uart_tbl[i].rx_mode  = UART_MODE_POLLING;
uart_tbl[i].tx_mode  = UART_MODE_POLLING;
uart_tbl[i].tx_done  = false;
uart_tbl[i].txDoneISR = NULL;
uart_tbl[i].err_cnt  = 0;
uart_tbl[i].hw_driver = UART_HW_NONE;
return true;
bool uartOpen(uint8_t channel, uint32_t baud)
bool ret = false;
uart_t *p_uart;
if (channel >= UART_MAX_CH)
return false;
switch(channel)
case _DEF_UART1:
p_uart = &uart_tbl[channel];
p_uart->baud      = baud;
p_uart->hw_driver = UART_HW_STM32_UART;
p_uart->rx_mode   = UART_MODE_DMA;
p_uart->tx_mode   = UART_MODE_POLLING;
p_uart->hdma_rx = &hdma_usart2_rx;
p_uart->handle =  &huart2;
p_uart->handle->Instance = USART2;
p_uart->handle->Init.BaudRate     = baud;
p_uart->handle->Init.WordLength   = UART_WORDLENGTH_8B;
p_uart->handle->Init.StopBits     = UART_STOPBITS_1;
p_uart->handle->Init.Parity       = UART_PARITY_NONE;
p_uart->handle->Init.Mode         = UART_MODE_TX_RX;
p_uart->handle->Init.HwFlowCtl    = UART_HWCONTROL_NONE;
p_uart->handle->Init.OverSampling = UART_OVERSAMPLING_16;
p_uart->handle->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
p_uart->handle->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
qbufferCreate(&p_uart->qbuffer_rx, p_uart->rx_buf, UART_RX_BUF_LENGTH);
HAL_UART_DeInit(p_uart->handle);
HAL_UART_Init(p_uart->handle);
p_uart->is_open  = true;
uartStartRx(channel);
ret = true;
break;
return ret;
void uartSetTxDoneISR(uint8_t channel, void (*func)(void))
uart_tbl[channel].txDoneISR = func;
void uartStartRx(uint8_t channel)
uart_t *p_uart = &uart_tbl[channel];
if (p_uart->rx_mode == UART_MODE_INTERRUPT)
HAL_UART_Receive_IT(p_uart->handle, p_uart->rx_buf, 1);
if (p_uart->rx_mode == UART_MODE_DMA)
HAL_UART_Receive_DMA(p_uart->handle, (uint8_t *)p_uart->qbuffer_rx.p_buf, p_uart->qbuffer_rx.length);
bool uartClose(uint8_t channel)
bool ret = false;
if (channel >= UART_MAX_CH)
return false;
if (uart_tbl[channel].is_open == true && uart_tbl[channel].hw_driver == UART_HW_STM32_UART)
if(HAL_UART_DeInit(uart_tbl[channel].handle) == HAL_OK)
ret = true;
return ret;
uint32_t uartAvailable(uint8_t channel)
uint32_t ret;
uart_t *p_uart = &uart_tbl[channel];
if (channel >= UART_MAX_CH)
return 0;
if (p_uart->rx_mode == UART_MODE_VCP)
ret = vcpAvailable();
if (p_uart->rx_mode == UART_MODE_INTERRUPT)
ret = qbufferAvailable(&uart_tbl[channel].qbuffer_rx);
if (p_uart->rx_mode == UART_MODE_DMA)
p_uart->qbuffer_rx.ptr_in = p_uart->qbuffer_rx.length - ((DMA_Channel_TypeDef *)p_uart->hdma_rx->Instance)->CNDTR;
ret = qbufferAvailable(&p_uart->qbuffer_rx);
return ret;
void uartFlush(uint8_t channel)
if (uart_tbl[channel].rx_mode == UART_MODE_VCP)
vcpFlush();
if (uart_tbl[channel].rx_mode == UART_MODE_INTERRUPT)
qbufferFlush(&uart_tbl[channel].qbuffer_rx);
if (uart_tbl[channel].rx_mode == UART_MODE_DMA)
uart_tbl[channel].qbuffer_rx.ptr_in  = uart_tbl[channel].qbuffer_rx.length - ((DMA_Channel_TypeDef *)uart_tbl[channel].hdma_rx->Instance)->CNDTR;
uart_tbl[channel].qbuffer_rx.ptr_out = uart_tbl[channel].qbuffer_rx.ptr_in;
void uartPutch(uint8_t channel, uint8_t ch)
uartWrite(channel, &ch, 1 );
uint8_t uartGetch(uint8_t channel)
uint8_t ret = 0;
while(1)
if (uartAvailable(channel) > 0)
ret = uartRead(channel);
break;
return ret;
int32_t uartWrite(uint8_t channel, uint8_t *p_data, uint32_t length)
int32_t ret = 0;
uart_t *p_uart = &uart_tbl[channel];
if (p_uart->tx_mode == UART_MODE_VCP)
vcpWrite(p_data, length);
if (p_uart->tx_mode == UART_MODE_POLLING)
if (HAL_UART_Transmit(p_uart->handle, (uint8_t*)p_data, length, 1000) == HAL_OK)
ret = length;
if (p_uart->tx_mode == UART_MODE_DMA)
p_uart->handle->gState = HAL_UART_STATE_READY;
HAL_DMA_PollForTransfer(p_uart->hdma_tx, HAL_DMA_FULL_TRANSFER, 100);
if (HAL_UART_Transmit_DMA(p_uart->handle, p_data, length) == HAL_OK)
ret = length;
return ret;
uint8_t uartRead(uint8_t channel)
uint8_t ret = 0;
uart_t *p_uart = &uart_tbl[channel];
if (p_uart->rx_mode == UART_MODE_VCP)
ret = vcpRead();
if (p_uart->rx_mode == UART_MODE_INTERRUPT)
qbufferRead(&p_uart->qbuffer_rx, &ret, 1);
if (p_uart->rx_mode == UART_MODE_DMA)
qbufferRead(&p_uart->qbuffer_rx, &ret, 1);
return ret;
bool uartSendBreak(uint8_t channel)
HAL_LIN_SendBreak(uart_tbl[channel].handle);
return true;
bool uartSendBreakEnd(uint8_t channel)
return true;
int32_t uartPrintf(uint8_t channel, const char *fmt, ...)
int32_t ret = 0;
va_list arg;
va_start (arg, fmt);
int32_t len;
char print_buffer[256];
len = vsnprintf(print_buffer, 255, fmt, arg);
va_end (arg);
ret = uartWrite(channel, (uint8_t *)print_buffer, len);
return ret;
void uartRxHandler(uint8_t channel)
uart_t *p_uart = &uart_tbl[channel];
if(p_uart->rx_mode == UART_MODE_INTERRUPT)
qbufferWrite(&p_uart->qbuffer_rx, &p_uart->rx_buf[0], 1);
__HAL_UNLOCK(p_uart->handle);
uartStartRx(channel);
void uartErrHandler(uint8_t channel)
uartStartRx(channel);
uartFlush(channel);
uart_tbl[channel].err_cnt++;
uint32_t uartGetErrCnt(uint8_t channel)
return uart_tbl[channel].err_cnt;
void uartResetErrCnt(uint8_t channel)
uartStartRx(channel);
uartFlush(channel);
uart_tbl[channel].err_cnt = 0;
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle)
void HAL_UART_ErrorCallback(UART_HandleTypeDef *UartHandle)
if (UartHandle->Instance == uart_tbl[_DEF_UART1].handle->Instance)
uartErrHandler(_DEF_UART1);
if (UartHandle->Instance == uart_tbl[_DEF_UART3].handle->Instance)
uartErrHandler(_DEF_UART3);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
if (huart->Instance == uart_tbl[_DEF_UART1].handle->Instance)
uartRxHandler(_DEF_UART1);
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
GPIO_InitTypeDef GPIO_InitStruct = {0};
if(uartHandle->Instance==USART2)
uart_t *p_uart = &uart_tbl[_DEF_UART1];
__HAL_RCC_USART2_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF3_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
if (p_uart->rx_mode == UART_MODE_DMA)
__HAL_RCC_DMA1_CLK_ENABLE();
hdma_usart2_rx.Instance = DMA1_Channel6;
hdma_usart2_rx.Init.Request = DMA_REQUEST_2;
hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW;
if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
Error_Handler();
__HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx);
void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
if(uartHandle->Instance==USART2)
__HAL_RCC_USART2_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_15);
HAL_DMA_DeInit(uartHandle->hdmarx);
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
*ppxIdleTaskTCBBuffer = &xIdleTaskTCBBuffer;
*ppxIdleTaskStackBuffer = &xIdleStack[0];
*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
void sendTaskFunc(void const * argument)
TickType_t xLastWakeTime=xTaskGetTickCount();;
TickType_t sendTaskPeriod=pdMS_TO_TICKS(1);
CONTROLLER_TYPE *ptController = ptCentral->ptControlHub->ptController[0];
for(;;)
if(start_transmission){
printf("%.3f %1.6f %2.4f %3.3f  %6.0f %6.0f %2.3f %2.3f %2.3f  %2.4f %2.4f\\r\\n",
HAL_GetTick()/1000.0f,
ptCentral->ptSensorData->angle[0],
ptCentral->ptSensorData->velocity[0],
ptCentral->ptSensorData->acceleration[0],
ptCentral->ptSensorData->pressure[0][0],
ptCentral->ptSensorData->pressure[0][1],
ptCentral->ptSensorData->stiffness[0],
ptCentral->ptNominalData->stiffness[0],
ptController->pid.Kp,
ptCentral->ptSensorData->torque[0],
ptCentral->ptSensorData->force[0]
);
vTaskDelayUntil(&xLastWakeTime,sendTaskPeriod);
void EthPacketTaskFunc(void const * argument)
TickType_t xLastWakeTime=xTaskGetTickCount();
TickType_t EthPacketTaskPeriod=pdMS_TO_TICKS(10);
int32_t lRet;
lRet = Protocol_SendFirstPacket(&tAppData);
int32_t c1,c2;
for(;;)
while(tAppData.fRunning && lRet == CIFX_NO_ERROR){
c1=TIC();
lRet = EthercatPacketEventHandler();
Usart_TerminalHandler();
c2=TIC();
ptCentral->process_time.terminalTaskTime = c2-c1;
vTaskDelayUntil(&xLastWakeTime,EthPacketTaskPeriod);
Ethercat_DeInit();
void EthCyclicTaskFunc(void const * argument)
TickType_t xLastWakeTime=xTaskGetTickCount();
TickType_t EthCyclicTaskPeriod=pdMS_TO_TICKS(1);
int32_t c1,c2;
int32_t c3=0;
int32_t c4=0;
for(;;)
c1 = TIC();
ptCentral->updateData(ptCentral);
c2 = TIC();
if(ptCentral->gogogo){
ptCentral->ptControlHub->control(ptCentral->ptControlHub,0);
c3 = TIC();
ptCentral->ptActuatorHub->moveJoint(ptCentral->ptActuatorHub,0);
c4 = TIC();
ptCentral->process_time.controlTaskTime = c4-c1;
vTaskDelayUntil(&xLastWakeTime,EthCyclicTaskPeriod);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
SpiHandle.Instance               = SPIx;
SpiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
SpiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
SpiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;
SpiHandle.Init.CLKPolarity       = SPI_POLARITY_LOW;
SpiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
SpiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
SpiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;
SpiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
SpiHandle.Init.CRCPolynomial     = 7;
SpiHandle.Init.NSS               = SPI_NSS_SOFT;
SpiHandle.Init.Mode = SPI_MODE_MASTER;
SpiHandle.Init.Mode = SPI_MODE_SLAVE;
if(HAL_SPI_Init(&SpiHandle) != HAL_OK)
Error_Handler();
BSP_PB_Init(BUTTON_WAKEUP,BUTTON_MODE_GPIO);
while (BSP_PB_GetState(BUTTON_WAKEUP) == GPIO_PIN_RESET)
BSP_LED_Toggle(LED1);
HAL_Delay(100);
BSP_LED_Off(LED1);
if(HAL_SPI_TransmitReceive_IT(&SpiHandle, (uint8_t*)aTxBuffer, (uint8_t *)aRxBuffer, BUFFERSIZE) != HAL_OK)
Error_Handler();
while (wTransferState == TRANSFER_WAIT)
switch(wTransferState)
case TRANSFER_COMPLETE :
if(Buffercmp((uint8_t*)aTxBuffer, (uint8_t*)aRxBuffer, BUFFERSIZE))
Error_Handler();
break;
default :
Error_Handler();
break;
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
BSP_LED_On(LED1);
BSP_LED_On(LED2);
wTransferState = TRANSFER_COMPLETE;
void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
wTransferState = TRANSFER_ERROR;
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static uint16_t Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength)
while (BufferLength--)
if ((*pBuffer1) != *pBuffer2)
return BufferLength;
pBuffer1++;
pBuffer2++;
return 0;
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void atio_irq(void)
unsigned char  value;
unsigned short ringspace;
if(__HAL_UART_GET_FLAG(&uart_at, UART_FLAG_RXNE) != RESET)
value = (uint8_t)(uart_at.Instance->DR & 0x00FF);
g_atio_cb.rcvlen++;
if(g_atio_cb.w_next < CN_RCVBUF_LEN)
g_atio_cb.rcvbuf[g_atio_cb.w_next] = value;
g_atio_cb.w_next++;
else
g_atio_cb.rframeover++;
else if (__HAL_UART_GET_FLAG(&uart_at,UART_FLAG_IDLE) != RESET)
__HAL_UART_CLEAR_IDLEFLAG(&uart_at);
ringspace = CN_RCVMEM_LEN - ring_buffer_datalen(&g_atio_cb.rcvring);
if(ringspace < g_atio_cb.w_next)
g_atio_cb.rframedrop++;
else
ringspace = g_atio_cb.w_next;
ring_buffer_write(&g_atio_cb.rcvring,(unsigned char *)&ringspace,sizeof(ringspace));
ring_buffer_write(&g_atio_cb.rcvring,g_atio_cb.rcvbuf,ringspace);
osal_semp_post(g_atio_cb.rcvsync);
g_atio_cb.rcvframe++;
g_atio_cb.w_next=0;
bool_t uart_at_init(int baud)
memset(&g_atio_cb,0,sizeof(g_atio_cb));
if(false == osal_semp_create(&g_atio_cb.rcvsync,CN_RCVMEM_LEN,0))
printf("%s:semp create error\\n\\r",__FUNCTION__);
goto EXIT_SEMP;
ring_buffer_init(&g_atio_cb.rcvring,g_atio_cb.rcvringmem,CN_RCVMEM_LEN,0,0);
uart_at.Instance = s_pUSART;
uart_at.Init.BaudRate = baud;
uart_at.Init.WordLength = UART_WORDLENGTH_8B;
uart_at.Init.StopBits = UART_STOPBITS_1;
uart_at.Init.Parity = UART_PARITY_NONE;
uart_at.Init.HwFlowCtl = UART_HWCONTROL_NONE;
uart_at.Init.Mode = UART_MODE_TX_RX;
uart_at.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_Init(&uart_at) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
__HAL_UART_CLEAR_FLAG(&uart_at,UART_FLAG_TC);
LOS_HwiCreate(s_uwIRQn, 3, 0, atio_irq, 0);
__HAL_UART_ENABLE_IT(&uart_at, UART_IT_IDLE);
__HAL_UART_ENABLE_IT(&uart_at, UART_IT_RXNE);
return true;
EXIT_SEMP:
return false;
void uartat_deinit(void)
__HAL_UART_DISABLE(&uart_at);
__HAL_UART_DISABLE_IT(&uart_at, UART_IT_IDLE);
__HAL_UART_DISABLE_IT(&uart_at, UART_IT_RXNE);
static ssize_t uart_at_send(const void *buf, size_t len,uint32_t timeout)
HAL_UART_Transmit(&uart_at,(unsigned char *)buf,len,timeout);
g_atio_cb.sndlen += len;
g_atio_cb.sndframe ++;
return len;
static ssize_t uart_at_receive(void *buf,size_t len, uint32_t timeout)
unsigned short cpylen;
unsigned short framelen;
unsigned short readlen;
int32_t ret = 0;
unsigned int lock;
if(osal_semp_pend(g_atio_cb.rcvsync,timeout))
lock = LOS_IntLock();
readlen = sizeof(framelen);
cpylen = ring_buffer_read(&g_atio_cb.rcvring,(unsigned char *)&framelen,readlen);
if(cpylen != readlen)
ring_buffer_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
if(framelen > len)
ring_buffer_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
readlen = framelen;
cpylen = ring_buffer_read(&g_atio_cb.rcvring,(unsigned char *)buf,readlen);
if(cpylen != framelen)
ring_buffer_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
ret = cpylen;
LOS_IntRestore(lock);
return ret;
static ssize_t  __at_read  (void *pri,size_t offset,void *buf,size_t len,uint32_t timeout)
return uart_at_receive(buf,len, timeout);
static ssize_t  __at_write (void *pri,size_t offset, const void *buf,size_t len,uint32_t timeout)
return uart_at_send(buf, len, timeout);
static void Blink(int count)
int i;
for(i=0; i<count; i++)
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_Delay(50);
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
HAL_Delay(200);
HAL_Delay(500);
void tfp_putchar(char data)
HAL_USART_Transmit(&g_usart, (uint8_t*)&data, sizeof(data), HAL_MAX_DELAY);
static void init_clocks(void)
static const RCC_OscInitTypeDef rcc_osc_init = {
RCC_OSCILLATORTYPE_HSE,
RCC_HSE_ON,
RCC_HSE_PREDIV_DIV1,
0,0,0,0,
RCC_PLL_ON,
RCC_PLLSOURCE_HSE,
RCC_PLL_MUL9
};
static const RCC_ClkInitTypeDef rcc_clk_init = {
(RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2),
RCC_SYSCLKSOURCE_PLLCLK,
RCC_SYSCLK_DIV1,
RCC_HCLK_DIV2,
RCC_HCLK_DIV1,
};
HAL_RCC_OscConfig((RCC_OscInitTypeDef*)&rcc_osc_init);
HAL_RCC_ClockConfig((RCC_ClkInitTypeDef*)&rcc_clk_init, FLASH_LATENCY_2);
__HAL_RCC_PWR_CLK_ENABLE();
SystemCoreClockUpdate();
static void init(void)
int i;
static const USART_InitTypeDef usart_init = {
115200*2,
USART_WORDLENGTH_8B,
USART_STOPBITS_1,
USART_PARITY_NONE,
USART_MODE_TX_RX,
USART_POLARITY_LOW,
USART_PHASE_1EDGE,
USART_LASTBIT_ENABLE
};
init_clocks();
__HAL_RCC_AFIO_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
for(i=0;i<GPIO_INIT_COUNT;i++)
HAL_GPIO_Init(g_gpio_init[i].gpio, (GPIO_InitTypeDef*)&g_gpio_init[i].pin);
__HAL_RCC_USART1_FORCE_RESET( );
__HAL_RCC_USART1_RELEASE_RESET( );
__HAL_RCC_USART1_CLK_ENABLE();
g_usart.Instance = USART1;
g_usart.Init = usart_init;
HAL_USART_Init(&g_usart);
void main_entry(void)
uint32_t counter;
init();
counter = 0;
while(1)
Blink(3);
tfp_printf("%08u: Hello world (@%uMHz)!\\n\\r",counter++,SystemCoreClock/1000000);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
MPU_Config();
MPU_AccessPermConfig();
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV1;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
while(1);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
char desc[50];
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
LCD_Config();
ADC_Config();
HAL_ADC_Start_DMA(&AdcHandle, (uint32_t*)&ConvertedValue, 1);
while (1)
HAL_Delay(TEMP_REFRESH_PERIOD);
JTemp = ((((ConvertedValue * VREF)/MAX_CONVERTED_VALUE) - VSENS_AT_AMBIENT_TEMP) * 10 / AVG_SLOPE) + AMBIENT_TEMP;
sprintf(desc, "Internal Temperature is %ld degree C", JTemp);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()/2 + 45, (uint8_t *)desc, CENTER_MODE);
BSP_LCD_ClearStringLine(30);
BSP_LED_Toggle(LED2);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.PLL.PLLR = 7;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void LCD_Config(void)
uint32_t  lcd_status = LCD_OK;
lcd_status = BSP_LCD_Init();
while(lcd_status != LCD_OK);
BSP_LCD_LayerDefaultInit(0, LCD_FB_START_ADDRESS);
BSP_LCD_Clear(LCD_COLOR_WHITE);
BSP_LCD_SetTextColor(LCD_COLOR_DARKBLUE);
BSP_LCD_SetFont(&Font12);
BSP_LCD_DisplayStringAt(0, BSP_LCD_GetYSize()- 20, (uint8_t *)"Copyright (c) STMicroelectronics 2016", CENTER_MODE);
BSP_LCD_SetTextColor(LCD_COLOR_BLUE);
BSP_LCD_FillRect(0, 0, BSP_LCD_GetXSize(), 120);
BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
BSP_LCD_SetFont(&Font24);
BSP_LCD_DisplayStringAt(0, 10, (uint8_t *)"ADC_TemperatureSensor", CENTER_MODE);
BSP_LCD_SetFont(&Font16);
BSP_LCD_DisplayStringAt(0, 60, (uint8_t *)"This example shows how to measure the Junction", CENTER_MODE);
BSP_LCD_DisplayStringAt(0, 75, (uint8_t *)"Temperature of the device via an Internal", CENTER_MODE);
BSP_LCD_DisplayStringAt(0, 90, (uint8_t *)"Sensor and display the Value on the LCD", CENTER_MODE);
BSP_LCD_SetTextColor(LCD_COLOR_BLACK);
BSP_LCD_SetBackColor(LCD_COLOR_WHITE);
BSP_LCD_SetFont(&Font24);
static void ADC_Config(void)
ADC_ChannelConfTypeDef sConfig;
AdcHandle.Instance          = ADC1;
AdcHandle.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV4;
AdcHandle.Init.Resolution            = ADC_RESOLUTION_12B;
AdcHandle.Init.ScanConvMode          = DISABLE;
AdcHandle.Init.ContinuousConvMode    = ENABLE;
AdcHandle.Init.DiscontinuousConvMode = DISABLE;
AdcHandle.Init.NbrOfDiscConversion   = 0;
AdcHandle.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
AdcHandle.Init.ExternalTrigConv      = ADC_EXTERNALTRIGCONV_T1_CC1;
AdcHandle.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
AdcHandle.Init.NbrOfConversion       = 1;
AdcHandle.Init.DMAContinuousRequests = ENABLE;
AdcHandle.Init.EOCSelection          = DISABLE;
if (HAL_ADC_Init(&AdcHandle) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_TEMPSENSOR;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_56CYCLES;
sConfig.Offset = 0;
if (HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(20);
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0xC0000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_32MB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER1;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0xA0000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_8KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER2;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x0;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void OnCalibrateSystemWakeupTimeTimerEvent( void )
RtcSetMcuWakeUpTime( );
SystemWakeupTimeCalibrated = true;
void BoardCriticalSectionBegin( uint32_t *mask )
*mask = __get_PRIMASK( );
__disable_irq( );
void BoardCriticalSectionEnd( uint32_t *mask )
__set_PRIMASK( *mask );
void BoardInitPeriph( void )
void BoardInitMcu( void )
if( McuInitialized == false )
HAL_Init( );
GpioInit( &Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
GpioInit( &Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
SystemClockConfig( );
UsbIsConnected = true;
FifoInit( &Uart2.FifoTx, Uart2TxBuffer, UART2_FIFO_TX_SIZE );
FifoInit( &Uart2.FifoRx, Uart2RxBuffer, UART2_FIFO_RX_SIZE );
UartInit( &Uart2, UART_2, UART_TX, UART_RX );
UartConfig( &Uart2, RX_TX, 921600, UART_8_BIT, UART_1_STOP_BIT, NO_PARITY, NO_FLOW_CTRL );
RtcInit( );
BoardUnusedIoInit( );
if( GetBoardPowerSource( ) == BATTERY_POWER )
LpmSetOffMode( LPM_APPLI_ID, LPM_DISABLE );
else
SystemClockReConfig( );
SpiInit( &SX126x.Spi, SPI_1, RADIO_MOSI, RADIO_MISO, RADIO_SCLK, NC );
SX126xIoInit( );
SpiInit( &SX1272.Spi, SPI_1, RADIO_MOSI, RADIO_MISO, RADIO_SCLK, NC );
SX1272IoInit( );
SpiInit( &SX1276.Spi, SPI_1, RADIO_MOSI, RADIO_MISO, RADIO_SCLK, NC );
SX1276IoInit( );
if( McuInitialized == false )
McuInitialized = true;
if( GetBoardPowerSource( ) == BATTERY_POWER )
CalibrateSystemWakeupTime( );
void BoardResetMcu( void )
CRITICAL_SECTION_BEGIN( );
NVIC_SystemReset( );
void BoardDeInitMcu( void )
SpiDeInit( &SX126x.Spi );
SX126xIoDeInit( );
SpiDeInit( &SX1272.Spi );
SX1272IoDeInit( );
SpiDeInit( &SX1276.Spi );
SX1276IoDeInit( );
uint32_t BoardGetRandomSeed( void )
return ( ( *( uint32_t* )ID1 ) ^ ( *( uint32_t* )ID2 ) ^ ( *( uint32_t* )ID3 ) );
void BoardGetUniqueId( uint8_t *id )
id[7] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 24;
id[6] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 16;
id[5] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) ) >> 8;
id[4] = ( ( *( uint32_t* )ID1 )+ ( *( uint32_t* )ID3 ) );
id[3] = ( ( *( uint32_t* )ID2 ) ) >> 24;
id[2] = ( ( *( uint32_t* )ID2 ) ) >> 16;
id[1] = ( ( *( uint32_t* )ID2 ) ) >> 8;
id[0] = ( ( *( uint32_t* )ID2 ) );
uint16_t BoardBatteryMeasureVolage( void )
return 0;
uint32_t BoardGetBatteryVoltage( void )
return 0;
uint8_t BoardGetBatteryLevel( void )
return 0;
static void BoardUnusedIoInit( void )
HAL_DBGMCU_EnableDBGSleepMode( );
HAL_DBGMCU_EnableDBGStopMode( );
HAL_DBGMCU_EnableDBGStandbyMode( );
void SystemClockConfig( void )
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
__HAL_RCC_PWR_CLK_ENABLE( );
__HAL_PWR_VOLTAGESCALING_CONFIG( PWR_REGULATOR_VOLTAGE_SCALE1 );
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE;
RCC_OscInitStruct.HSEState = RCC_HSE_OFF;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLLMUL_6;
RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLLDIV_3;
if( HAL_RCC_OscConfig( &RCC_OscInitStruct ) != HAL_OK )
assert_param( FAIL );
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_1 ) != HAL_OK )
assert_param( FAIL );
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
if( HAL_RCCEx_PeriphCLKConfig( &PeriphClkInit ) != HAL_OK )
assert_param( FAIL );
HAL_SYSTICK_Config( HAL_RCC_GetHCLKFreq( ) / 1000 );
HAL_SYSTICK_CLKSourceConfig( SYSTICK_CLKSOURCE_HCLK );
HAL_NVIC_SetPriority( SysTick_IRQn, 0, 0 );
void CalibrateSystemWakeupTime( void )
if( SystemWakeupTimeCalibrated == false )
TimerInit( &CalibrateSystemWakeupTimeTimer, OnCalibrateSystemWakeupTimeTimerEvent );
TimerSetValue( &CalibrateSystemWakeupTimeTimer, 1000 );
TimerStart( &CalibrateSystemWakeupTimeTimer );
while( SystemWakeupTimeCalibrated == false )
void SystemClockReConfig( void )
__HAL_RCC_PWR_CLK_ENABLE( );
__HAL_PWR_VOLTAGESCALING_CONFIG( PWR_REGULATOR_VOLTAGE_SCALE1 );
__HAL_RCC_HSI_CONFIG( RCC_HSI_ON );
while( __HAL_RCC_GET_FLAG( RCC_FLAG_HSIRDY ) == RESET )
__HAL_RCC_PLL_ENABLE( );
while( __HAL_RCC_GET_FLAG( RCC_FLAG_PLLRDY ) == RESET )
__HAL_RCC_SYSCLK_CONFIG ( RCC_SYSCLKSOURCE_PLLCLK );
while( __HAL_RCC_GET_SYSCLK_SOURCE( ) != RCC_SYSCLKSOURCE_STATUS_PLLCLK )
void SysTick_Handler( void )
HAL_IncTick( );
HAL_SYSTICK_IRQHandler( );
uint8_t GetBoardPowerSource( void )
if( UsbIsConnected == false )
return BATTERY_POWER;
else
return USB_POWER;
void LpmEnterStopMode( void)
CRITICAL_SECTION_BEGIN( );
BoardDeInitMcu( );
HAL_PWR_DisablePVD( );
SET_BIT( PWR->CR, PWR_CR_CWUF );
HAL_PWREx_EnableUltraLowPower( );
HAL_PWREx_EnableFastWakeUp( );
CRITICAL_SECTION_END( );
HAL_PWR_EnterSTOPMode( PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI );
void LpmExitStopMode( void )
CRITICAL_SECTION_BEGIN( );
BoardInitMcu( );
CRITICAL_SECTION_END( );
void LpmEnterSleepMode( void)
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
void BoardLowPowerHandler( void )
__disable_irq( );
LpmEnterLowPower( );
__enable_irq( );
int _write( int fd, const void *buf, size_t count )
while( UartPutBuffer( &Uart2, ( uint8_t* )buf, ( uint16_t )count ) != 0 ){ };
return count;
int _read( int fd, const void *buf, size_t count )
size_t bytesRead = 0;
while( UartGetBuffer( &Uart2, ( uint8_t* )buf, count, ( uint16_t* )&bytesRead ) != 0 ){ };
while( UartPutBuffer( &Uart2, ( uint8_t* )buf, ( uint16_t )bytesRead ) != 0 ){ };
return bytesRead;
int fputc( int c, FILE *stream )
while( UartPutChar( &Uart2, ( uint8_t )c ) != 0 );
return c;
int fgetc( FILE *stream )
uint8_t c = 0;
while( UartGetChar( &Uart2, &c ) != 0 );
while( UartPutChar( &Uart2, c ) != 0 );
return ( int )c;
void assert_failed( uint8_t* file, uint32_t line )
printf( "Wrong parameters value: file %s on line %lu\\r\\n", ( const char* )file, line );
while( 1 )
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_MEMS_Init();
while (1)
MX_MEMS_Process();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_10;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
uint16_t i=0;
int *packet_freq_points_No1 = NULL;
int symbol_len_No1 = NULL;
int *packet_freq_points_No2 = NULL;
int symbol_len_No2 = NULL;
HAL_Init();
SystemClock_Config();
HW_SPI_Init();
SPI1_Init();
delay_init(80);
uart_init(115200);
Control_GPIO_Init();
CC1125_Init();
printf("Tx\\r\\n");
printf("CR=4/%d, CRC=%s, IMPL_HEAD=%s, LDR=%s\\n",4+LORA_CR_NO1,LORA_HAS_CRC_NO1?"ON":"OFF",LORA_IMPL_HEAD_NO1?"ON":"OFF",LORA_LOWDATERATEOPTIMIZE_NO1?"ON":"OFF");
printf("FREQ1:%d,sf1:%d,\\r\\nFREQ2:%d,sf2:%d\\r\\n",RF_FREQUENCY_NO1,LORA_SF_NO1,RF_FREQUENCY_NO2,LORA_SF_NO2);
for (int j = 0; j < BufferSize; j++)
Tx_Buffer[j] = 0x31;
for(i=0;i<PACKET_COUNT;i++)
packet_freq_points_No1 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO1, LORA_CR_NO1, LORA_HAS_CRC_NO1, LORA_IMPL_HEAD_NO1, &symbol_len_No1, LORA_LOWDATERATEOPTIMIZE_NO1);
packet_freq_points_No2 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO2, LORA_CR_NO2, LORA_HAS_CRC_NO2, LORA_IMPL_HEAD_NO2, &symbol_len_No2, LORA_LOWDATERATEOPTIMIZE_NO2);
LoRa_Generate_Signal(packet_freq_points_No1,symbol_len_No1);
LoRa_Generate_Signal_With_Blank(packet_freq_points_No1,symbol_len_No1,LOOK_BLANK_RATIO);
LoRa_Generate_Double_Packet(packet_freq_points_No1,symbol_len_No1,packet_freq_points_No2,symbol_len_No2);
free(packet_freq_points_No1);
free(packet_freq_points_No2);
printf("Tx done, Count:%d\\r\\n",i+1);
delay_ms(INTERVAL_TIME);
printf("finish!!\\r\\n");
int main(void)
HAL_Init();
SystemClock_Config();
Periph_Config();
BSP_LED_Init(LED_GREEN);
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
Timing_Init();
Task_Init();
hrng.Instance = RNG;
if (HAL_RNG_Init(&hrng) != HAL_OK)
Error_Handler();
RTC_Init();
UART_Init(SUBSYSTEM_UART);
UART_RegisterReceiver(SUBSYSTEM_UART, GetCharReceiver);
Log_EchoOn();
UART_printf(SUBSYSTEM_UART, "System Initialized\\r\\n");
firewall_init();
Task_Schedule((task_t)cloud_test, (void*)1, 100, 100);
while(1) {
SystemTick();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 6;
RCC_OscInitStruct.PLL.PLLN = 20;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
HAL_RCCEx_EnableMSIPLLMode();
void Led_SetState(bool on)
if (on == true)
BSP_LED_On(LED_GREEN);
else
BSP_LED_Off(LED_GREEN);
void Led_Blink(int period, int duty, int count)
if ( (duty > 0) && (period >= duty) )
do
Led_SetState(true);
HAL_Delay(duty);
Led_SetState(false);
HAL_Delay(period - duty);
} while (count--);
if ( (duty < 0) && (period >= -duty) )
do
Led_SetState(false);
HAL_Delay(period + duty);
Led_SetState(true);
HAL_Delay(-duty);
} while (count--);
static void Button_ISR(void)
button_flags++;
uint8_t Button_WaitForPush(uint32_t delay)
uint32_t time_out = HAL_GetTick()+delay;
do
if (button_flags > 1)
button_flags = 0;
return BP_MULTIPLE_PUSH;
if (button_flags == 1)
button_flags = 0;
return BP_SINGLE_PUSH;
while( HAL_GetTick() < time_out);
return BP_NOT_PUSHED;
uint8_t Button_WaitForMultiPush(uint32_t delay)
static uint32_t timestamp = 0;
if(TimeSince(timestamp)>delay) {
timestamp = TimeNow();
if (button_flags > 1)
button_flags = 0;
return BP_MULTIPLE_PUSH;
if (button_flags == 1)
button_flags = 0;
return BP_SINGLE_PUSH;
return BP_NOT_PUSHED;
static void Console_UART_Init(void)
console_uart.Instance = USART1;
console_uart.Init.BaudRate = 115200;
console_uart.Init.WordLength = UART_WORDLENGTH_8B;
console_uart.Init.StopBits = UART_STOPBITS_1;
console_uart.Init.Parity = UART_PARITY_NONE;
console_uart.Init.Mode = UART_MODE_TX_RX;
console_uart.Init.HwFlowCtl = UART_HWCONTROL_NONE;
console_uart.Init.OverSampling = UART_OVERSAMPLING_16;
console_uart.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
console_uart.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
BSP_COM_Init(COM1,&console_uart);
static void RTC_Init(void)
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
static void cloud_test(void const *arg)
static uint8_t state = 0;
int return_val;
switch(state) {
case 0:
return_val = platform_init();
if(return_val == 0) state++;
break;
case 1:
LaserTag_Init();
if(return_val == 0) state++;
else if(return_val < 0) state = 0;
Task_Remove(cloud_test, 0);
break;
case 2:
platform_deinit();
state++;
break;
case 3:
break;
default:
state = 0;
break;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
switch (GPIO_Pin)
case (GPIO_PIN_13):
Button_ISR();
break;
case (GPIO_PIN_1):
SPI_WIFI_ISR();
break;
default:
break;
void SPI3_IRQHandler(void)
HAL_SPI_IRQHandler(&hspi);
void Error_Handler(void)
while(1)
BSP_LED_Toggle(LED_GREEN);
HAL_Delay(200);
int main(void)
char Temp_Buffer_text[40];
uint16_t value_dac=0;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_ADC1_Init();
MX_SPI1_Init();
MX_SPI2_Init();
MX_I2C1_Init();
HAL_UART_Receive_IT(&huart1, (uint8_t *) uart1_indx, 1);
HAL_ADC_Start_IT(&hadc1);
HAL_GPIO_WritePin(LCD_LED_GPIO_Port,LCD_LED_Pin,on);
ILI9341_Init();
ILI9341_Fill_Screen(WHITE);
ILI9341_Set_Rotation(SCREEN_HORIZONTAL_1);
ILI9341_Draw_Text("FPS TEST, 40 loop 2 screens", 10, 10, BLACK, 1, WHITE);
MCP4822_DAC_Write(DAC_B, GAIN_X2, SHUTDOWN_MODE, 2000);
HAL_Delay(100);
MCP4822_DAC_Write(DAC_A, GAIN_X2, ACTIVE_MODE, 1234);
while (1)
HAL_GPIO_WritePin(LED1_GPIO_Port,LED1_Pin,HAL_GPIO_ReadPin(POWER_GOOD_GPIO_Port,POWER_GOOD_Pin));
HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV8;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_0;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_HARD_OUTPUT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_SPI2_Init(void)
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_MASTER;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_16BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_SOFT;
hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi2.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi2) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 9600;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, LED1_Pin|LED2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, LCD_LED_Pin|LCD_DC_Pin|LCD_RST_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(DAC_CS_GPIO_Port, DAC_CS_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(BUZZER_GPIO_Port, BUZZER_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED1_Pin|LED2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BT1_Pin|BT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LCD_LED_Pin|LCD_DC_Pin|LCD_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = DAC_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(DAC_CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = POWER_GOOD_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(POWER_GOOD_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BUZZER_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(BUZZER_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
init();
osThreadDef(shutdownMonitorTask, ShutdownMonitorThread, osPriorityNormal, 0, 128);
osThreadDef(timeTask, TimeThread, osPriorityNormal, 0, 128);
osThreadDef(controlsTask, ControlsThread, osPriorityNormal, 0, 128);
osThreadCreate(osThread(shutdownMonitorTask), NULL);
osThreadCreate(osThread(timeTask), NULL);
osThreadCreate(osThread(controlsTask), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM4) {
HAL_IncTick();
void vApplicationIdleHook(void)
HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
RTC_AlarmConfig();
while (1)
RTC_TimeShow(aShowTime);
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
BSP_LED_On(LED1);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void Error_Handler(void)
while (1)
BSP_LED_Toggle(LED3);
HAL_Delay(1000);
static void RTC_AlarmConfig(void)
RTC_DateTypeDef  sdatestructure;
RTC_TimeTypeDef  stimestructure;
RTC_AlarmTypeDef salarmstructure;
sdatestructure.Year = 0x14;
sdatestructure.Month = RTC_MONTH_FEBRUARY;
sdatestructure.Date = 0x18;
sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
stimestructure.Hours = 0x02;
stimestructure.Minutes = 0x20;
stimestructure.Seconds = 0x00;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
salarmstructure.Alarm = RTC_ALARM_A;
salarmstructure.AlarmDateWeekDay = RTC_WEEKDAY_MONDAY;
salarmstructure.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_WEEKDAY;
salarmstructure.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY;
salarmstructure.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;
salarmstructure.AlarmTime.TimeFormat = RTC_HOURFORMAT12_AM;
salarmstructure.AlarmTime.Hours = 0x02;
salarmstructure.AlarmTime.Minutes = 0x20;
salarmstructure.AlarmTime.Seconds = 0x30;
salarmstructure.AlarmTime.SubSeconds = 0x56;
if(HAL_RTC_SetAlarm_IT(&RtcHandle,&salarmstructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
static void RTC_TimeShow(uint8_t* showtime)
RTC_DateTypeDef sdatestructureget;
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char*)showtime,"%02d:%02d:%02d",stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_RTC_Init();
MX_SPI1_Init();
MX_UART7_Init();
MX_USART2_UART_Init();
osKernelInitialize();
coreToLCDHandle = osMessageQueueNew (3, 15, &coreToLCD_attributes);
radioToCoreHandle = osMessageQueueNew (3, 25, &radioToCore_attributes);
coreTaskHandle = osThreadNew(StartCoreTask, NULL, &coreTask_attributes);
radioTaskHandle = osThreadNew(StartRadioTask, NULL, &radioTask_attributes);
lcdTaskHandle = osThreadNew(StartLCDTask, NULL, &lcdTask_attributes);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
static void MX_RTC_Init(void)
RTC_TimeTypeDef sTime = {0};
RTC_DateTypeDef sDate = {0};
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
sTime.Hours = 0x0;
sTime.Minutes = 0x0;
sTime.Seconds = 0x0;
sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
sTime.StoreOperation = RTC_STOREOPERATION_RESET;
if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
sDate.WeekDay = RTC_WEEKDAY_MONDAY;
sDate.Month = RTC_MONTH_JANUARY;
sDate.Date = 0x1;
sDate.Year = 0x0;
if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_32;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_UART7_Init(void)
huart7.Instance = UART7;
huart7.Init.BaudRate = 9600;
huart7.Init.WordLength = UART_WORDLENGTH_8B;
huart7.Init.StopBits = UART_STOPBITS_1;
huart7.Init.Parity = UART_PARITY_NONE;
huart7.Init.Mode = UART_MODE_TX_RX;
huart7.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart7.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_HalfDuplex_Init(&huart7) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_HalfDuplex_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_4, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, LD1_Pin|LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOG, USB_PowerSwitchOn_Pin|GPIO_PIN_9, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD1_Pin|LD3_Pin|LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = STLK_RX_Pin|STLK_TX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_SOF_Pin|USB_ID_Pin|USB_DM_Pin|USB_DP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_VBUS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USB_VBUS_GPIO_Port, &GPIO_InitStruct);
void StartCoreTask(void *argument)
MX_LWIP_Init();
Core_Set_RTC_Handle( &hrtc );
Core_Set_LCD_Message_Queue( coreToLCDHandle );
Core_Set_Radio_Message_Queue( radioToCoreHandle );
Core_Set_Debug_UART( &huart2 );
for(;;)
Core_Run();
osThreadYield();
void StartRadioTask(void *argument)
Radio_Set_SPI( &hspi1 );
Radio_Set_Reset_Pin( GPIOG, GPIO_PIN_9 );
Radio_Set_NCS_Pin( GPIOA, GPIO_PIN_4 );
Radio_Set_Message_Queue( radioToCoreHandle );
for(;;)
Radio_Run();
osThreadYield();
void StartLCDTask(void *argument)
LCD_Set_UART( &huart7 );
LCD_Set_Message_Queue( coreToLCDHandle );
LCD_Set_RTC( &hrtc );
LCD_Init();
for(;;)
LCD_Run();
osThreadYield();
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM7) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_LPUART1_UART_Init();
MX_LPTIM1_Init();
morse_1_init();
while (1)
morse_1_step();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
RCC_OscInitStruct.PLL.PLLN = 85;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1|RCC_PERIPHCLK_LPTIM1;
PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
PeriphClkInit.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_LPTIM1_Init(void)
hlptim1.Instance = LPTIM1;
hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;
hlptim1.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
hlptim1.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
Error_Handler();
static void MX_LPUART1_UART_Init(void)
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
hlpuart1.Init.StopBits = UART_STOPBITS_1;
hlpuart1.Init.Parity = UART_PARITY_NONE;
hlpuart1.Init.Mode = UART_MODE_TX_RX;
hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&hlpuart1) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USER_BUTTON_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USER_LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(USER_LED_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
UartHandle.Instance        = USARTx;
UartHandle.Init.BaudRate   = 9600;
UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits   = UART_STOPBITS_1;
UartHandle.Init.Parity     = UART_PARITY_ODD;
UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
UartHandle.Init.Mode       = UART_MODE_TX_RX;
if (HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
printf("\\n\\r UART Printf Example: retarget the C library printf function to the UART\\n\\r");
printf("** Test finished successfully. ** \\n\\r");
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
CrcHandle.Instance = CRC;
if (HAL_CRC_Init(&CrcHandle) != HAL_OK)
Error_Handler();
uwCRCValue = HAL_CRC_Calculate(&CrcHandle, (uint32_t *)aDataBuffer, BUFFER_SIZE);
if (uwCRCValue != uwExpectedCRCValue)
Error_Handler();
else
BSP_LED_On(LED1);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
void flashModulesCallback(bool isUpdating)
if(isUpdating)
OTA_FLASH_AVAILABLE = 1;
LED_SetRGBColor(FirmwareUpdateColor);
else
OTA_FLASH_AVAILABLE = 0;
LED_Off(LED_RGB);
int main(void)
Set_System();
BUTTON_Init_Ext();
SysTick_Configuration();
platform_startup();
USE_SYSTEM_FLAGS = 1;
Load_SystemFlags();
Save_Reset_Syndrome();
if (SYSTEM_FLAG(Bootloader_Version_SysFlag) != BOOTLOADER_VERSION)
Bootloader_Update_Version(BOOTLOADER_VERSION);
if (SYSTEM_FLAG(StartupMode_SysFlag) != 0) {
SYSTEM_FLAG(StartupMode_SysFlag) = 0;
Save_SystemFlags();
uint8_t features = SYSTEM_FLAG(FeaturesEnabled_SysFlag);
if (true || (features!=0xFF && (((~(features>>4)&0xF)) != (features & 0xF))) || (features&8)) {
features = 0xFF;
get_led_theme_colors(&FirmwareUpdateColor, &SafeModeColor, &DFUModeColor);
ApplicationAddress = CORE_FW_ADDRESS;
if((BACKUP_REGISTER(BKP_DR_10) == 0x0005) ||
(SYSTEM_FLAG(FLASH_OTA_Update_SysFlag) == 0x0005))
OTA_FLASH_AVAILABLE = 1;
else if((BACKUP_REGISTER(BKP_DR_10) == 0x5555) ||
(SYSTEM_FLAG(FLASH_OTA_Update_SysFlag) == 0x5555))
OTA_FLASH_AVAILABLE = 0;
REFLASH_FROM_BACKUP = 1;
if (0xAAAA == SYSTEM_FLAG(Factory_Reset_SysFlag))
FACTORY_RESET_MODE = 1;
volatile uint16_t BKP_DR1_Value = HAL_Core_Read_Backup_Register(BKP_DR_01);
if(BKP_DR1_Value != 0xFFFF)
if (BKP_DR1_Value == ENTER_DFU_APP_REQUEST)
USB_DFU_MODE = 1;
HAL_Core_Write_Backup_Register(BKP_DR_01, 0xFFFF);
else if (BKP_DR1_Value == ENTER_SAFE_MODE_APP_REQUEST)
SAFE_MODE = 1;
HAL_Core_Write_Backup_Register(BKP_DR_01, 0xFFFF);
else if (RCC_GetFlagStatus(RCC_FLAG_IWDGRST) != RESET)
switch(BKP_DR1_Value)
case FIRST_RETRY:
REFLASH_FROM_BACKUP = 1;
BKP_DR1_Value += 1;
break;
case SECOND_RETRY:
FACTORY_RESET_MODE = 1;
SYSTEM_FLAG(NVMEM_SPARK_Reset_SysFlag) = 0x0000;
BKP_DR1_Value += 1;
break;
case THIRD_RETRY:
USB_DFU_MODE = 1;
case ENTERED_SparkCoreConfig:
case ENTERED_Main:
case ENTERED_Setup:
case ENTERED_Loop:
case RAN_Loop:
case PRESERVE_APP:
default:
BKP_DR1_Value = 0xFFFF;
break;
HAL_Core_Write_Backup_Register(BKP_DR_01, BKP_DR1_Value);
OTA_Flashed_ResetStatus();
RCC_ClearFlag();
else
BKP_DR1_Value = 1;
HAL_Core_Write_Backup_Register(BKP_DR_01, BKP_DR1_Value);
if (BUTTON_Is_Pressed(BUTTON1) && (features & BL_BUTTON_FEATURES))
bool factory_reset_available = (features & BL_FEATURE_FACTORY_RESET) && FLASH_IsFactoryResetAvailable();
TimingBUTTON = TIMING_ALL;
while (BUTTON_Is_Pressed(BUTTON1) && TimingBUTTON)
if(BUTTON_Pressed_Time(BUTTON1) > TIMING_RESET_MODE)
LED_SetRGBColor(RGB_COLOR_WHITE);
SYSTEM_FLAG(NVMEM_SPARK_Reset_SysFlag) = 0x0001;
else if(!FACTORY_RESET_MODE && BUTTON_Pressed_Time(BUTTON1) > TIMING_RESTORE_MODE)
LED_SetRGBColor(RGB_COLOR_GREEN);
SYSTEM_FLAG(NVMEM_SPARK_Reset_SysFlag) = 0x0000;
FACTORY_RESET_MODE = 1;
else if(!USB_DFU_MODE && BUTTON_Pressed_Time(BUTTON1) >= TIMING_DFU_MODE)
if (features&BL_FEATURE_DFU_MODE) {
LED_SetRGBColor(DFUModeColor);
USB_DFU_MODE = 1;
if (!factory_reset_available)
break;
else if(!SAFE_MODE && BUTTON_Pressed_Time(BUTTON1) >= TIMING_SAFE_MODE)
OTA_FLASH_AVAILABLE = 0;
REFLASH_FROM_BACKUP = 0;
FACTORY_RESET_MODE = 0;
if (features&BL_FEATURE_SAFE_MODE) {
LED_SetRGBColor(SafeModeColor);
SAFE_MODE = 1;
if (SAFE_MODE) {
SYSTEM_FLAG(StartupMode_SysFlag) = 0x0001;
Save_SystemFlags();
if (OTA_FLASH_AVAILABLE == 1)
LED_SetRGBColor(FirmwareUpdateColor);
OTA_Flash_Reset();
else if (FACTORY_RESET_MODE)
if (FACTORY_RESET_MODE == 1)
if (SYSTEM_FLAG(NVMEM_SPARK_Reset_SysFlag) == 0x0001)
LED_SetRGBColor(RGB_COLOR_WHITE);
else
LED_SetRGBColor(RGB_COLOR_GREEN);
if (!FACTORY_Flash_Reset()) {
if (is_application_valid(ApplicationAddress)) {
NVIC_SystemReset();
} else {
FACTORY_RESET_MODE = 0;
Finish_Update();
else if (USB_DFU_MODE == 0)
FLASH_UpdateModules(flashModulesCallback);
if (REFLASH_FROM_BACKUP == 1)
LED_SetRGBColor(RGB_COLOR_RED);
BACKUP_Flash_Reset();
if (is_application_valid(ApplicationAddress))
JumpAddress = *(__IO uint32_t*) (ApplicationAddress + 4);
Jump_To_Application = (pFunction) JumpAddress;
__set_MSP(*(__IO uint32_t*) ApplicationAddress);
IWDG_Reset_Enable(5 * TIMING_IWDG_RELOAD);
SysTick_Disable();
Jump_To_Application();
else
LED_SetRGBColor(RGB_COLOR_RED);
FACTORY_Flash_Reset();
FACTORY_RESET_MODE = 0;
OTA_FLASH_AVAILABLE = 0;
REFLASH_FROM_BACKUP = 0;
LED_SetRGBColor(DFUModeColor);
USB_DFU_MODE = 1;
HAL_DFU_USB_Init();
while (1)
void Timing_Decrement(void)
if (TimingBUTTON != 0x00)
TimingBUTTON--;
if (TimingLED != 0x00)
TimingLED--;
else if(FACTORY_RESET_MODE || REFLASH_FROM_BACKUP || OTA_FLASH_AVAILABLE)
LED_Toggle(LED_RGB);
TimingLED = 50;
else if(SAFE_MODE || USB_DFU_MODE)
LED_Toggle(LED_RGB);
TimingLED = 100;
DFU_Check_Reset();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
static void call_constructors(unsigned long *start, unsigned long *end)
unsigned long *i;
void (*funcptr)();
for (i = start; i < end; i++)
funcptr=(void (*)())(*i);
funcptr();
void CallConstructors(void)
call_constructors(&link_constructors_location, &link_constructors_end);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC1_Init();
MX_USART2_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig;
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4;
hadc1.Init.Resolution = ADC_RESOLUTION12b;
hadc1.Init.ScanConvMode = DISABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
hadc1.Init.DMAContinuousRequests = DISABLE;
hadc1.Init.EOCSelection = EOC_SINGLE_CONV;
HAL_ADC_Init(&hadc1);
sConfig.Channel = ADC_CHANNEL_0;
sConfig.Rank = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
HAL_ADC_ConfigChannel(&hadc1, &sConfig);
void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&huart2);
void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__GPIOC_CLK_ENABLE();
__GPIOH_CLK_ENABLE();
__GPIOA_CLK_ENABLE();
__GPIOB_CLK_ENABLE();
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
void assert_failed(uint8_t* file, uint32_t line)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim == &htim6)
if(!IsAutoBiasUpdate()){
DEBUG_PIN_HIGH;
if(READ_USER_SW){
LD2_ON;
HAL_Delay(500);
mkAE_Reset_Filter();
LD2_OFF;
}else{
pose_update_func();
DEBUG_PIN_LOW;
if (htim == &htim7)
AutoBiasUpdate_TIM();
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USB_DEVICE_Init();
MX_SPI1_Init();
MX_USART3_UART_Init();
MX_TIM6_Init();
MX_TIM7_Init();
Read_FlashData();
IMU_BRD_SETTING(CONTROL_CYCLE,(double)Params.send_cycle_ms/1000.0);
mkAE_Filter_Init(CONTROL_CYCLE);
Start_PoseUpdateTimer();
while (1)
switch(tim_mode){
case USB_SPI_MODE:
ReadBinaryCmd();
break;
default:
ReadStringCmd();
print_func();
break;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_16BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_HIGH;
hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM6_Init(void)
htim6.Instance = TIM6;
htim6.Init.Prescaler = 4800-1;
htim6.Init.CounterMode = TIM_COUNTERMODE_UP;
htim6.Init.Period = 100-1;
htim6.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim6) != HAL_OK)
Error_Handler();
static void MX_TIM7_Init(void)
htim7.Instance = TIM7;
htim7.Init.Prescaler = 4800-1;
htim7.Init.CounterMode = TIM_COUNTERMODE_UP;
htim7.Init.Period = 5000-1;
htim7.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim7) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 460800;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LD1_Pin|LD2_Pin|LD3_Pin|ADIS_nRST_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(DEBUG_PIN_GPIO_Port, DEBUG_PIN_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(SPI1_nCS_GPIO_Port, SPI1_nCS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = USER_SW_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_SW_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD1_Pin|LD2_Pin|LD3_Pin|ADIS_nRST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CONF_SW1_Pin|CONF_SW2_Pin|CONF_SW3_Pin|CONF_SW4_Pin
|CONF_SW5_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = DEBUG_PIN_Pin|SPI1_nCS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = ADIS_DR_Pin|ADIS_SYNC_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_I2CEx_EnableFastModePlus(SYSCFG_CFGR1_I2C_FMP_PB6);
void Error_Handler(void)
while(1)
void assert_failed(char *file, uint32_t line)
void Sigfox_Init(void)
sfx_u8 error = 0;
SigfoxInfo_t *SigfoxRegionInfo;
FEAT_INFO_Param_t *p_cm0plus_specific_features_info;
uint32_t sgfx_cm0plus_app;
APP_LOG(TS_OFF, VLEVEL_M, "M4 APP_VERSION:     V%X.%X.%X\\r\\n",
(uint8_t)(__CM4_APP_VERSION >> __APP_VERSION_MAIN_SHIFT),
(uint8_t)(__CM4_APP_VERSION >> __APP_VERSION_SUB1_SHIFT),
(uint8_t)(__CM4_APP_VERSION >> __APP_VERSION_SUB2_SHIFT));
p_cm0plus_specific_features_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_SYSTEM_ID);
sgfx_cm0plus_app = p_cm0plus_specific_features_info->Feat_Info_Feature_Version ;
APP_LOG(TS_OFF, VLEVEL_M, "M0PLUS_APP_VERSION: V%X.%X.%X\\r\\n",
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_MAIN_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB1_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB2_SHIFT));
p_cm0plus_specific_features_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_SIGFOX_ID);
sgfx_cm0plus_app = p_cm0plus_specific_features_info->Feat_Info_Feature_Version ;
APP_LOG(TS_OFF, VLEVEL_M, "MW_SIGFOX_VERSION:  V%X.%X.%X\\r\\n",
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_MAIN_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB1_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB2_SHIFT));
p_cm0plus_specific_features_info = MBMUXIF_SystemGetFeatCapabInfoPtr(FEAT_INFO_RADIO_ID);
sgfx_cm0plus_app = p_cm0plus_specific_features_info->Feat_Info_Feature_Version ;
APP_LOG(TS_OFF, VLEVEL_M, "MW_RADIO_VERSION:   V%X.%X.%X\\r\\n",
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_MAIN_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB1_SHIFT),
(uint8_t)(sgfx_cm0plus_app >> __APP_VERSION_SUB2_SHIFT));
BSP_LED_Init(LED_BLUE);
BSP_LED_Init(LED_GREEN);
SYS_LED_Init(SYS_LED_BLUE);
SYS_LED_Init(SYS_LED_GREEN);
BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
SYS_PB_Init(SYS_BUTTON1, SYS_BUTTON_MODE_EXTI);
E2P_Write_Rc(DEFAULT_RC);
error = st_sigfox_open(E2P_Read_Rc());
SigfoxInfo_Init();
SigfoxRegionInfo = SigfoxInfo_GetPtr();
if (SigfoxRegionInfo->Region == 0)
APP_PRINTF("error: At least one region shall be defined : RC1 to RC7 \\n\\r");
while (1) {}
Sigfox_Register(&SigfoxCallbacks);
if (1U == E2P_Read_AtEcho())
if (error == SFX_ERR_NONE)
APP_PPRINTF("\\r\\n\\n\\rSIGFOX APPLICATION READY\\n\\r\\n\\r");
else
APP_PPRINTF("\\r\\n\\n\\rSIGFOX APPLICATION ERROR: %d\\n\\r\\n\\r", error);
UTIL_SEQ_RegTask((1 << CFG_SEQ_Task_Pb), UTIL_SEQ_RFU, SendSigfox);
void BSP_PB_Callback(Button_TypeDef Button)
switch (Button)
case  BUTTON_SW1:
UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_Pb), CFG_SEQ_Prio_0);
break;
default:
break;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
switch (GPIO_Pin)
case  SYS_BUTTON1_PIN:
UTIL_SEQ_SetTask((1 << CFG_SEQ_Task_Pb), CFG_SEQ_Prio_0);
break;
case  SYS_BUTTON2_PIN:
break;
default:
break;
static sfx_error_t st_sigfox_open(sfx_rc_enum_t sfx_rc)
sfx_u32 config_words[3] = {0};
E2P_Read_ConfigWords(sfx_rc, config_words);
sfx_error_t error = SFX_ERR_NONE;
switch (sfx_rc)
case SFX_RC1:
sfx_rc_t SgfxRc = RC1;
error = SIGFOX_API_open(&SgfxRc);
break;
case SFX_RC2:
sfx_rc_t SgfxRc = RC2;
error = SIGFOX_API_open(&SgfxRc);
if (error == SFX_ERR_NONE)
error = SIGFOX_API_set_std_config(config_words, RC2_SET_STD_TIMER_ENABLE);
break;
case SFX_RC3A:
sfx_rc_t SgfxRc = RC3A;
error = SIGFOX_API_open(&SgfxRc);
if (error == SFX_ERR_NONE)
error = SIGFOX_API_set_std_config(config_words, NA);
break;
case SFX_RC3C:
sfx_rc_t SgfxRc = RC3C;
error = SIGFOX_API_open(&SgfxRc);
if (error == SFX_ERR_NONE)
error = SIGFOX_API_set_std_config(config_words, NA);
break;
case SFX_RC4:
sfx_rc_t SgfxRc = RC4;
error = SIGFOX_API_open(&SgfxRc);
if (error == SFX_ERR_NONE)
error = SIGFOX_API_set_std_config(config_words, RC4_SET_STD_TIMER_ENABLE);
break;
case SFX_RC5:
sfx_rc_t SgfxRc = RC5;
error = SIGFOX_API_open(&SgfxRc);
if (error == SFX_ERR_NONE)
error = SIGFOX_API_set_std_config(config_words, NA);
break;
case SFX_RC6:
sfx_rc_t SgfxRc = RC6;
error = SIGFOX_API_open(&SgfxRc);
break;
case SFX_RC7:
sfx_rc_t SgfxRc = RC7;
error = SIGFOX_API_open(&SgfxRc);
break;
default:
error = SFX_ERR_API_OPEN;
break;
return error;
static void SendSigfox(void)
uint8_t ul_msg[12] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x10, 0x11};
uint8_t dl_msg[8] = {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};
uint32_t  ul_size = 0;
int16_t temperature = SYS_GetTemperatureLevel() >> 8;
uint16_t batteryLevel = SYS_GetBatteryLevel();
uint32_t nbTxRepeatFlag = 1;
sensor_t sensor_data;
uint16_t pressure = 0;
uint16_t humidity = 0;
EnvSensors_Read(&sensor_data);
pressure    = (uint16_t)(sensor_data.pressure * 100 / 10);
humidity    = (uint16_t) sensor_data.humidity;
APP_LOG(TS_ON, VLEVEL_L, "sending temperature=%d degC,  battery=%d mV", temperature, batteryLevel);
ul_msg[ul_size++] = (uint8_t)((batteryLevel * 100) / 3300);
ul_msg[ul_size++] = (pressure >> 8) & 0xFF;
ul_msg[ul_size++] = pressure & 0xFF;
ul_msg[ul_size++] = (temperature >> 8) & 0xFF;
ul_msg[ul_size++] = temperature & 0xFF;
ul_msg[ul_size++] = (humidity >> 8) & 0xFF;
ul_msg[ul_size++] = humidity & 0xFF;
BSP_LED_On(LED_BLUE);
SYS_LED_On(SYS_LED_BLUE);
SIGFOX_API_send_frame(ul_msg, ul_size, dl_msg, nbTxRepeatFlag, SFX_FALSE);
BSP_LED_Off(LED_BLUE);
SYS_LED_Off(SYS_LED_BLUE);
APP_LOG(TS_OFF, VLEVEL_L, " done\\n\\r");
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
static unsigned short pin_state = 0;
while (1)
pin_state = !pin_state;
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, pin_state);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 38400;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int fputc(int ch, FILE *f)
if (ch == '\\n') {
HAL_UART_Transmit(&huart1, (void *)"\\r", 1,30000);
HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);
return ch;
int _write(int fd, char *ptr, int len)
(void)HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF);
return len;
int fgetc(FILE *f)
uint8_t ch = 0;
HAL_UART_Receive(&huart1, &ch, 1,30000);
return ch;
void board_init(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
dwt_delay_init(SystemCoreClock);
MX_RNG_Init();
printf("hardware init ok\\r\\n");
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 8;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void HAL_MspInit(void)
__HAL_RCC_SYSCFG_CLK_ENABLE();
__HAL_RCC_PWR_CLK_ENABLE();
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void HAL_I2C_MspInit(I2C_HandleTypeDef* hi2c)
GPIO_InitTypeDef GPIO_InitStruct;
if(hi2c->Instance==I2C1)
GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
__HAL_RCC_I2C1_CLK_ENABLE();
void HAL_I2C_MspDeInit(I2C_HandleTypeDef* hi2c)
if(hi2c->Instance==I2C1)
__HAL_RCC_I2C1_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8|GPIO_PIN_9);
void HAL_UART_MspInit(UART_HandleTypeDef* huart)
GPIO_InitTypeDef GPIO_InitStruct;
if(huart->Instance==USART1)
__HAL_RCC_USART1_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
hdma_usart1_rx.Instance = DMA1_Channel5;
hdma_usart1_rx.Init.Request = DMA_REQUEST_2;
hdma_usart1_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_usart1_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart1_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart1_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart1_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart1_rx.Init.Mode = DMA_NORMAL;
hdma_usart1_rx.Init.Priority = DMA_PRIORITY_LOW;
if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
__HAL_LINKDMA(huart,hdmarx,hdma_usart1_rx);
hdma_usart1_tx.Instance = DMA1_Channel4;
hdma_usart1_tx.Init.Request = DMA_REQUEST_2;
hdma_usart1_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
hdma_usart1_tx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart1_tx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart1_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart1_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart1_tx.Init.Mode = DMA_NORMAL;
hdma_usart1_tx.Init.Priority = DMA_PRIORITY_LOW;
if (HAL_DMA_Init(&hdma_usart1_tx) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
__HAL_LINKDMA(huart,hdmatx,hdma_usart1_tx);
HAL_NVIC_SetPriority(USART1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART1_IRQn);
else if(huart->Instance==USART2)
__HAL_RCC_USART2_CLK_ENABLE();
GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART2_IRQn);
} else if(huart->Instance==USART3)
__HAL_RCC_USART3_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
hdma_usart3_rx.Instance = DMA1_Channel3;
hdma_usart3_rx.Init.Request = DMA_REQUEST_2;
hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart3_rx.Init.Mode = DMA_NORMAL;
hdma_usart3_rx.Init.Priority = DMA_PRIORITY_LOW;
if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
printf("failed hdma_usart3_rx\\n");
__HAL_LINKDMA(huart,hdmarx,hdma_usart3_rx);
hdma_usart3_tx.Instance = DMA1_Channel2;
hdma_usart3_tx.Init.Request = DMA_REQUEST_2;
hdma_usart3_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
hdma_usart3_tx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart3_tx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart3_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart3_tx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart3_tx.Init.Mode = DMA_NORMAL;
hdma_usart3_tx.Init.Priority = DMA_PRIORITY_LOW;
if (HAL_DMA_Init(&hdma_usart3_tx) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
printf("failed hdma_usart3_tx\\n");
__HAL_LINKDMA(huart,hdmatx,hdma_usart3_tx);
HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART3_IRQn);
void HAL_UART_MspDeInit(UART_HandleTypeDef* huart)
if(huart->Instance==USART1)
__HAL_RCC_USART1_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);
HAL_DMA_DeInit(huart->hdmarx);
HAL_DMA_DeInit(huart->hdmatx);
HAL_NVIC_DisableIRQ(USART1_IRQn);
else if(huart->Instance==USART2)
__HAL_RCC_USART2_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOA, USART_TX_Pin|USART_RX_Pin);
HAL_NVIC_DisableIRQ(USART2_IRQn);
}   else if(huart->Instance==USART3)
__HAL_RCC_USART3_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOC, GPIO_PIN_4|GPIO_PIN_5);
HAL_DMA_DeInit(huart->hdmarx);
HAL_DMA_DeInit(huart->hdmatx);
HAL_NVIC_DisableIRQ(USART3_IRQn);
int main(void)
MPU_Config();
SCB_EnableICache();
SCB_EnableDCache();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_CRC_Init();
MX_DMA2D_Init();
MX_FMC_Init();
MX_I2C3_Init();
MX_LTDC_Init();
MX_QUADSPI_Init();
MX_TouchGFX_Init();
osKernelInitialize();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_I2C3;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
PeriphClkInitStruct.PLLSAI.PLLSAIR = 5;
PeriphClkInitStruct.PLLSAI.PLLSAIQ = 2;
PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV2;
PeriphClkInitStruct.PLLSAIDivQ = 1;
PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct = {0};
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.BaseAddress = 0x90000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_256MB;
MPU_InitStruct.SubRegionDisable = 0x0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Number = MPU_REGION_NUMBER1;
MPU_InitStruct.Size = MPU_REGION_SIZE_16MB;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM6) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_ICACHE_Init();
MX_GPIO_Init();
MX_DMA_Init();
MX_USB_Device_Init();
BSP_LED_Init(LED5);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_CRSInitTypeDef RCC_CRSInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000,1000);
RCC_CRSInitStruct.ErrorLimitValue = 34;
RCC_CRSInitStruct.HSI48CalibrationValue = 32;
HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
__HAL_RCC_CRS_CLK_ENABLE();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
void MX_TIM2_Init(void)
TIM_SlaveConfigTypeDef sSlaveConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim2.Instance = TIM2;
htim2.Init.Prescaler = (4000000/10000) - 1;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 10000 - 1;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode = TIM_SLAVEMODE_DISABLE;
sSlaveConfig.InputTrigger = TIM_TS_ITR0;
if (HAL_TIM_SlaveConfigSynchro(&htim2, &sSlaveConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
Error_Handler();
void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart3.Init.ClockPrescaler = UART_PRESCALER_DIV1;
huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&huart3, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&huart3, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&huart3) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMAMUX1_CLK_ENABLE();
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 6, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void HAL_Delay(__IO uint32_t Delay)
while (Delay)
if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
Delay--;
void Error_Handler(void)
BSP_LED_On(LED5);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main( void )
BaseType_t x;
prvSetupHardware();
xControlMessageBuffer = xMessageBufferCreateStatic(
mbaCONTROL_MESSAGE_BUFFER_SIZE,
ucControlBufferStorage,
&xControlMessageBufferStruct );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xDataMessageBuffers[ x ] = xMessageBufferCreateStatic( mbaTASK_MESSAGE_BUFFER_SIZE,
&( ucDataBufferStorage[ x ][ 0 ] ),
&( xDataMessageBufferStructs[ x ] ) );
prvWaitForOtherCoreToStart( mainINDEX_TO_TEST, mainINDEX_TO_INCREMENT );
xTaskCreate( prvM7CoreTasks,
"AMPM7Core",
configMINIMAL_STACK_SIZE,
NULL,
tskIDLE_PRIORITY,
&xM7AMPTask );
vTaskStartScheduler();
for( ;; );
static void prvM7CoreTasks( void *pvParameters )
BaseType_t x;
uint32_t ulNextValue = 0;
char cString[ 15 ];
size_t xStringLength;
( void ) pvParameters;
for( ;; )
sprintf( cString, "%lu", ( unsigned long ) ulNextValue );
xStringLength = strlen( cString );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
while( xMessageBufferSend( 	xDataMessageBuffers[ x ],
( void * ) cString,
xStringLength,
portMAX_DELAY ) != xStringLength );
ulNextValue++;
void vGenerateM7ToM4Interrupt( void * xUpdatedMessageBuffer )
MessageBufferHandle_t xUpdatedBuffer = ( MessageBufferHandle_t ) xUpdatedMessageBuffer;
if( xUpdatedBuffer != xControlMessageBuffer )
while( xMessageBufferSend( xControlMessageBuffer, &xUpdatedBuffer, sizeof( xUpdatedBuffer ), mbaDONT_BLOCK ) != sizeof( xUpdatedBuffer ) )
HAL_EXTI_D1_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, DISABLE );
HAL_EXTI_D2_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, ENABLE );
HAL_EXTI_GenerateSWInterrupt( EXTI_LINE0 );
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, uint32_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
static StaticTask_t xIdleTaskTCB;
static uint32_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];
*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
*ppxIdleTaskStackBuffer = uxIdleTaskStack;
*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
static void prvWaitForOtherCoreToStart( uint32_t ulIndexToTest, uint32_t ulIndexToIncrement )
volatile uint32_t ulInitialCount = ulStartSyncCounters[ ulIndexToTest ], x;
const uint32_t ulCrudeLoopDelay = 0xfffffUL;
while( ulStartSyncCounters[ ulIndexToTest ] == ulInitialCount );
ulInitialCount = ulStartSyncCounters[ ulIndexToTest ];
for( ;; )
ulStartSyncCounters[ ulIndexToIncrement ]++;
if( ulStartSyncCounters[ ulIndexToTest ] != ulInitialCount )
ulStartSyncCounters[ ulIndexToIncrement ]++;
break;
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_Off( LED2 );
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_On( LED2 );
void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
uint32_t x;
configASSERT( xM7AMPTask );
HAL_EXTI_D1_ClearFlag( EXTI_LINE1 );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xMessageBufferReceiveCompletedFromISR( xDataMessageBuffers[ x ], &xHigherPriorityTaskWoken );
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
static void prvSetupHardware( void )
MPU_Region_InitTypeDef MPU_InitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = D3_SRAM_BASE;
MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
SCB_EnableICache();
SCB_EnableDCache();
HAL_Init();
BSP_LED_Init(LED1);
HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while( !__HAL_PWR_GET_FLAG( PWR_FLAG_VOSRDY ) )
__asm volatile ( "NOP" );
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 160;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLQ = 4;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
configASSERT( HAL_RCC_OscConfig( &RCC_OscInitStruct ) == HAL_OK );
RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \\
RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1 );
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
configASSERT( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_4 ) == HAL_OK );
HAL_EXTI_EdgeConfig( EXTI_LINE0, EXTI_RISING_EDGE );
HAL_NVIC_SetPriority( EXTI1_IRQn, 0xFU, 0U );
HAL_NVIC_EnableIRQ( EXTI1_IRQn );
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_SYSCLK, RCC_MCODIV_1);
while (1)
if(SwitchClock != RESET)
SwitchSystemClock();
BSP_LED_Toggle(LED2);
HAL_Delay(100);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == USER_BUTTON_PIN)
SwitchClock = SET;
static void SwitchSystemClock(void)
if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)
SystemClockMSI_Config();
else if (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
SystemClockHSI_Config();
SwitchClock = RESET;
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
while(1);
static void SystemClockHSI_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitStruct.ClockType       = RCC_CLOCKTYPE_SYSCLK;
RCC_ClkInitStruct.SYSCLKSource    = RCC_SYSCLKSOURCE_MSI;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType    = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState          = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue  = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState      = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource     = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM          = 2;
RCC_OscInitStruct.PLL.PLLN          = 20;
RCC_OscInitStruct.PLL.PLLP          = 7;
RCC_OscInitStruct.PLL.PLLQ          = 4;
RCC_OscInitStruct.PLL.PLLR          = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType       = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource    = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider   = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider  = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider  = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType  = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState        = RCC_MSI_OFF;
RCC_OscInitStruct.PLL.PLLState    = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
static void SystemClockMSI_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitStruct.ClockType       = RCC_CLOCKTYPE_SYSCLK;
RCC_ClkInitStruct.SYSCLKSource    = RCC_SYSCLKSOURCE_HSI;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState            = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange       = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM            = 1;
RCC_OscInitStruct.PLL.PLLN            = 40;
RCC_OscInitStruct.PLL.PLLP            = 7;
RCC_OscInitStruct.PLL.PLLQ            = 4;
RCC_OscInitStruct.PLL.PLLR            = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType       = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource    = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider   = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider  = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider  = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState        = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState    = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED2);
while (1)
void assert_failed(char *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
while (1)
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_SET);
HAL_Delay(500);
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_0,GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_1,GPIO_PIN_RESET);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
osThreadStaticDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128, defaultTaskBuffer, &defaultTaskControlBlock);
defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);
if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_2)
Error_Handler();
LL_RCC_HSE_EnableBypass();
LL_RCC_HSE_Enable();
while(LL_RCC_HSE_IsReady() != 1)
LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_3);
LL_RCC_PLL_Enable();
while(LL_RCC_PLL_IsReady() != 1)
LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);
LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
LL_Init1msTick(72000000);
LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
LL_SetSystemCoreClock(72000000);
LL_RCC_ConfigMCO(LL_RCC_MCO1SOURCE_PLLCLK_DIV_2);
LL_RCC_SetUSBClockSource(LL_RCC_USB_CLKSOURCE_PLL_DIV_1_5);
NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));
static void MX_GPIO_Init(void)
LL_GPIO_InitTypeDef GPIO_InitStruct;
LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOA);
LL_APB2_GRP1_EnableClock(LL_APB2_GRP1_PERIPH_GPIOB);
GPIO_InitStruct.Pin = LL_GPIO_PIN_8;
GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void StartDefaultTask(void const * argument)
MX_USB_DEVICE_Init();
for(;;)
osDelay(1);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM7) {
HAL_IncTick();
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
HAL_FLASH_Unlock();
EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
EraseInitStruct.PageAddress = FLASH_USER_START_ADDR;
EraseInitStruct.NbPages     = (FLASH_USER_END_ADDR - FLASH_USER_START_ADDR) / FLASH_PAGE_SIZE;
if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
while (1)
BSP_LED_On(LED3);
HAL_Delay(100);
BSP_LED_Off(LED3);
HAL_Delay(2000);
Address = FLASH_USER_START_ADDR;
while (Address < FLASH_USER_END_ADDR)
if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, DATA_32) == HAL_OK)
Address = Address + 4;
else
while (1)
BSP_LED_On(LED3);
HAL_Delay(100);
BSP_LED_Off(LED3);
HAL_Delay(2000);
HAL_FLASH_Lock();
Address = FLASH_USER_START_ADDR;
MemoryProgramStatus = 0x0;
while (Address < FLASH_USER_END_ADDR)
data32 = *(__IO uint32_t *)Address;
if (data32 != DATA_32)
MemoryProgramStatus++;
Address = Address + 4;
if (MemoryProgramStatus == 0)
BSP_LED_On(LED3);
else
while (1)
BSP_LED_On(LED3);
HAL_Delay(1000);
BSP_LED_Off(LED3);
HAL_Delay(1000);
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void set_led_state(bool level)
if (level)
printf("LED is turned ON\\r\\n");
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);
else
printf("LED is turned OFF\\r\\n");
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
static void telemetry_thread_entry(ULONG parameter)
NX_PACKET* packet_ptr;
ULONG events;
lps22hb_t lps22hb_data;
hts221_data_t hts221_data;
lsm6dsl_data_t lsm6dsl_data;
lis2mdl_data_t lis2mdl_data;
NX_PARAMETER_NOT_USED(parameter);
while (true)
lps22hb_data = lps22hb_data_read();
hts221_data  = hts221_data_read();
lsm6dsl_data = lsm6dsl_data_read();
lis2mdl_data = lis2mdl_data_read();
nx_azure_iot_hub_client_telemetry_message_create(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER);
azure_iot_nx_client_publish_float_telemetry(
&azure_iot_nx_client, "temperature", lps22hb_data.temperature_degC, packet_ptr);
nx_azure_iot_hub_client_telemetry_message_create(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER);
azure_iot_nx_client_publish_float_telemetry(
&azure_iot_nx_client, "pressure", lps22hb_data.pressure_hPa, packet_ptr);
nx_azure_iot_hub_client_telemetry_message_create(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER);
azure_iot_nx_client_publish_float_telemetry(
&azure_iot_nx_client, "humidityPercentage", hts221_data.humidity_perc, packet_ptr);
nx_azure_iot_hub_client_telemetry_message_create(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER);
azure_iot_nx_client_publish_float_telemetry(
&azure_iot_nx_client, "acceleration", lsm6dsl_data.acceleration_mg[0], packet_ptr);
nx_azure_iot_hub_client_telemetry_message_create(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER);
azure_iot_nx_client_publish_float_telemetry(
&azure_iot_nx_client, "magnetic", lis2mdl_data.magnetic_mG[0], packet_ptr);
tx_event_flags_get(
&azure_iot_flags, TELEMETRY_INTERVAL_EVENT, TX_OR_CLEAR, &events, telemetry_interval * NX_IP_PERIODIC_RATE);
static void device_twin_thread_entry(ULONG parameter)
NX_PACKET* packet_ptr;
UINT status;
jsmn_parser parser;
jsmntok_t tokens[64];
INT token_count;
NX_PARAMETER_NOT_USED(parameter);
if ((status = nx_azure_iot_hub_client_device_twin_properties_request(
&azure_iot_nx_client.iothub_client, NX_WAIT_FOREVER)))
printf("device twin document request failed!: error code = 0x%08x\\r\\n", status);
return;
if ((status = nx_azure_iot_hub_client_device_twin_properties_receive(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER)))
printf("device twin document receive failed!: error code = 0x%08x\\r\\n", status);
return;
while (true)
printf("Receive device twin properties: ");
printf_packet(packet_ptr);
const CHAR* json_str = (CHAR*)packet_ptr->nx_packet_prepend_ptr;
const ULONG json_len = packet_ptr->nx_packet_append_ptr - packet_ptr->nx_packet_prepend_ptr;
jsmn_init(&parser);
token_count = jsmn_parse(&parser, json_str, json_len, tokens, 64);
if (findJsonInt(json_str, tokens, token_count, "telemetryInterval", &telemetry_interval))
tx_event_flags_set(&azure_iot_flags, TELEMETRY_INTERVAL_EVENT, TX_OR);
nx_packet_release(packet_ptr);
if ((status = nx_azure_iot_hub_client_device_twin_desired_properties_receive(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER)))
printf("Receive desired property receive failed!: error code = 0x%08x\\r\\n", status);
break;
static void direct_method_thread_entry(ULONG parameter)
UINT status;
NX_PACKET* packet_ptr;
UCHAR* method_name_ptr;
USHORT method_name_length;
VOID* context_ptr;
USHORT context_length;
CHAR* payload_ptr;
USHORT payload_length;
UINT http_status;
CHAR* http_response = "{}";
NX_PARAMETER_NOT_USED(parameter);
while (true)
http_status = 501;
if ((status = nx_azure_iot_hub_client_direct_method_message_receive(&azure_iot_nx_client.iothub_client,
&method_name_ptr,
&method_name_length,
&context_ptr,
&context_length,
&packet_ptr,
NX_WAIT_FOREVER)))
printf("Direct method receive failed!: error code = 0x%08x\\r\\n", status);
break;
printf("Receive method call: %.*s, with payload: ", (INT)method_name_length, (CHAR*)method_name_ptr);
printf_packet(packet_ptr);
payload_ptr    = (CHAR*)packet_ptr->nx_packet_prepend_ptr;
payload_length = packet_ptr->nx_packet_append_ptr - packet_ptr->nx_packet_prepend_ptr;
if (strncmp((CHAR*)method_name_ptr, "setLedState", method_name_length) == 0)
bool arg = (strncmp(payload_ptr, "true", payload_length) == 0);
set_led_state(arg);
azure_iot_nx_client_publish_bool_property(&azure_iot_nx_client, "ledState", arg);
http_status = 200;
if ((status = nx_azure_iot_hub_client_direct_method_message_response(&azure_iot_nx_client.iothub_client,
http_status,
context_ptr,
context_length,
(UCHAR*)http_response,
strlen(http_response),
NX_WAIT_FOREVER)))
printf("Direct method response failed!: error code = 0x%08x\\r\\n", status);
break;
nx_packet_release(packet_ptr);
static void c2d_thread_entry(ULONG parameter)
NX_PACKET* packet_ptr;
UINT status;
NX_PARAMETER_NOT_USED(parameter);
while (true)
if ((status = nx_azure_iot_hub_client_cloud_message_receive(
&azure_iot_nx_client.iothub_client, &packet_ptr, NX_WAIT_FOREVER)))
printf("C2D receive failed!: error code = 0x%08x\\r\\n", status);
break;
printf("Receive message: ");
printf_packet(packet_ptr);
nx_packet_release(packet_ptr);
UINT azure_iot_nx_client_entry(
NX_IP* ip_ptr, NX_PACKET_POOL* pool_ptr, NX_DNS* dns_ptr, UINT (*unix_time_callback)(ULONG* unix_time))
UINT status;
if ((status = tx_event_flags_create(&azure_iot_flags, "Azure IoT flags")))
printf("FAIL: Unable to create nx_client event flags (0x%02x)\\r\\n", status);
return status;
if ((status = azure_iot_nx_client_create(&azure_iot_nx_client,
ip_ptr,
pool_ptr,
dns_ptr,
unix_time_callback,
IOT_HUB_HOSTNAME,
IOT_DEVICE_ID,
IOT_PRIMARY_KEY)))
printf("ERROR: failed to create iot client 0x%08x\\r\\n", status);
return status;
azure_iot_nx_client_enable_telemetry(&azure_iot_nx_client, telemetry_thread_entry);
azure_iot_nx_client_enable_device_twin(&azure_iot_nx_client, device_twin_thread_entry);
azure_iot_nx_client_enable_direct_method(&azure_iot_nx_client, direct_method_thread_entry);
azure_iot_nx_client_enable_c2d(&azure_iot_nx_client, c2d_thread_entry);
if ((status = azure_iot_nx_client_connect(&azure_iot_nx_client)))
printf("ERROR: failed to connect iot client 0x%08x\\r\\n", status);
return status;
while (true)
tx_thread_sleep(NX_IP_PERIODIC_RATE);
return NX_SUCCESS;
int main(void)
pFunction JumpToApplication;
uint32_t JumpAddress;
HAL_Init();
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_ORANGE);
BSP_LED_Init(LED_RED);
BSP_LED_Init(LED_BLUE);
SystemClock_Config();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
if (BSP_PB_GetState(BUTTON_KEY) == GPIO_PIN_RESET)
if (((*(__IO uint32_t*)USBD_DFU_APP_DEFAULT_ADD) & 0x2FFE0000 ) == 0x20000000)
JumpAddress = *(__IO uint32_t*) (USBD_DFU_APP_DEFAULT_ADD + 4);
JumpToApplication = (pFunction) JumpAddress;
__set_MSP(*(__IO uint32_t*) USBD_DFU_APP_DEFAULT_ADD);
JumpToApplication();
USBD_Init(&USBD_Device, &DFU_Desc, 0);
USBD_RegisterClass(&USBD_Device, &USBD_DFU);
USBD_DFU_RegisterMedia(&USBD_Device, &USBD_DFU_Flash_fops);
USBD_Start(&USBD_Device);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct ={0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct = {0};
static RCC_CRSInitTypeDef RCC_CRSInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
__HAL_RCC_PWR_CLK_DISABLE();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_HSI48;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);
__HAL_RCC_CRS_CLK_ENABLE();
RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
RCC_CRSInitStruct.ReloadValue =  __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000, 1000);
RCC_CRSInitStruct.ErrorLimitValue = RCC_CRS_ERRORLIMIT_DEFAULT;
RCC_CRSInitStruct.HSI48CalibrationValue = 0x20;
HAL_RCCEx_CRSConfig (&RCC_CRSInitStruct);
RCC_OscInitStruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState        = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLState    = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLMUL      = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PLLDIV      = RCC_PLL_DIV3;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1)!= HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED_RED);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
MPU_Config();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LED_On(LED1);
BSP_LED_On(LED3);
if (SysTick_Config(SystemCoreClock / 1000))
while (1)
{}
while (1)
BSP_LED_Toggle(LED2);
BSP_LED_Toggle(LED4);
HAL_Delay(50);
BSP_LED_Toggle(LED1);
BSP_LED_Toggle(LED3);
HAL_Delay(100);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main (void)
HAL_Init ();
SystemClock_Config ();
MX_GPIO_Init ();
MX_FMC_Init ();
MX_USART1_UART_Init ();
printf ("Start\\r\\n");
temp.Plane = 0;
temp.Block = 0;
temp.Page = 0;
uint32_t error = 0;
int i = 0;
int j = 0;
int t = 0;
uint32_t n = 0;
uint32_t m = 0;
uint32_t x1 = 0;
uint32_t y1 = 0;
uint32_t temp_time = 0;
uint32_t temp_time2 = 0;
uint32_t write_time = 0;
uint32_t read_time = 0;
uint32_t erase_time = 0;
HAL_NAND_Reset (&hnand2);
HAL_Delay (500);
HAL_NAND_Read_ID (&hnand2, &id);
printf ("1.HAL_id = 0x%X\\r\\n", *((unsigned int*) &id));
temp.Plane = 0;
temp.Block = 0;
temp.Page = 0;
erase_time = HAL_GetTick();
for (uint8_t block_temp = 0; block_temp < TOTAL_BLOCK_NUM; block_temp++)
temp.Block = block_temp;
HAL_NAND_Erase_Block (&hnand2, &temp);
temp_time = HAL_GetTick() ;
erase_time = temp_time - erase_time;
for (i = 0; i < TOTAL_PAGE_NUM; i++)
for (j = 0; j < 40; j++)
for (t = 0; t < 12; t++)
x1 = n % IMG_WIDTH;
y1 = n / IMG_WIDTH;
page_buf_1[j][t] = pos[t][0] + x1 + 1024 * (pos[t][1] + y1);
n++;
temp.Block = i / 64;
temp.Page = i % 64;
temp.Plane = 0;
HAL_NAND_Write_Page_8b (&hnand2, &temp, page_buf_1, 1);
temp_time2 = HAL_GetTick() ;
write_time = temp_time2 - temp_time;
n = 0;
for (i = 0; i < 54; i++)
HAL_NAND_Read_Page_8b (&hnand2, &temp, page_buf_4, 20);
m = 0;
temp_time = HAL_GetTick() ;
read_time = temp_time - temp_time2;
printf ("Done , error= %d \\r\\n", error);
printf ("erase_time : %d  \\r\\n", erase_time);
printf ("write_time : %d  \\r\\n", write_time);
printf ("read_time : %d  \\r\\n", read_time);
while (1);
while (1)
void SystemClock_Config (void)
RCC_OscInitTypeDef RCC_OscInitStruct = { 0 };
RCC_ClkInitTypeDef RCC_ClkInitStruct = { 0 };
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 15;
RCC_OscInitStruct.PLL.PLLN = 216;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig (&RCC_OscInitStruct) != HAL_OK)
Error_Handler ();
if (HAL_PWREx_EnableOverDrive () != HAL_OK)
Error_Handler ();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig (&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler ();
void Error_Handler (void)
void assert_failed(uint8_t *file, uint32_t line)
static void SFU_TEST_Protection(void)
uint32_t test_idx;
uint32_t flashErrCode = 0;
uint64_t pattern = 0U;
uint32_t page_error = 0U;
FLASH_EraseInitTypeDef p_erase_init;
TestStatus status = TEST_IN_PROGRESS;
__IO uint8_t tmp;
void (*func)(void);
do
HAL_Delay(100);
test_idx = HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1);
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, (test_idx + 1));
printf("\\r\\n= [TEST] %s @ %s %08x", aTestOperation[aProtectTests[test_idx].type], aProtectTests[test_idx].msg,
aProtectTests[test_idx].address);
if ((aProtectTests[test_idx].address != 0U) && (aProtectTests[test_idx].address < 0xFFFFFF00U)
&& (aProtectTests[test_idx].address > 0x00000FFFU))
switch (aProtectTests[test_idx].type)
case TEST_WRITE_FLASH :
HAL_FLASH_Unlock();
HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, aProtectTests[test_idx].address, pattern);
HAL_FLASH_Lock();
flashErrCode = HAL_FLASH_GetError();
printf("\\r\\nflash error code: %x", flashErrCode);
if ((flashErrCode & HAL_FLASH_ERROR_WRP) == 0U)
status = TEST_ERROR;
if (0 == strncmp("OBs @", (const char *)aProtectTests[test_idx].msg, 5))
status = TEST_ERROR;
break;
case TEST_READ_FLASH :
tmp = *(uint8_t *)(aProtectTests[test_idx].address);
HAL_Delay(1);
if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_RDERR) == 0)
printf(" value : %d", tmp);
status = TEST_ERROR;
__HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_RDERR);
if (0 == strncmp("Isolated", (const char *)aProtectTests[test_idx].msg, 8))
status = TEST_ERROR;
break;
case TEST_ERASE_FLASH :
HAL_FLASH_Unlock();
p_erase_init.TypeErase   = FLASH_TYPEERASE_PAGES;
p_erase_init.Page        = SFU_LL_FLASH_GetPage(aProtectTests[test_idx].address);
p_erase_init.NbPages     = 1;
HAL_FLASHEx_Erase(&p_erase_init, &page_error);
HAL_FLASH_Lock();
if ((HAL_FLASH_GetError() & HAL_FLASH_ERROR_WRP) == 0U)
status = TEST_ERROR;
break;
case TEST_WRITE_RAM :
*(uint32_t *)aProtectTests[test_idx].address = 0x00000000;
status = TEST_ERROR;
break;
case TEST_READ_RAM :
tmp = *(uint8_t *)aProtectTests[test_idx].address;
printf(" value : %d ", tmp);
status = TEST_ERROR;
break;
case TEST_EXECUTE :
func = (void(*)(void))(aProtectTests[test_idx].address);
func();
status = TEST_ERROR;
break;
case TEST_END :
status = TEST_COMPLETED;
break;
default :
break;
} while (status == TEST_IN_PROGRESS) ;
if (status == TEST_ERROR)
SFU_TEST_Error();
else if (status == TEST_COMPLETED)
printf("\\b\\b\\b\\b\\b\\b\\b\\b");
printf("\\r\\nYou can RESET the platform to restart the tests.\\r\\n");
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_DONE);
void SFU_TEST_Init(void)
if (MAGIC_TEST_DONE == HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR0))
return;
else if (MAGIC_TEST_INIT != HAL_RTCEx_BKUPRead(&RtcHandle,
RTC_BKP_DR0))
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_INIT);
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x0000);
SFU_TEST_Protection();
void SFU_TEST_Reset(void)
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_INIT);
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x0000);
void SFU_TEST_Error(void)
printf(" ===> KO!!!!!");
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR0, MAGIC_TEST_DONE);
void lis3de_freefall(void)
stmdev_ctx_t dev_ctx;
lis3de_ctrl_reg3_t ctrl_reg3;
lis3de_ig1_cfg_t ig1_cfg;
uint8_t whoamI;
dev_ctx.write_reg = platform_write;
dev_ctx.read_reg = platform_read;
dev_ctx.handle = &SENSOR_BUS;
whoamI = 0;
lis3de_device_id_get(&dev_ctx, &whoamI);
if (whoamI != LIS3DE_ID)
while (1);
lis3de_data_rate_set(&dev_ctx, LIS3DE_ODR_100Hz);
lis3de_full_scale_set(&dev_ctx, LIS3DE_2g);
memset((uint8_t *)&ctrl_reg3, 0, sizeof(ctrl_reg3));
ctrl_reg3.int1_ig1 = PROPERTY_ENABLE;
lis3de_pin_int1_config_set(&dev_ctx, &ctrl_reg3);
lis3de_int1_pin_notification_mode_set(&dev_ctx, LIS3DE_INT1_LATCHED);
lis3de_int1_gen_threshold_set(&dev_ctx, 0x16);
lis3de_int1_gen_duration_set(&dev_ctx, 0x03);
memset((uint8_t *)&ig1_cfg, 0, sizeof(ig1_cfg));
ig1_cfg.aoi = PROPERTY_ENABLE;
ig1_cfg.zlie = PROPERTY_ENABLE;
ig1_cfg.ylie = PROPERTY_ENABLE;
ig1_cfg.xlie = PROPERTY_ENABLE;
lis3de_int1_gen_conf_set(&dev_ctx, &ig1_cfg);
lis3de_operating_mode_set(&dev_ctx, LIS3DE_LP);
while (1) {
lis3de_ig1_source_t src;
if (platform_reap_int_pin()) {
lis3de_int1_gen_source_get(&dev_ctx, &src);
sprintf((char *)tx_buffer, "freefall detected\\r\\n");
tx_com(tx_buffer, strlen((char const *)tx_buffer));
static int32_t platform_write(void *handle, uint8_t reg,
uint8_t *bufp,
uint16_t len)
reg |= 0x80;
HAL_I2C_Mem_Write(handle, LIS3DE_I2C_ADD_L, reg,
I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
reg |= 0x40;
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &reg, 1, 1000);
HAL_SPI_Transmit(handle, bufp, len, 1000);
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_SET);
reg |= 0x80;
i2c_lld_write(handle,  LIS3DE_I2C_ADD_L & 0xFE, reg, bufp, len);
return 0;
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
uint16_t len)
reg |= 0x80;
HAL_I2C_Mem_Read(handle, LIS3DE_I2C_ADD_L, reg,
I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
reg |= 0xC0;
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &reg, 1, 1000);
HAL_SPI_Receive(handle, bufp, len, 1000);
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_SET);
reg |= 0x80;
i2c_lld_read(handle, LIS3DE_I2C_ADD_L & 0xFE, reg, bufp, len);
return 0;
static void tx_com(uint8_t *tx_buffer, uint16_t len)
HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
CDC_Transmit_FS(tx_buffer, len);
sd_lld_write(&SD2, tx_buffer, len);
static void platform_delay(uint32_t ms)
HAL_Delay(ms);
osalThreadDelayMilliseconds(ms);
static void platform_init(void)
TIM3->CCR1 = PWM_3V3;
TIM3->CCR2 = PWM_3V3;
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
HAL_Delay(1000);
static int32_t platform_reap_int_pin(void)
return HAL_GPIO_ReadPin(LIS3DE_INT1_GPIO_PORT, LIS3DE_INT1_PIN);
return 0;
void SystemInit(void)
SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));
RCC->CR |= (uint32_t)0x00000001;
RCC->CFGR = 0x00000000;
RCC->CR &= (uint32_t)0xFEF6FFFF;
RCC->PLLCFGR = 0x24003010;
RCC->CR &= (uint32_t)0xFFFBFFFF;
RCC->CIR = 0x00000000;
SystemInit_ExtMemCtl();
SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET;
SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET;
void SetSysClock(void)
if (SetSysClock_PLL_HSE(1) == 0)
if (SetSysClock_PLL_HSE(0) == 0)
if (SetSysClock_PLL_HSI() == 0) {
while(1) {
uint8_t SetSysClock_PLL_HSE(uint8_t bypass)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSE;
if (bypass == 0) {
RCC_OscInitStruct.HSEState          = RCC_HSE_ON;
} else {
RCC_OscInitStruct.HSEState          = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM            = 13;
RCC_OscInitStruct.PLL.PLLN            = 192;
RCC_OscInitStruct.PLL.PLLP            = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ            = 8;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
return 0;
RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) {
return 0;
return 1;
uint8_t SetSysClock_PLL_HSI(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
RCC_OscInitStruct.HSEState            = RCC_HSE_OFF;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM            = 8;
RCC_OscInitStruct.PLL.PLLN            = 200;
RCC_OscInitStruct.PLL.PLLP            = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ            = 9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
return 0;
RCC_ClkInitStruct.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider  = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) {
return 0;
return 1;
void HardFault_Handler(void)
printf("Hard Fault\\n");
NVIC_SystemReset();
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART3_UART_Init();
while (1)
HAL_UART_Transmit(&huart3, "Hello from the board\\n\\r", 24, 100);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
void _Error_Handler(char * file, int line)
while(1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_CRSInitTypeDef RCC_CRSInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
__HAL_RCC_CRS_CLK_ENABLE();
RCC_CRSInitStruct.Prescaler = RCC_CRS_SYNC_DIV1;
RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;
RCC_CRSInitStruct.Polarity = RCC_CRS_SYNC_POLARITY_RISING;
RCC_CRSInitStruct.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE(48000000,1000);
RCC_CRSInitStruct.ErrorLimitValue = 34;
RCC_CRSInitStruct.HSI48CalibrationValue = 32;
HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
int main(void)
uint8_t prev_ser_state;
HAL_Init();
SystemClock_Config();
setup_usart();
init_printf(0,usart_putc);
printf("\\n\\n\\rf042_usb_spi\\n\\r");
printf("\\n");
printf("SYSCLK = %d\\n\\r", HAL_RCC_GetSysClockFreq());
printf("\\n");
tim_init();
printf("Microsecond timer initialized\\n\\r");
led_init();
printf("LED initialized\\n\\r");
spi_init();
printf("SPI initialized\\n\\r");
usb_init();
printf("USB initialized\\n\\r");
prev_ser_state = ser_state;
printf("Looping\\n\\r");
while (1)
if(prev_ser_state != ser_state)
prev_ser_state = ser_state;
printf("State = %d, err = %d\\n\\r", prev_ser_state, ser_err);
if(prev_ser_state)
led_on(LED1);
else
led_off(LED1);
void SysTick_Handler(void)
HAL_IncTick();
HAL_SYSTICK_IRQHandler();
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
ADC_ChannelConfTypeDef sConfig;
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
AdcHandle.Instance                   = ADCx;
AdcHandle.Init.ClockPrescaler        = ADC_CLOCKPRESCALER_PCLK_DIV4;
AdcHandle.Init.Resolution            = ADC_RESOLUTION_12B;
AdcHandle.Init.ScanConvMode          = DISABLE;
AdcHandle.Init.ContinuousConvMode    = ENABLE;
AdcHandle.Init.DiscontinuousConvMode = DISABLE;
AdcHandle.Init.NbrOfDiscConversion   = 0;
AdcHandle.Init.ExternalTrigConvEdge  = ADC_EXTERNALTRIGCONVEDGE_NONE;
AdcHandle.Init.ExternalTrigConv      = ADC_EXTERNALTRIGCONV_T1_CC1;
AdcHandle.Init.DataAlign             = ADC_DATAALIGN_RIGHT;
AdcHandle.Init.NbrOfConversion       = 1;
AdcHandle.Init.DMAContinuousRequests = DISABLE;
AdcHandle.Init.EOCSelection          = DISABLE;
if (HAL_ADC_Init(&AdcHandle) != HAL_OK)
Error_Handler();
sConfig.Channel      = ADC_CHANNEL_10;
sConfig.Rank         = 1;
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;
sConfig.Offset       = 0;
if (HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK)
Error_Handler();
if (HAL_ADC_Start_IT(&AdcHandle) != HAL_OK)
Error_Handler();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED2);
while (1)
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle)
uhADCxConvertedValue = HAL_ADC_GetValue(AdcHandle);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_AES_Init();
MX_I2C1_Init();
MX_SPI1_Init();
while (1)
void SystemClock_Config(void)
LL_FLASH_SetLatency(LL_FLASH_LATENCY_0);
if(LL_FLASH_GetLatency() != LL_FLASH_LATENCY_0)
Error_Handler();
LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);
LL_RCC_MSI_Enable();
while(LL_RCC_MSI_IsReady() != 1)
LL_RCC_MSI_SetRange(LL_RCC_MSIRANGE_5);
LL_RCC_MSI_SetCalibTrimming(0);
LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);
LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_1);
LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_MSI);
while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_MSI)
LL_Init1msTick(2097000);
LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);
LL_SetSystemCoreClock(2097000);
LL_RCC_SetI2CClockSource(LL_RCC_I2C1_CLKSOURCE_PCLK1);
NVIC_SetPriority(SysTick_IRQn, 0);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if(htim->Instance == TIM3)
SoftUartHandler();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin==GPIO_PIN_10)
SoftUartRxHelper(0);
else if(GPIO_Pin==GPIO_PIN_1)
SoftUartRxHelper(1);
uint8_t getchar(uint8_t SoftUartNumber)
uint8_t ch;
while(SoftUartRxAlavailable(SoftUartNumber)==0);
SoftUartReadRxBuffer(SoftUartNumber,&ch,1);
return ch;
int main(void)
uint8_t ch;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM3_Init();
HAL_TIM_Base_Start_IT(&htim3);
SoftUartInit(0,SU_TX_GPIO_Port,SU_TX_Pin,SU_RX_GPIO_Port,SU_RX_Pin);
SoftUartInit(1,SU2_TX_GPIO_Port,SU2_TX_Pin,SU2_RX_GPIO_Port,SU2_RX_Pin);
SoftUartEnableRx(0);
SoftUartEnableRx(1);
while (1)
ch=getchar(1);
SoftUartPuts(1,&ch,1);
SoftUartWaitUntilTxComplate(0);
HAL_GPIO_TogglePin(LED_GPIO_Port,LED_Pin);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL4;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_TIM3_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim3.Instance = TIM3;
htim3.Init.Prescaler = 15;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 103;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, SU2_TX_Pin|SU_TX_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SU2_TX_Pin|SU_TX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SU2_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(SU2_RX_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SU_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(SU_RX_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int fputc(int ch, FILE *f)
HAL_UART_Transmit(&huart1, (unsigned char *)&ch, 1, 100);
return ch;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_SPI1_Init();
MX_I2C1_Init();
MX_IWDG_Init();
printf("duckypad V2\\ndekuNukem 2020\\n");
osThreadDef(kb_scan, kb_scan_task, osPriorityNormal, 0, 256);
kb_scanHandle = osThreadCreate(osThread(kb_scan), NULL);
osThreadDef(keypress_task, keypress_task_start, osPriorityAboveNormal, 0, 512);
osThreadCreate(osThread(keypress_task), NULL);
osThreadDef(animation_task, animation_task_start, osPriorityBelowNormal, 0, 256);
osThreadCreate(osThread(animation_task), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI48
|RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL5;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_SYSCLK;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 3, 0);
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.Timing = 0x0000020B;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_IWDG_Init(void)
hiwdg.Instance = IWDG;
hiwdg.Init.Prescaler = IWDG_PRESCALER_32;
hiwdg.Init.Window = 4095;
hiwdg.Init.Reload = 4095;
if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_4;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_HalfDuplex_Init(&huart1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, OLED_RESET_Pin|LED_DATA_EN_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(SD_CS_GPIO_Port, SD_CS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = SW11_Pin|SW12_Pin|SW13_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SW14_Pin|SW15_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OLED_RESET_Pin|LED_DATA_EN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BUTTON_1_Pin|BUTTON_2_Pin|SW4_Pin|SW5_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CARD_DETECT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING_FALLING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(CARD_DETECT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SD_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(SD_CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SW1_Pin|SW2_Pin|SW3_Pin|SW6_Pin
|SW7_Pin|SW8_Pin|SW9_Pin|SW10_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI4_15_IRQn, 3, 0);
HAL_NVIC_EnableIRQ(EXTI4_15_IRQn);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
HAL_Delay(200);
NVIC_SystemReset();
void kb_scan_task(void const * argument)
MX_FATFS_Init();
MX_USB_DEVICE_Init();
neopixel_off();
mount_result = f_mount(&sd_fs, "", 1);
HAL_GPIO_WritePin(OLED_RESET_GPIO_Port, OLED_RESET_Pin, GPIO_PIN_RESET);
osDelay(10);
HAL_GPIO_WritePin(OLED_RESET_GPIO_Port, OLED_RESET_Pin, GPIO_PIN_SET);
osDelay(20);
ssd1306_Init();
ssd1306_Fill(Black);
if(mount_result)
ssd1306_Fill(Black);
ssd1306_SetCursor(0, 5);
ssd1306_WriteString("Please Insert SD Card",Font_6x10,White);
memset(temp_buf, 0, PATH_SIZE);
sprintf(temp_buf, "FW V%d.%d.%d", fw_version_major, fw_version_minor, fw_version_patch);
ssd1306_SetCursor(35, 52);
ssd1306_WriteString(temp_buf,Font_6x10,White);
ssd1306_SetCursor(0, 22);
ssd1306_WriteString(instruction,Font_6x10,White);
ssd1306_SetCursor(18, 35);
ssd1306_WriteString(project_url,Font_6x10,White);
ssd1306_UpdateScreen();
while(1)
HAL_IWDG_Refresh(&hiwdg);
osDelay(30);
load_settings();
scan_profiles();
uint8_t last_profile = get_last_profile();
if(last_profile == 0)
change_profile(NEXT_PROFILE);
else
restore_profile(last_profile, 1, 1);
init_complete = 1;
for(;;)
HAL_IWDG_Refresh(&hiwdg);
keyboard_update();
osDelay(16);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM6) {
HAL_IncTick();
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
TimMasterHandle.Instance = TIM2;
TimSlave1Handle.Instance = TIM3;
TimSlave2Handle.Instance = TIM4;
TimMasterHandle.Init.Period            = 255;
TimMasterHandle.Init.Prescaler         = 0;
TimMasterHandle.Init.ClockDivision     = 0;
TimMasterHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimMasterHandle.Init.RepetitionCounter = 4;
TimMasterHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimMasterHandle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode       = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse = 64;
sOCConfig.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
sOCConfig.OCFastMode   = TIM_OCFAST_DISABLE;
sOCConfig.OCIdleState  = TIM_OCIDLESTATE_RESET;
sOCConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&TimMasterHandle, &sOCConfig, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode     = TIM_MASTERSLAVEMODE_ENABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&TimMasterHandle, &sMasterConfig) != HAL_OK)
Error_Handler();
TimSlave1Handle.Init.Period            = 9;
TimSlave1Handle.Init.Prescaler         = 0;
TimSlave1Handle.Init.ClockDivision     = 0;
TimSlave1Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimSlave1Handle.Init.RepetitionCounter = 0;
TimSlave1Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimSlave1Handle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode     = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse = 3;
if (HAL_TIM_PWM_ConfigChannel(&TimSlave1Handle, &sOCConfig, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode        = TIM_SLAVEMODE_GATED;
sSlaveConfig.InputTrigger     = TIM_TS_ITR1;
sSlaveConfig.TriggerPolarity  = TIM_TRIGGERPOLARITY_NONINVERTED;
sSlaveConfig.TriggerPrescaler = TIM_TRIGGERPRESCALER_DIV1;
sSlaveConfig.TriggerFilter    = 0;
if (HAL_TIM_SlaveConfigSynchronization(&TimSlave1Handle, &sSlaveConfig) != HAL_OK)
Error_Handler();
TimSlave2Handle.Init.Period            = 4;
TimSlave2Handle.Init.Prescaler         = 0;
TimSlave2Handle.Init.ClockDivision     = 0;
TimSlave2Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimSlave2Handle.Init.RepetitionCounter = 0;
TimSlave2Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimSlave2Handle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode     = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse = 3;
if (HAL_TIM_PWM_ConfigChannel(&TimSlave2Handle, &sOCConfig, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode     = TIM_SLAVEMODE_GATED;
sSlaveConfig.InputTrigger  = TIM_TS_ITR1;
if (HAL_TIM_SlaveConfigSynchronization(&TimSlave2Handle, &sSlaveConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimMasterHandle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimSlave1Handle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimSlave2Handle, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
while (1)
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_ICACHE_Init();
MX_GPIO_Init();
MX_LPTIM2_Init();
if (BSP_LED_Init(LED_RED) != BSP_ERROR_NONE)
Error_Handler();
if (BSP_LED_Init(LED_GREEN) != BSP_ERROR_NONE)
Error_Handler();
if (HAL_LPTIM_Counter_Start_IT(&hlptim2, 1000) != HAL_OK)
Error_Handler();
HAL_PWREx_EnterSTOP1Mode(PWR_STOPENTRY_WFI);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_LPTIM2_Init(void)
hlptim2.Instance = LPTIM2;
hlptim2.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
hlptim2.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
hlptim2.Init.UltraLowPowerClock.Polarity = LPTIM_CLOCKPOLARITY_RISING;
hlptim2.Init.UltraLowPowerClock.SampleTime = LPTIM_CLOCKSAMPLETIME_DIRECTTRANSITION;
hlptim2.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
hlptim2.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
hlptim2.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
hlptim2.Init.CounterSource = LPTIM_COUNTERSOURCE_EXTERNAL;
hlptim2.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
hlptim2.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
hlptim2.Init.RepetitionCounter = 0;
if (HAL_LPTIM_Init(&hlptim2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOD_CLK_ENABLE();
void HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim)
if (BSP_LED_Toggle(LED_GREEN) != BSP_ERROR_NONE)
Error_Handler();
void Error_Handler(void)
(void) BSP_LED_On(LED_RED);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
OSThread_start(&blinky1,
&main_blinky1,
stack_blinky1, sizeof(stack_blinky1));
OSThread_start(&blinky2,
&main_blinky2,
stack_blinky2, sizeof(stack_blinky2));
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9|GPIO_PIN_10, GPIO_PIN_SET);
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
void main_blinky1()
while(1)
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, GPIO_PIN_RESET);
HAL_Delay(1000);
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_9, GPIO_PIN_SET);
HAL_Delay(1000);
void main_blinky2()
while(1)
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_10, GPIO_PIN_RESET);
HAL_Delay(500);
HAL_GPIO_WritePin(GPIOF, GPIO_PIN_10, GPIO_PIN_SET);
HAL_Delay(500);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
HAL_Init();
MX_GTZC_S_Init();
MX_GPIO_Init();
MX_ICACHE_Init();
while (SecureExti_IT == 0)  { }
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
HAL_NVIC_DisableIRQ(EXTI13_IRQn);
HAL_EXTI_ConfigLineAttributes(EXTI_LINE_13, EXTI_LINE_NSEC);
NVIC_SetTargetState(EXTI13_IRQn);
HAL_SuspendTick();
NonSecure_Init();
while (1)
static void NonSecure_Init(void)
funcptr_NS NonSecure_ResetHandler;
SCB_NS->VTOR = VTOR_TABLE_NS_START_ADDR;
__TZ_set_MSP_NS((*(uint32_t *)VTOR_TABLE_NS_START_ADDR));
NonSecure_ResetHandler = (funcptr_NS)(*((uint32_t *)((VTOR_TABLE_NS_START_ADDR) + 4U)));
NonSecure_ResetHandler();
static void MX_GTZC_S_Init(void)
MPCBB_ConfigTypeDef MPCBB_NonSecureArea_Desc = {0};
MPCBB_NonSecureArea_Desc.SecureRWIllegalMode = GTZC_MPCBB_SRWILADIS_ENABLE;
MPCBB_NonSecureArea_Desc.InvertSecureState = GTZC_MPCBB_INVSECSTATE_NOT_INVERTED;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[8] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[9] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[10] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[11] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[12] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[13] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[14] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[15] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[16] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[17] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[18] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[19] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[20] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[21] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[22] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[23] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
if (HAL_GTZC_MPCBB_ConfigMem(SRAM1_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
Error_Handler();
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
HAL_EXTI_ConfigLineAttributes(EXTI_LINE_13, EXTI_LINE_SEC);
GPIO_InitStruct.Pin = BUTTON_USER_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BUTTON_USER_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
HAL_GPIO_ConfigPinAttributes(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_NSEC);
HAL_NVIC_SetPriority(EXTI13_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI13_IRQn);
void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == BUTTON_USER_Pin)
SecureExti_IT = 1;
void Error_Handler(void)
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
void net_init(void)
IP_ADDRESS[0] = 192;
IP_ADDRESS[1] = 168;
IP_ADDRESS[2] = 3;
IP_ADDRESS[3] = 200;
NETMASK_ADDRESS[0] = 255;
NETMASK_ADDRESS[1] = 255;
NETMASK_ADDRESS[2] = 255;
NETMASK_ADDRESS[3] = 0;
GATEWAY_ADDRESS[0] = 192;
GATEWAY_ADDRESS[1] = 168;
GATEWAY_ADDRESS[2] = 3;
GATEWAY_ADDRESS[3] = 1;
IP_ADDR4(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
IP_ADDR4(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1], NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
IP_ADDR4(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);
IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1], NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);
IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);
tcpip_init(NULL, NULL);
printf("lwip test init ok.\\n");
(void)ethernetif_api_register(&g_eth_api);
(void)netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);
(void)netif_add(&gnetif, NULL, ethernetif_init, tcpip_input);
netif_create_ip6_linklocal_address(&gnetif, 1);
ip6_addr_t ip6;
err_t ret;
s8_t idx;
ip6_addr_t ipv6_gw;
if (inet_pton(AF_INET6, "2000::2", &ip6) <= 0) {
printf("set source ip6 failed \\n");
return;
ret = netif_add_ip6_address(&gnetif, &ip6, &idx);
if (ret != 0) {
printf("netif_add_ip6_address failed,ret %d\\n", ret);
return;
if (inet_pton(AF_INET6, "2000::1", &ipv6_gw) <= 0) {
printf("inet_pton failed\\n");
return;
set_lwip_ipv6_default_gw(&gnetif, &ipv6_gw);
(void)netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);
netif_set_default(&gnetif);
if (netif_is_link_up(&gnetif)) {
gnetif.flags |= NETIF_FLAG_LINK_UP;
netif_set_up(&gnetif);
} else {
netif_set_down(&gnetif);
uint32_t HAL_GetTick(void)
return (uint32_t)LOS_TickCountGet();
void _Error_Handler(char *file, int line)
while (1) {}
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
_Error_Handler(__FILE__, __LINE__);
if (HAL_PWREx_EnableOverDrive() != HAL_OK) {
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) {
_Error_Handler(__FILE__, __LINE__);
SystemCoreClockUpdate();
void hieth_hw_init(void)
extern void ETH_IRQHandler(void);
(void)LOS_HwiCreate(ETH_IRQn + 16, 1, 0, ETH_IRQHandler, 0);
void atiny_usleep(unsigned long usec)
delayus((uint32_t)usec);
int atiny_random(void *output, size_t len)
return hal_rng_generate_buffer(output, len);
void atiny_reboot(void)
HAL_NVIC_SystemReset();
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART2_UART_Init();
HAL_Delay(1);
printf("Testing Uart:\\r\\n");
HAL_UARTEx_ReceiveToIdle_IT(&huart2, (uint8_t *)aRxBuffer, 20);
__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Stream5_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream5_IRQn);
HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void HAL_UART_RxHalfCpltCallback(UART_HandleTypeDef *huart)
UNUSED(huart);
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
printf("Error Callback...\\r\\n");
void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size)
HAL_UART_Transmit_IT(&huart2, (uint8_t *)aRxBuffer, 20);
HAL_UARTEx_ReceiveToIdle_IT(&huart2, (uint8_t *)aRxBuffer, 20);
__HAL_UART_ENABLE_IT(&huart2, UART_IT_IDLE);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
trace_printf("Hello\\n");
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_TIM_Config(&htim5_gen,TIM_CH1,10,TIM_OC_MODE_TOGGLE);
BSP_TIM_Capture_Config(&htim14_cap,LOW_FREQ,TIM_CAP_BOTH_EDGE);
while (1)
trace_printf("%d\\n\\r",uwFrequency);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
PVD_Config();
while (1)
if (uwToggleOn)
BSP_LED_Toggle(LED3);
HAL_Delay(200);
static void PVD_Config(void)
__HAL_RCC_PWR_CLK_ENABLE();
HAL_NVIC_SetPriority(PVD_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(PVD_IRQn);
sConfigPVD.PVDLevel = PWR_PVDLEVEL_3;
sConfigPVD.Mode = PWR_PVD_MODE_IT_RISING_FALLING;
HAL_PWR_ConfigPVD(&sConfigPVD);
HAL_PWR_EnablePVD();
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
void HAL_PWR_PVDCallback(void)
BSP_LED_On(LED3);
uwToggleOn = (uwToggleOn+1) % 2;
void assert_failed(uint8_t *file, uint32_t line)
Error_Handler();
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
USBD_Init(&USBD_Device, &AUDIO_Desc, 0);
USBD_RegisterClass(&USBD_Device, USBD_AUDIO_CLASS);
USBD_AUDIO_RegisterInterface(&USBD_Device, &USBD_AUDIO_fops);
USBD_Start(&USBD_Device);
while (1)
static void Error_Handler(void)
while(1)
HAL_Delay(50);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
Error_Handler();
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PLLSAI.PLLSAIM = 8;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLSAIP;
ret = HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
if(ret != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
Error_Handler();
void BSP_AUDIO_OUT_ClockConfig(SAI_HandleTypeDef *hsai, uint32_t AudioFreq, void *Params)
RCC_PeriphCLKInitTypeDef RCC_ExCLKInitStruct;
HAL_RCCEx_GetPeriphCLKConfig(&RCC_ExCLKInitStruct);
if((AudioFreq == AUDIO_FREQUENCY_11K) || (AudioFreq == AUDIO_FREQUENCY_22K) || (AudioFreq == AUDIO_FREQUENCY_44K))
RCC_ExCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
RCC_ExCLKInitStruct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SM = 8;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SN = 429;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SQ = 2;
RCC_ExCLKInitStruct.PLLI2SDivQ = 19;
HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct);
else
RCC_ExCLKInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SAI2;
RCC_ExCLKInitStruct.Sai2ClockSelection = RCC_SAI2CLKSOURCE_PLLI2S;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SM = 8;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SN = 344;
RCC_ExCLKInitStruct.PLLI2S.PLLI2SQ = 7;
RCC_ExCLKInitStruct.PLLI2SDivQ = 1;
HAL_RCCEx_PeriphCLKConfig(&RCC_ExCLKInitStruct);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
MX_GPIO_Init();
MX_SPI2_Init();
MX_USART3_UART_Init();
WIFIModuleInit();
WIFIModuleSetWIFIName("Amin");
WIFIModuleSetWIFIPassword("PASSWORD");
MX_NVIC_Init();
__HAL_SPI_ENABLE_IT(&hspi2,SPI_IT_RXNE);
__HAL_SPI_ENABLE(&hspi2);
while (1)
GPIOD->ODR^=1<<13;
HAL_Delay(300);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_NVIC_Init(void)
HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(SPI2_IRQn);
HAL_NVIC_SetPriority(USART3_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(USART3_IRQn);
static void MX_SPI2_Init(void)
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_SLAVE;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_HARD_INPUT;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi2.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi2) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
BSP_LED_Init(LED4);
BSP_LED_Init(LED5);
SystemClock_Config();
MX_ICACHE_Init();
MX_RTC_Init();
BSP_LED_On(LED4);
RTCStatus = 1;
while (1)
RTC_CalendarShow(aShowTime, aShowDate);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSIDiv = RCC_LSI_DIV1;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_RTC_Init(void)
RTC_PrivilegeStateTypeDef privilegeState = {0};
RTC_TimeTypeDef sTime = {0};
RTC_DateTypeDef sDate = {0};
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
hrtc.Init.SynchPrediv = RTC_SYNCH_PREDIV;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
hrtc.Init.OutPutPullUp = RTC_OUTPUT_PULLUP_NONE;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
privilegeState.rtcPrivilegeFull = RTC_PRIVILEGE_FULL_NO;
privilegeState.backupRegisterPrivZone = RTC_PRIVILEGE_BKUP_ZONE_NONE;
privilegeState.backupRegisterStartZone2 = RTC_BKP_DR0;
privilegeState.backupRegisterStartZone3 = RTC_BKP_DR0;
if (HAL_RTCEx_PrivilegeModeSet(&hrtc, &privilegeState) != HAL_OK)
Error_Handler();
if (HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR0) != 0x32F2)
sTime.Hours = 0x2;
sTime.Minutes = 0x0;
sTime.Seconds = 0x0;
sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
sTime.StoreOperation = RTC_STOREOPERATION_RESET;
if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
sDate.WeekDay = RTC_WEEKDAY_MONDAY;
sDate.Month = RTC_MONTH_APRIL;
sDate.Date = 0x16;
sDate.Year = 0x18;
if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR0, 0x32F2);
else
if (__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST) != RESET)
BSP_LED_On(LED5);
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
BSP_LED_On(LED5);
__HAL_RCC_CLEAR_RESET_FLAGS();
static void RTC_CalendarShow(uint8_t *showtime, uint8_t *showdate)
RTC_DateTypeDef sdatestructureget;
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&hrtc, &stimestructureget, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&hrtc, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char *)showtime, "%2d:%2d:%2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
sprintf((char *)showdate, "%2d-%2d-%2d", sdatestructureget.Month, sdatestructureget.Date, 2000 + sdatestructureget.Year);
void Error_Handler(void)
RTCStatus = 0xE;
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
transferErrorDetected = 0;
transferCompleteDetected = 0;
DMA_Config();
while (1)
if (transferErrorDetected == 1)
BSP_LED_On(LED3);
transferErrorDetected = 0;
if (transferCompleteDetected == 1)
BSP_LED_On(LED1);
transferCompleteDetected = 0;
static void DMA_Config(void)
__HAL_RCC_DMA2_CLK_ENABLE();
DmaHandle.Init.Channel = DMA_CHANNEL;
DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;
DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
DmaHandle.Init.Mode = DMA_NORMAL;
DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;
DmaHandle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;
DmaHandle.Instance = DMA_INSTANCE;
if(HAL_DMA_Init(&DmaHandle) != HAL_OK)
Error_Handler();
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_CPLT_CB_ID, TransferComplete);
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_ERROR_CB_ID, TransferError);
HAL_NVIC_SetPriority(DMA_INSTANCE_IRQ, 0, 0);
HAL_NVIC_EnableIRQ(DMA_INSTANCE_IRQ);
if (HAL_DMA_Start_IT(&DmaHandle, (uint32_t)&aSRC_Const_Buffer, (uint32_t)&aDST_Buffer, BUFFER_SIZE) != HAL_OK)
Error_Handler();
static void TransferComplete(DMA_HandleTypeDef *DmaHandle)
transferCompleteDetected = 1;
static void TransferError(DMA_HandleTypeDef *DmaHandle)
transferErrorDetected = 1;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 6;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_USART1_UART_Init();
init();
while (1)
loop();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 9600;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_HalfDuplex_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
void Error_Handler(void)
while(1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_GPIO);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LCD_Init();
BSP_LCD_SetFont(&Font20);
BSP_LCD_LayerDefaultInit(1, 0xC0130000);
BSP_LCD_SelectLayer(1);
BSP_LCD_DisplayOn();
BSP_LCD_Clear(LCD_COLOR_WHITE);
BSP_LCD_SetBackColor(LCD_COLOR_BLUE);
BSP_LCD_SetBackColor(LCD_COLOR_RED);
BSP_LCD_SetTextColor(LCD_COLOR_WHITE);
BSP_LCD_DisplayStringAtLine(0, (uint8_t *)MESSAGE1);
BSP_LCD_DisplayStringAtLine(1, (uint8_t *)MESSAGE3);
BSP_LCD_DisplayStringAtLine(2, (uint8_t *)MESSAGE5);
BSP_LCD_DisplayStringAtLine(3, (uint8_t *)MESSAGE7);
BSP_LED_On(LED3);
BSP_LED_On(LED4);
while (1)
while (BSP_PB_GetState(BUTTON_TAMPER) != RESET)
BSP_LED_Toggle(LED3);
HAL_Delay(50);
BSP_LED_Toggle(LED4);
HAL_Delay(50);
HAL_FLASH_Unlock();
HAL_FLASH_OB_Unlock();
AdvOBInit.OptionType = OPTIONBYTE_BOOTCONFIG;
HAL_FLASHEx_AdvOBGetConfig(&AdvOBInit);
if (((AdvOBInit.BootConfig) & (FLASH_OPTCR_BFB2)) == FLASH_OPTCR_BFB2)
AdvOBInit.BootConfig = OB_DUAL_BOOT_DISABLE;
HAL_FLASHEx_AdvOBProgram (&AdvOBInit);
else
AdvOBInit.BootConfig = OB_DUAL_BOOT_ENABLE;
HAL_FLASHEx_AdvOBProgram (&AdvOBInit);
if (HAL_FLASH_OB_Launch() != HAL_OK)
while (1)
HAL_FLASH_OB_Lock();
HAL_FLASH_Lock();
HAL_NVIC_SystemReset();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC1_Init();
HAL_ADCEx_Calibration_Start(&hadc1);
InitDisplay();
HAL_ADC_Start_IT(&hadc1);
while (true)
HAL_GPIO_TogglePin(SIG_GPIO_Port, SIG_Pin);
HAL_Delay(Max(signalPeriod / 2, 1));
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
if (hadc == &hadc1)
const uint16_t oldPeriod = signalPeriod;
signalPeriod = Max((uint16_t)HAL_ADC_GetValue(&hadc1), 1);
if (oldPeriod != signalPeriod)
UpdateDisplay();
HAL_ADC_Start_IT(&hadc1);
uint16_t Max(const uint16_t a, const uint16_t b)
return a > b ? a : b;
void InitDisplay(void)
HAL_Delay(16);
const uint8_t setBusTo8Bit = 0x34,
shiftOnWrite = 0x6,
enableDisplay = 0xC;
const uint8_t busCmdDelay = 1,
shiftCmdDelay = 1,
enableCmdDelay = 1;
SendToDisplay(false, setBusTo8Bit, busCmdDelay);
SendToDisplay(false, shiftOnWrite, shiftCmdDelay);
SendToDisplay(false, enableDisplay, enableCmdDelay);
ResetDisplay();
void ResetDisplay(void)
const uint8_t resetDataCmd = 0x1,
resetDataDelay = 2;
SendToDisplay(false, resetDataCmd, resetDataDelay);
void SendToDisplay(const bool isSymbol, const uint8_t data, const uint32_t cmdDelay)
HAL_GPIO_WritePin(DISPLAY_CMD_GPIO_Port, DISPLAY_CMD_Pin, isSymbol ? GPIO_PIN_SET : GPIO_PIN_RESET);
const uint8_t dataStartPin = 8;
HAL_GPIO_WritePin(GPIOA, data << dataStartPin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, (~data) << dataStartPin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(DISPLAY_SYNC_GPIO_Port, DISPLAY_SYNC_Pin, GPIO_PIN_SET);
HAL_Delay(1);
HAL_GPIO_WritePin(DISPLAY_SYNC_GPIO_Port, DISPLAY_SYNC_Pin, GPIO_PIN_RESET);
HAL_Delay(cmdDelay);
HAL_GPIO_WritePin(GPIOA, data << dataStartPin, GPIO_PIN_RESET);
void PrintNextSymbol(const char symbol)
SendToDisplay(true, symbol, 1);
bool PrintNextNumber(const uint8_t nextNumber)
const bool isNumberValid = nextNumber < 10;
if (isNumberValid)
const uint8_t asciiNumberOffset = 0x30;
PrintNextSymbol(nextNumber + asciiNumberOffset);
return isNumberValid;
void UpdateDisplay(void)
ResetDisplay();
const double frequency = (double)1000 / signalPeriod;
const uint16_t integralFrequency = (uint16_t)frequency;
const uint8_t integralFreqDigitsCount = GetDigitsCount(integralFrequency);
for (uint8_t curDigit = integralFreqDigitsCount; curDigit > 0; --curDigit)
PrintNextNumber(integralFrequency % (uint16_t)pow(10, curDigit) / pow(10, (curDigit - 1)));
if (FRACTIONAL_FREQ_DISPLAY_LENGTH > 0)
PrintNextSymbol('.');
const double fractionalFrequency = frequency - integralFrequency;
for (uint8_t curDigit = 1; curDigit <= FRACTIONAL_FREQ_DISPLAY_LENGTH; ++curDigit)
PrintNextNumber((uint8_t)(fractionalFrequency * pow(10, curDigit)) % 10);
const char postfix[] = " Hz";
for (uint8_t symbol = 0; symbol < sizeof(postfix) / sizeof(postfix[0]); ++symbol)
PrintNextSymbol(postfix[symbol]);
uint8_t GetDigitsCount(uint16_t number)
uint8_t digitsCount = 0;
do
number /= 10;
++digitsCount;
} while (number != 0);
return digitsCount;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_1;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, SIG_Pin|DISPLAY_CMD_Pin|DISPLAY_SYNC_Pin|DISPLAY_DATA_0_Pin
|DISPLAY_DATA_1_Pin|DISPLAY_DATA_2_Pin|DISPLAY_DATA_3_Pin|DISPLAY_DATA_4_Pin
|DISPLAY_DATA_5_Pin|DISPLAY_DATA_6_Pin|DISPLAY_DATA_7_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = SIG_Pin|DISPLAY_CMD_Pin|DISPLAY_SYNC_Pin|DISPLAY_DATA_0_Pin
|DISPLAY_DATA_1_Pin|DISPLAY_DATA_2_Pin|DISPLAY_DATA_3_Pin|DISPLAY_DATA_4_Pin
|DISPLAY_DATA_5_Pin|DISPLAY_DATA_6_Pin|DISPLAY_DATA_7_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
switch (HAL_SPI_TransmitReceive(&hspi1, (uint8_t *)aTxBuffer, (uint8_t *)aRxBuffer, BUFFERSIZE, 5000))
case HAL_OK:
if (Buffercmp((uint8_t *)aTxBuffer, (uint8_t *)aRxBuffer, BUFFERSIZE))
Error_Handler();
BSP_LED_On(LED1);
BSP_LED_On(LED2);
break;
case HAL_TIMEOUT:
Timeout_Error_Handler();
break;
case HAL_ERROR:
Error_Handler();
break;
default:
break;
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_SLAVE;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOA_CLK_ENABLE();
static void Timeout_Error_Handler(void)
while (1)
BSP_LED_On(LED3);
HAL_Delay(500);
BSP_LED_Off(LED3);
HAL_Delay(500);
static uint16_t Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength)
while (BufferLength--)
if ((*pBuffer1) != *pBuffer2)
return BufferLength;
pBuffer1++;
pBuffer2++;
return 0;
void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
static void atio_irq(void)
unsigned char  value;
unsigned short ringspace;
if(__HAL_UART_GET_FLAG(&uart_at, UART_FLAG_RXNE) != RESET)
value = (uint8_t)(uart_at.Instance->DR & 0x00FF);
g_atio_cb.rcvlen++;
if(g_atio_cb.w_next < CN_RCVBUF_LEN)
g_atio_cb.rcvbuf[g_atio_cb.w_next] = value;
g_atio_cb.w_next++;
else
g_atio_cb.rframeover++;
else if (__HAL_UART_GET_FLAG(&uart_at,UART_FLAG_IDLE) != RESET)
__HAL_UART_CLEAR_IDLEFLAG(&uart_at);
ringspace = CN_RCVMEM_LEN - ring_datalen(&g_atio_cb.rcvring);
if(ringspace < g_atio_cb.w_next)
g_atio_cb.rframedrop++;
else
ringspace = g_atio_cb.w_next;
ring_write(&g_atio_cb.rcvring,(unsigned char *)&ringspace,sizeof(ringspace));
ring_write(&g_atio_cb.rcvring,g_atio_cb.rcvbuf,ringspace);
osal_semp_post(g_atio_cb.rcvsync);
g_atio_cb.rcvframe++;
g_atio_cb.w_next=0;
bool_t uart_at_init(int baud)
memset(&g_atio_cb,0,sizeof(g_atio_cb));
if(false == osal_semp_create(&g_atio_cb.rcvsync,CN_RCVMEM_LEN,0))
printf("%s:semp create error\\n\\r",__FUNCTION__);
goto EXIT_SEMP;
ring_init(&g_atio_cb.rcvring,g_atio_cb.rcvringmem,CN_RCVMEM_LEN,0,0);
uart_at.Instance = s_pUSART;
uart_at.Init.BaudRate = baud;
uart_at.Init.WordLength = UART_WORDLENGTH_8B;
uart_at.Init.StopBits = UART_STOPBITS_1;
uart_at.Init.Parity = UART_PARITY_NONE;
uart_at.Init.HwFlowCtl = UART_HWCONTROL_NONE;
uart_at.Init.Mode = UART_MODE_TX_RX;
uart_at.Init.OverSampling = UART_OVERSAMPLING_16;
if(HAL_UART_Init(&uart_at) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
__HAL_UART_CLEAR_FLAG(&uart_at,UART_FLAG_TC);
LOS_HwiCreate(s_uwIRQn, 3, 0, atio_irq, 0);
__HAL_UART_ENABLE_IT(&uart_at, UART_IT_IDLE);
__HAL_UART_ENABLE_IT(&uart_at, UART_IT_RXNE);
return true;
EXIT_SEMP:
return false;
void uartat_deinit(void)
__HAL_UART_DISABLE(&uart_at);
__HAL_UART_DISABLE_IT(&uart_at, UART_IT_IDLE);
__HAL_UART_DISABLE_IT(&uart_at, UART_IT_RXNE);
static ssize_t uart_at_send(const void *buf, size_t len,uint32_t timeout)
HAL_UART_Transmit(&uart_at,(unsigned char *)buf,len,timeout);
g_atio_cb.sndlen += len;
g_atio_cb.sndframe ++;
return len;
static ssize_t uart_at_receive(void *buf,size_t len, uint32_t timeout)
unsigned short cpylen;
unsigned short framelen;
unsigned short readlen;
int32_t ret = 0;
unsigned int lock;
if(osal_semp_pend(g_atio_cb.rcvsync,timeout))
lock = LOS_IntLock();
readlen = sizeof(framelen);
cpylen = ring_read(&g_atio_cb.rcvring,(unsigned char *)&framelen,readlen);
if(cpylen != readlen)
ring_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
if(framelen > len)
ring_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
readlen = framelen;
cpylen = ring_read(&g_atio_cb.rcvring,(unsigned char *)buf,readlen);
if(cpylen != framelen)
ring_reset(&g_atio_cb.rcvring);
g_atio_cb.rcvringrst++;
else
ret = cpylen;
LOS_IntRestore(lock);
return ret;
static ssize_t  __at_read  (void *pri,size_t offset,void *buf,size_t len,uint32_t timeout)
return uart_at_receive(buf,len, timeout);
static ssize_t  __at_write (void *pri,size_t offset, const void *buf,size_t len,uint32_t timeout)
return uart_at_send(buf, len, timeout);
int main(void)
HAL_Init();
SystemClock_Config();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED_OK);
BSP_LED_Init(LED_ERROR);
BSP_SD_Init(0);
BSP_SD_DetectITConfig(0);
MX_ICACHE_Init();
MX_GPIO_Init();
if (MX_FATFS_Init() != APP_OK) {
Error_Handler();
osKernelInitialize();
fatfs_attr.name = "FATFS";
FatFsThreadHandle = osThreadNew(MX_FATFS_Process, NULL, (const osThreadAttr_t *)&fatfs_attr);
fatfs_attr.name = "STATUS";
StatusThreadHandle = osThreadNew(STATUS_Thread, NULL, (const osThreadAttr_t *)&fatfs_attr);
osKernelStart();
for (;;);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0);
__HAL_RCC_PWR_CLK_DISABLE();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
while(1);
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
static void STATUS_Thread(void *argument)
(void) argument;
for (;;)
if (ProcessStatus == APP_SD_UNPLUGGED)
BSP_LED_Off(LED_OK);
BSP_LED_Toggle(LED_ERROR);
osDelay(200);
else if (ProcessStatus == APP_ERROR)
Error_Handler();
else
BSP_LED_Off(LED_ERROR);
BSP_LED_On(LED_OK);
void Error_Handler(void)
BSP_LED_Off(LED_OK);
BSP_LED_On(LED_ERROR);
while(1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC1_Init();
MX_DAC_Init();
MX_USB_DEVICE_Init();
uint8_t scratch_buffer1[512];
uint8_t cycle_counter = 0;
while( !is_usb_connected() ) {}
uint8_t hello_message[] = "HELLO -- STM32 CDC Serial Demo!  All echoed text will be caps.\\n\\r";
cdc_write(hello_message, sizeof(hello_message));
while (1)
if ( cdc_data_pending() ) {
int brx = cdc_read(scratch_buffer1, 512);
for (int idx=0; idx < brx; ++idx ) {
scratch_buffer1[idx] = to_upper(scratch_buffer1[idx]);
cdc_write(scratch_buffer1, brx);
if ( cycle_counter > 10 ) {
HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);
cycle_counter = 0;
} else {
++cycle_counter;
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV2;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_ADC12;
PeriphClkInit.Adc12ClockSelection = RCC_ADC12PLLCLK_DIV1;
PeriphClkInit.USBClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_MultiModeTypeDef multimode = {0};
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
hadc1.Init.DMAContinuousRequests = DISABLE;
hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
hadc1.Init.LowPowerAutoWait = DISABLE;
hadc1.Init.Overrun = ADC_OVR_DATA_OVERWRITTEN;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
multimode.Mode = ADC_MODE_INDEPENDENT;
if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_3;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SingleDiff = ADC_SINGLE_ENDED;
sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
sConfig.OffsetNumber = ADC_OFFSET_NONE;
sConfig.Offset = 0;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_DAC_Init(void)
DAC_ChannelConfTypeDef sConfig = {0};
hdac.Instance = DAC;
if (HAL_DAC_Init(&hdac) != HAL_OK)
Error_Handler();
sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOE_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 38400;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.Timing = 0x0000020B;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
void Error_Handler(void)
iprintf("\\r\\n\\r\\n");
iprintf("ERROR!");
iprintf("\\r\\n\\r\\n");
while(1) { }
bool board_init(void)
HAL_Init();
SystemClock_Config();
InitRTC();
UART_Console_Init();
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
BSP_LED_Init(LED2);
Init_MEM1_Sensors();
InitTimers();
return 0;
static void Init_MEM1_Sensors(void)
if (ACCELERO_OK != BSP_ACCELERO_Init())
printf("Error Accelero Sensor\\r\\n");
if (GYRO_OK != BSP_GYRO_Init())
printf("Error Gyroscope Sensor\\r\\n");
if (MAGNETO_OK != BSP_MAGNETO_Init())
printf("Error Magneto Sensor\\r\\n");
if (HSENSOR_OK != BSP_HSENSOR_Init())
printf("Error Humidity Sensor\\r\\n");
if (TSENSOR_OK != BSP_TSENSOR_Init())
printf("Error Temperature Sensor\\r\\n");
if (PSENSOR_OK != BSP_PSENSOR_Init())
printf("Error Pressure Sensor\\r\\n");
static void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 6;
RCC_OscInitStruct.PLL.PLLN = 20;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
STM32_Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
STM32_Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_I2C2 | RCC_PERIPHCLK_RNG;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_MSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
STM32_Error_Handler();
__HAL_RCC_PWR_CLK_ENABLE();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
STM32_Error_Handler();
HAL_RCCEx_EnableMSIPLLMode();
void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim)
uint32_t uhCapture = 0;
if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1)
uhCapture = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);
__HAL_TIM_SET_COMPARE(&TimCCHandle, TIM_CHANNEL_1, (uhCapture + t_TIM_CC1_Pulse));
SendData = 1;
BSP_LED_Toggle(LED2);
static void InitTimers(void)
uint32_t uwPrescalerValue;
TIM_OC_InitTypeDef sConfig;
uwPrescalerValue = (uint32_t)((SystemCoreClock / 2000) - 1);
TimCCHandle.Instance = TIM1;
TimCCHandle.Init.Period = 65535;
TimCCHandle.Init.Prescaler = uwPrescalerValue;
TimCCHandle.Init.ClockDivision = 0;
TimCCHandle.Init.CounterMode = TIM_COUNTERMODE_UP;
if (HAL_TIM_OC_Init(&TimCCHandle) != HAL_OK)
STM32_Error_Handler();
sConfig.OCMode = TIM_OCMODE_TOGGLE;
sConfig.OCPolarity = TIM_OCPOLARITY_LOW;
sConfig.Pulse = DEFAULT_TIM_CC1_PULSE;
if (HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK)
STM32_Error_Handler();
static void InitRTC(void)
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
STM32_Error_Handler();
void STM32_Error_Handler(void)
printf("FATAL: STM32 Error Handler\\r\\n");
while (1)
static void UART_Console_Init(void)
UartHandle.Instance = USART1;
UartHandle.Init.BaudRate = CFG_HW_UART1_BAUDRATE;
UartHandle.Init.WordLength = CFG_HW_UART1_WORDLENGTH;
UartHandle.Init.StopBits = CFG_HW_UART1_STOPBITS;
UartHandle.Init.Parity = CFG_HW_UART1_PARITY;
UartHandle.Init.Mode = CFG_HW_UART1_MODE;
UartHandle.Init.HwFlowCtl = CFG_HW_UART1_HWFLOWCTL;
UartHandle.AdvancedInit.AdvFeatureInit = CFG_HW_UART1_ADVFEATUREINIT;
BSP_COM_Init(COM1, &UartHandle);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
switch (GPIO_Pin)
case USER_BUTTON_PIN:
ButtonPressed = 1;
break;
case GPIO_PIN_1:
SPI_WIFI_ISR();
break;
void SPI3_IRQHandler(void)
HAL_SPI_IRQHandler(&hspi);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LED_On(LED1);
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
__HAL_RTC_RESET_HANDLE_STATE(&RtcHandle);
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1) != 0x32F2)
RTC_CalendarConfig();
else
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
BSP_LED_On(LED2);
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
BSP_LED_On(LED4);
__HAL_RCC_CLEAR_RESET_FLAGS();
while (1)
RTC_CalendarShow(aShowTime, aShowDate);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 6;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void RTC_CalendarConfig(void)
RTC_DateTypeDef sdatestructure;
RTC_TimeTypeDef stimestructure;
sdatestructure.Year = 0x14;
sdatestructure.Month = RTC_MONTH_FEBRUARY;
sdatestructure.Date = 0x18;
sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
stimestructure.Hours = 0x02;
stimestructure.Minutes = 0x00;
stimestructure.Seconds = 0x00;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
if (HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
static void RTC_CalendarShow(uint8_t *showtime, uint8_t *showdate)
RTC_DateTypeDef sdatestructureget;
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char *)showtime, "%2d:%2d:%2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
sprintf((char *)showdate, "%2d-%2d-%2d", sdatestructureget.Month, sdatestructureget.Date, 2000 + sdatestructureget.Year);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main()
HAL_Init();
init_sysclk_216MHz();
init_gpio(led1, OUTPUT);
init_gpio(led2, OUTPUT);
init_gpio(led3, OUTPUT);
init_gpio(pb1, INPUT);
int Debounce = 0;
int Led = 1;
while(1)
if(read_gpio(pb1)==LOW)
HAL_Delay(5);
if(read_gpio(pb1)==LOW)
Debounce = 1;
if((Debounce == 1)&&(read_gpio(pb1)==HIGH))
switch (Led)
case 1:
write_gpio(led1, HIGH);
write_gpio(led3, LOW);
Led = 2;
break;
case 2:
write_gpio(led2, HIGH);
write_gpio(led1, LOW);
Led = 3;
break;
case 3:
write_gpio(led3, HIGH);
write_gpio(led2, LOW);
Led = 1;
break;
default: ;
break;
Debounce = 0;
int main(void)
HAL_Init();
BSP_LED_Init(LED2);
SystemClock_Config();
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
SystemPower_Config();
while (1)
HAL_Delay(5000);
BSP_LED_Off(LED2);
HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);
SYSCLKConfig_FromSTOP();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void SystemPower_Config(void)
GPIO_InitTypeDef gpio_initstruct;
__HAL_RCC_PWR_CLK_ENABLE();
LL_AHB1_GRP1_EnableClock(LL_AHB1_GRP1_PERIPH_GPIOA |
LL_AHB1_GRP1_PERIPH_GPIOB |
LL_AHB1_GRP1_PERIPH_GPIOC |
LL_AHB1_GRP1_PERIPH_GPIOD |
LL_AHB1_GRP1_PERIPH_GPIOE |
LL_AHB1_GRP1_PERIPH_GPIOH);
gpio_initstruct.Mode  = GPIO_MODE_ANALOG;
gpio_initstruct.Speed = GPIO_SPEED_FREQ_HIGH;
gpio_initstruct.Pull  = GPIO_NOPULL;
gpio_initstruct.Pin   = GPIO_PIN_All;
HAL_GPIO_Init(GPIOB, &gpio_initstruct);
HAL_GPIO_Init(GPIOD, &gpio_initstruct);
HAL_GPIO_Init(GPIOE, &gpio_initstruct);
HAL_GPIO_Init(GPIOH, &gpio_initstruct);
gpio_initstruct.Pin   &= ~GPIO_PIN_13;
HAL_GPIO_Init(GPIOC, &gpio_initstruct);
gpio_initstruct.Pin   &= (GPIO_PIN_All & ~GPIO_PIN_5);
HAL_GPIO_Init(GPIOA, &gpio_initstruct);
__STATIC_INLINE void SYSCLKConfig_FromSTOP(void)
LL_RCC_HSE_Enable();
while(LL_RCC_HSE_IsReady() != 1) {};
LL_RCC_PLL_Enable();
while(LL_RCC_PLL_IsReady() != 1)
};
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);
while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL)
};
void Error_Handler(void)
HAL_SuspendTick();
BSP_LED_On(LED2);
while (1)
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
if (TimingDelay != 0)
TimingDelay--;
else
BSP_LED_Toggle(LED2);
TimingDelay = LED_TOGGLE_DELAY;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == USER_BUTTON_PIN)
BSP_LED_Init(LED2);
BSP_LED_On(LED2);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_I2C1_Init();
mpu6050Config();
while (1)
mpu6050GyroRead();
mpu6050AccelRead();
HAL_Delay(200);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 400000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
value_adc = HAL_ADC_GetValue(&hadc1);
value_adc = value_adc * 0.085;
if(value_adc > ideal_mode){
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
} else {
HAL_TIM_PWM_Stop(&htim1, TIM_CHANNEL_2);
if(value_adc > UltraPower){
HAL_TIM_OC_Start(&htim1, TIM_CHANNEL_4);
}	else{
HAL_TIM_OC_Stop(&htim1, TIM_CHANNEL_4);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_ADC1_Init();
MX_TIM1_Init();
MX_USART1_UART_Init();
HAL_TIM_IC_Start_IT(&htim1, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);
HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_3);
char uartData[50];
char uartData2[50];
char uartData3[50];
lcd_init(_LCD_4BIT, _LCD_FONT_5x8, _LCD_2LINE);
lcd_print(1,1, "Program Starting....");
lcd_clear();
while (1)
HAL_ADC_Start_IT(&hadc1);
if(value_adc > UltraPower){
int len1 = sprintf(uartData3, "\\r\\nULTRA POWER MODE INITAITED\\r\\n");
HAL_UART_Transmit(&huart1, (uint8_t*)uartData3, len1+1, HAL_MAX_DELAY);
int len = sprintf(uartData, "Temperature = ");
lcd_print(1,1,uartData);
int lent2 = sprintf(uartData2, "%d.%02u C\\r\\n", (int) value_adc, (int) ((value_adc - (int) value_adc) * 100 ));
HAL_UART_Transmit(&huart1, (uint8_t*)uartData, len+1, HAL_MAX_DELAY);
HAL_UART_Transmit(&huart1, (uint8_t*)uartData2, len+1, HAL_MAX_DELAY);
lcd_print(2, 1, uartData2);
else if(value_adc > ideal_mode){
int len1 = sprintf(uartData3, "\\r\\nPOWER MODE INITAITED\\r\\n");
HAL_UART_Transmit(&huart1, (uint8_t*)uartData3, len1+1, HAL_MAX_DELAY);
int len = sprintf(uartData, "Temperature = ");
lcd_print(1,1,uartData);
int lent2 = sprintf(uartData2, "%d.%02u C\\r\\n", (int) value_adc, (int) ((value_adc - (int) value_adc) * 100 ));
HAL_UART_Transmit(&huart1, (uint8_t*)uartData, len+1, HAL_MAX_DELAY);
HAL_UART_Transmit(&huart1, (uint8_t*)uartData2, len+1, HAL_MAX_DELAY);
lcd_print(2, 1, uartData2);
} else {
int len1 = sprintf(uartData3, "\\r\\nPOWER MODE OFF\\rIDEAL MODE INITAITED\\r\\n");
HAL_UART_Transmit(&huart1, (uint8_t*)uartData3, len1+1, HAL_MAX_DELAY);
int len = sprintf(uartData, "Temperature = ");
lcd_print(1,1,uartData);
int lent2 = sprintf(uartData2, "%d.%02u C\\r\\n", (int) value_adc, (int) ((value_adc - (int) value_adc) * 100 ));
HAL_UART_Transmit(&huart1, (uint8_t*)uartData, len+1, HAL_MAX_DELAY);
HAL_UART_Transmit(&huart1, (uint8_t*)uartData2, len+1, HAL_MAX_DELAY);
lcd_print(2, 1, uartData2);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC;
PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_0;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_IC_InitTypeDef sConfigIC = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = 124;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 63999;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_IC_Init(&htim1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
Error_Handler();
if (HAL_TIM_OC_Init(&htim1) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
sConfigIC.ICFilter = 0;
if (HAL_TIM_IC_ConfigChannel(&htim1, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 42666;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
sConfigOC.Pulse = 42666;
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_TOGGLE;
sConfigOC.Pulse = 42666;
if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
Error_Handler();
sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
sBreakDeadTimeConfig.DeadTime = 0;
sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim1);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 9600;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LCD_EN_Pin|LCD_RS_Pin|LCD_D4_Pin|LCD_D5_Pin
|LCD_D6_Pin|LCD_D7_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LCD_EN_Pin|LCD_RS_Pin|LCD_D4_Pin|LCD_D5_Pin
|LCD_D6_Pin|LCD_D7_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
HAL_GPIO_WritePin(USBovr_GPIO_Port, USBovr_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(USBpw_GPIO_Port, USBpw_Pin, GPIO_PIN_RESET);
MX_GPIO_Init();
MX_TIM12_Init();
MX_I2C2_Init();
struct netif  *netif = &netif_myData;
lwip_init();
netif->hwaddr_len = 6;
memcpy(netif->hwaddr, hwaddr, 6);
netif = netif_add(netif,
PADDR(ipaddr),
PADDR(netmask),
PADDR(gateway),
NULL,
netif_init_cb,
ip_input);
netif_set_default(netif);
init_periph();
printf("netif_is_up...\\n");
while (!netif_is_up(&netif_myData))
;
tCGI cgi_script_1 = {"/state.cgi",  state_cgi_handler };
tCGI cgi_script_2 = {"/ctl1.cgi",  ctl_cgi_handler1};
tCGI CGI_TAB[2];
CGI_TAB[0] = cgi_script_1;
CGI_TAB[1] = cgi_script_2;
int CGI_NUM =2;
http_set_cgi_handlers(CGI_TAB, sizeof(CGI_TAB) / sizeof(tCGI));
http_set_ssi_handler(ssi_handler, ssi_tags_table, sizeof(ssi_tags_table) / sizeof(char *));
httpd_init();
printf("work\\n");
while (dhserv_init(&dhcp_config) != ERR_OK)
printf("dhserv_init ERR\\n");
time_init();
USBD_Init(&USB_OTG_dev, USB_OTG_FS_CORE_ID, &USR_desc, &usbd_rndis_cb, &USR_cb);
rndis_rxproc = on_packet;
while (1)
usb_polling();
stmr();
DHCP_Periodic_Handle(&gnetif);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 10;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 5;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.ClockSpeed = 100000;
hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
static void MX_TIM12_Init(void)
TIM_OC_InitTypeDef sConfigOC = {0};
htim12.Instance = TIM12;
htim12.Init.Prescaler = 120;
htim12.Init.CounterMode = TIM_COUNTERMODE_UP;
htim12.Init.Period = 100;
htim12.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim12.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_OC_Init(&htim12) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_TIMING;
sConfigOC.Pulse = 50;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_OC_ConfigChannel(&htim12, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(USBovr_GPIO_Port, USBovr_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, DIpu_Pin|CLKpu_Pin|nOnpWF_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(ResWF_GPIO_Port, ResWF_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(USBpw_GPIO_Port, USBpw_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, nRSTind_Pin|onLIGT_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USBovr_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(USBovr_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = DIpu_Pin|CLKpu_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = ResWF_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(ResWF_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Vbus_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(Vbus_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USBpw_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(USBpw_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = nOnpWF_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(nOnpWF_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = nRSTind_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(nRSTind_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = onLIGT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLDOWN;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(onLIGT_GPIO_Port, &GPIO_InitStruct);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM11) {
HAL_IncTick();
else if (htim->Instance == TIM12)
void Error_Handler(void)
printf("\\nError_Handler\\n");
void assert_failed(uint8_t *file, uint32_t line)
void SystemApp_Init(void)
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
UTIL_TIMER_Init();
Gpio_PreInit();
DBG_Init();
GNSE_TRACER_INIT();
GNSE_TRACER_TIMESTAMP(TimestampNow);
APP_PPRINTF("\\r\\n Powering and using HW secure element (ATECC608A-TNGLORA) \\r\\n");
GNSE_BSP_LS_Init(LOAD_SWITCH_SENSORS);
GNSE_BSP_LS_On(LOAD_SWITCH_SENSORS);
HAL_Delay(LOAD_SWITCH_SENSORS_DELAY_MS);
GNSE_BSP_Sensor_I2C1_Init();
UTIL_LPM_Init();
UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
void UTIL_SEQ_Idle(void)
UTIL_LPM_EnterLowPower();
static void TimestampNow(uint8_t *buff, uint16_t *size)
SysTime_t curtime = SysTimeGet();
tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
*size = strlen((char *)buff);
static void Gpio_PreInit(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Pin = GPIO_PIN_All & (~(GPIO_PIN_13 | GPIO_PIN_14));
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_All;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
__HAL_RCC_GPIOA_CLK_DISABLE();
__HAL_RCC_GPIOB_CLK_DISABLE();
__HAL_RCC_GPIOC_CLK_DISABLE();
__HAL_RCC_GPIOH_CLK_DISABLE();
static void DBG_Init()
LL_EXTI_EnableIT_32_63(LL_EXTI_LINE_46);
HAL_DBGMCU_EnableDBGSleepMode();
HAL_DBGMCU_EnableDBGStopMode();
HAL_DBGMCU_EnableDBGStandbyMode();
GPIO_InitTypeDef GPIO_InitStruct = {0};
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Pin = (GPIO_PIN_13 | GPIO_PIN_14);
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
HAL_DBGMCU_DisableDBGSleepMode();
HAL_DBGMCU_DisableDBGStopMode();
HAL_DBGMCU_DisableDBGStandbyMode();
void ADV_TRACER_PreSendHook(void)
UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
void ADV_TRACER_PostSendHook(void)
UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
va_list vaArgs;
va_start(vaArgs, strFormat);
ADV_TRACER_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
va_end(vaArgs);
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
return HAL_OK;
uint32_t HAL_GetTick(void)
return GNSE_RTC_GetTimerValue();
void HAL_Delay(__IO uint32_t Delay)
GNSE_RTC_DelayMs(Delay);
int main(void)
uint32_t counter = 0;
HAL_Init();
BSP_LED_Init(LED9);
SystemClock_Config();
MX_ICACHE_Init();
MX_RNG_Init();
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
while (1)
while ((ubUserButtonClickEvent) == RESET)
__NOP();
ubUserButtonClickEvent = RESET;
for (counter = 0; counter < 8; counter++)
if (HAL_RNG_GenerateRandomNumber(&hrng, &aRandom32bit[counter]) != HAL_OK)
Error_Handler();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_RNG_Init(void)
hrng.Instance = RNG;
hrng.Init.ClockErrorDetection = RNG_CED_ENABLE;
if (HAL_RNG_Init(&hrng) != HAL_OK)
Error_Handler();
void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == BUTTON_USER_PIN)
ubUserButtonClickEvent = SET;
RNGStatus = 1;
void Error_Handler(void)
RNGStatus = 0xE;
while (1)
BSP_LED_Toggle(LED9);
HAL_Delay(500);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_JOY_Init(JOY_MODE_EXTI);
while(1)
HAL_Delay(500);
BSP_LED_Toggle(LED1);
BSP_LED_Toggle(LED2);
BSP_LED_Toggle(LED3);
BSP_LED_Toggle(LED4);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == RIGHT_JOY_PIN)
if (uwIncrementState == 0)
HAL_SuspendTick();
uwIncrementState = 1;
else
HAL_ResumeTick();
uwIncrementState = 0;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t* file, uint32_t line)
void SystemClock_MHz(uint32_t freq)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
__HAL_FLASH_SET_LATENCY(FLASH_LATENCY_3);
HAL_RCC_DeInit();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = freq/2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
static void MX_TIM5_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim5.Instance = TIM5;
htim5.Init.Prescaler = SYSCLOCK_MHz*1000;
htim5.Init.CounterMode = TIM_COUNTERMODE_UP;
htim5.Init.Period = 0xffffffff;
htim5.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim5.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim5) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim5, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim5, &sMasterConfig) != HAL_OK)
Error_Handler();
HAL_TIM_Base_Start(&htim5);
__HAL_TIM_SetCounter(&htim5,0);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14|GPIO_PIN_7, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_14|GPIO_PIN_7;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
uint32_t HAL_Get_time_us(void)
return TIM5->CNT;
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
RCC_SystemClock_Config();
GPIO_Output_Config();
UART_Config();
while (1)
printf("UART printf.\\n");
HAL_Delay(1000);
void RCC_SystemClock_Config(void)
RCC_ClkInitTypeDef rccClkInit;
RCC_OscInitTypeDef rccOscInit;
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE;
rccOscInit.HSEState       = RCC_HSE_ON;
rccOscInit.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
rccOscInit.PLL.PLLState   = RCC_PLL_ON;
rccOscInit.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
rccOscInit.PLL.PLLMUL     = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&rccOscInit) != HAL_OK)
Error_Handler();
rccClkInit.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
rccClkInit.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
rccClkInit.AHBCLKDivider  = RCC_SYSCLK_DIV1;
rccClkInit.APB2CLKDivider = RCC_HCLK_DIV1;
rccClkInit.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void GPIO_Output_Config(void)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_GPIOB_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9;
gpioInit.Mode  = GPIO_MODE_OUTPUT_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &gpioInit);
void UART_Config(void)
uartHandle.Instance        = USART2;
uartHandle.Init.BaudRate   = 9600;
uartHandle.Init.WordLength = UART_WORDLENGTH_8B;
uartHandle.Init.StopBits   = UART_STOPBITS_1;
uartHandle.Init.Parity     = UART_PARITY_NONE;
uartHandle.Init.Mode       = UART_MODE_TX;
uartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
if (HAL_UART_Init(&uartHandle) != HAL_OK)
Error_Handler();
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_USART2_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_2;
gpioInit.Mode  = GPIO_MODE_AF_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOA, &gpioInit);
void Error_Handler(void)
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
while (1);
int main(void)
uint8_t buff[] = "Hello World!\\r\\n";
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
MX_USB_DEVICE_Init();
while (1)
CDC_Transmit_FS(buff, strlen((char*)buff));
HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_SLAVE;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_13;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM1) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void SystemInit(void)
RCC->CR |= (uint32_t)0x00000001;
RCC->CFGR = 0x00000000;
RCC->CR &= (uint32_t)0xFEF6FFFF;
RCC->PLLCFGR = 0x24003010;
RCC->CR &= (uint32_t)0xFFFBFFFF;
RCC->CIR = 0x00000000;
__HAL_RCC_PWR_CLK_ENABLE();
SystemInit_ExtMemCtl();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.OscillatorType    = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState          = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue  = 16;
RCC_OscInitStruct.PLL.PLLState      = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource     = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM          = 16;
RCC_OscInitStruct.PLL.PLLN          = 432;
RCC_OscInitStruct.PLL.PLLP          = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ          = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if (ret != HAL_OK) {
while (1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if (ret != HAL_OK) {
while (1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if (ret != HAL_OK) {
while (1) { ; }
void stm32_rng_init(void)
RNG_HandleTypeDef rng_handle = { 0 };
__HAL_RCC_RNG_CLK_ENABLE();
rng_handle.Instance = RNG;
HAL_StatusTypeDef status = HAL_RNG_Init(&rng_handle);
if (status != HAL_OK) {
panic("error initializing random number hardware\\n");
uint32_t r;
status = HAL_RNG_GenerateRandomNumber(&rng_handle, &r);
if (status != HAL_OK) {
panic("error getting random number from hardware\\n");
status = HAL_RNG_GenerateRandomNumber(&rng_handle, &r);
if (status != HAL_OK) {
panic("error getting random number from hardware\\n");
srand(r);
static void mpu_init(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
uint region_num = 0;
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x0;
MPU_InitStruct.Size = MPU_REGION_SIZE_128KB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = region_num++;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = SDRAM_BASE;
MPU_InitStruct.Size =
MPU_REGION_SIZE_1MB;
MPU_REGION_SIZE_2MB;
MPU_REGION_SIZE_4MB;
MPU_REGION_SIZE_8MB;
MPU_REGION_SIZE_16MB
MPU_REGION_SIZE_32MB;
MPU_REGION_SIZE_64MB;
MPU_REGION_SIZE_128MB;
MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = region_num++;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = EXT_SRAM_BASE;
MPU_InitStruct.Size = MPU_REGION_SIZE_2MB;
MPU_InitStruct.AccessPermission = MPU_REGION_PRIV_RW;
MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = region_num++;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_HFNMI_PRIVDEF);
void platform_early_init(void)
SystemInit();
SystemClock_Config();
__HAL_FLASH_ART_ENABLE();
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
stm32_unique_id[0] = *REG32(0x1ff0f420);
stm32_unique_id[1] = *REG32(0x1ff0f424);
stm32_unique_id[2] = *REG32(0x1ff0f428);
srand(stm32_unique_id[0] ^ stm32_unique_id[1] ^ stm32_unique_id[2]);
uint32_t sysclk = HAL_RCC_GetSysClockFreq();
arm_cm_systick_init(sysclk);
stm32_timer_early_init();
stm32_gpio_early_init();
stm32_flash_early_init();
stm32_rng_init();
stm32_usbc_early_init();
RCC->CSR |= (1<<24);
stm32_sdram_init((sdram_config_t *)&target_sdram_config);
novm_add_arena("sdram", SDRAM_BASE, SDRAM_SIZE);
mpu_init();
void platform_init(void)
printf("clocks:\\n");
printf("\\tsysclk %u\\n", HAL_RCC_GetSysClockFreq());
printf("\\thclk %u\\n", HAL_RCC_GetHCLKFreq());
printf("\\tpclk1 %u\\n", HAL_RCC_GetPCLK1Freq());
printf("\\tpclk2 %u\\n", HAL_RCC_GetPCLK2Freq());
printf("unique id: 0x%08x%08x%08x\\n", stm32_unique_id[0], stm32_unique_id[1], stm32_unique_id[2]);
stm32_timer_init();
stm32_flash_init();
stm32_usbc_init();
int main(void)
BSP_LED_Init(LED5);
BSP_LED_Init(LED4);
BSP_LED_Init(LED3);
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);
HAL_Init();
RCC_SystemClock_Config();
SPI_Config();
while (BSP_PB_GetState(BUTTON_KEY) == 0);
SPI_EnableSlave();
if (HAL_SPI_TransmitReceive_DMA(&spiHandle, txBuffer, rxBuffer, BUFFER_SIZE)
!= HAL_OK)
Error_Handler();
while (HAL_SPI_GetState(&spiHandle) != HAL_SPI_STATE_READY);
SPI_DisableSlave();
while (1);
void RCC_SystemClock_Config(void)
RCC_ClkInitTypeDef rccClkInit;
RCC_OscInitTypeDef rccOscInit;
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE;
rccOscInit.HSEState       = RCC_HSE_ON;
rccOscInit.PLL.PLLState   = RCC_PLL_ON;
rccOscInit.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
rccOscInit.PLL.PLLM       = 8;
rccOscInit.PLL.PLLN       = 336;
rccOscInit.PLL.PLLP       = RCC_PLLP_DIV2;
rccOscInit.PLL.PLLQ       = 7;
if(HAL_RCC_OscConfig(&rccOscInit) != HAL_OK)
Error_Handler();
rccClkInit.ClockType      = RCC_CLOCKTYPE_SYSCLK |
RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
rccClkInit.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
rccClkInit.AHBCLKDivider  = RCC_SYSCLK_DIV1;
rccClkInit.APB1CLKDivider = RCC_HCLK_DIV4;
rccClkInit.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void SPI_Config(void)
spiHandle.Instance               = SPI1;
spiHandle.Init.Mode              = SPI_MODE_MASTER;
spiHandle.Init.Direction         = SPI_DIRECTION_2LINES;
spiHandle.Init.DataSize          = SPI_DATASIZE_8BIT;
spiHandle.Init.CLKPolarity       = SPI_POLARITY_HIGH;
spiHandle.Init.CLKPhase          = SPI_PHASE_1EDGE;
spiHandle.Init.NSS               = SPI_NSS_HARD_OUTPUT;
spiHandle.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
spiHandle.Init.FirstBit          = SPI_FIRSTBIT_MSB;
spiHandle.Init.TIMode            = SPI_TIMODE_DISABLE;
spiHandle.Init.CRCCalculation    = SPI_CRCCALCULATION_DISABLE;
if(HAL_SPI_Init(&spiHandle) != HAL_OK)
Error_Handler();
void HAL_SPI_MspInit(SPI_HandleTypeDef *hspi)
GPIO_InitTypeDef gpioInit;
static DMA_HandleTypeDef dmaTxHandle;
static DMA_HandleTypeDef dmaRxHandle;
__HAL_RCC_SPI1_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_DMA2_CLK_ENABLE();
gpioInit.Pin       = GPIO_PIN_3;
gpioInit.Mode      = GPIO_MODE_OUTPUT_PP;
gpioInit.Pull      = GPIO_NOPULL;
gpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;;
HAL_GPIO_Init(GPIOA, &gpioInit);
SPI_DisableSlave();
gpioInit.Pin       = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7;
gpioInit.Mode      = GPIO_MODE_AF_PP;
gpioInit.Pull      = GPIO_PULLUP;
gpioInit.Speed     = GPIO_SPEED_FREQ_HIGH;
gpioInit.Alternate = GPIO_AF5_SPI1;
HAL_GPIO_Init(GPIOA, &gpioInit);
dmaTxHandle.Instance                 = DMA2_Stream3;
dmaTxHandle.Init.Channel             = DMA_CHANNEL_3;
dmaTxHandle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
dmaTxHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
dmaTxHandle.Init.MemInc              = DMA_MINC_ENABLE;
dmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
dmaTxHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
dmaTxHandle.Init.Mode                = DMA_NORMAL;
dmaTxHandle.Init.Priority            = DMA_PRIORITY_LOW;
dmaTxHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
dmaTxHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
dmaTxHandle.Init.MemBurst            = DMA_MBURST_INC4;
dmaTxHandle.Init.PeriphBurst         = DMA_PBURST_INC4;
__HAL_LINKDMA(hspi, hdmatx, dmaTxHandle);
HAL_DMA_Init(&dmaTxHandle);
dmaRxHandle.Instance                 = DMA2_Stream2;
dmaRxHandle.Init.Channel             = DMA_CHANNEL_3;
dmaRxHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
dmaRxHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
dmaRxHandle.Init.MemInc              = DMA_MINC_ENABLE;
dmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
dmaRxHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
dmaRxHandle.Init.Mode                = DMA_NORMAL;
dmaRxHandle.Init.Priority            = DMA_PRIORITY_HIGH;
dmaRxHandle.Init.FIFOMode            = DMA_FIFOMODE_DISABLE;
dmaRxHandle.Init.FIFOThreshold       = DMA_FIFO_THRESHOLD_FULL;
dmaRxHandle.Init.MemBurst            = DMA_MBURST_INC4;
dmaRxHandle.Init.PeriphBurst         = DMA_PBURST_INC4;
__HAL_LINKDMA(hspi, hdmarx, dmaRxHandle);
HAL_DMA_Init(&dmaRxHandle);
HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);
void HAL_SPI_TxRxCpltCallback(SPI_HandleTypeDef *hspi)
if(BufferCmp(txBuffer, rxBuffer, BUFFER_SIZE))
BSP_LED_On(LED5);
else
BSP_LED_On(LED4);
void HAL_SPI_ErrorCallback(SPI_HandleTypeDef *hspi)
BSP_LED_On(LED5);
void SPI_EnableSlave(void)
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_RESET);
void SPI_DisableSlave(void)
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_3, GPIO_PIN_SET);
uint8_t BufferCmp(uint8_t *pBuff1, uint8_t *pBuff2, uint16_t len)
while (len--)
if((*pBuff1) != *pBuff2)
return 1;
pBuff1++;
pBuff2++;
return 0;
void Error_Handler(void)
BSP_LED_On(LED5);
while (1);
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
LCD1602_Begin4BIT(RS_GPIO_Port,RS_Pin,E_Pin,D4_GPIO_Port,D4_Pin,D5_Pin,D6_Pin,D7_Pin);
for(int i=0;i<10;i++) {LCD1602_PrintInt(i);HAL_Delay(300);}
for(int i=0;i<3;i++) {LCD1602_print(".");HAL_Delay(300);}
LCD1602_2ndLine();
LCD1602_print("PS2 Sniffer");
HAL_Delay(1000);
LCD1602_clear();
LCD1602_1stLine();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, D0_Pin|D1_Pin|D2_Pin|D3_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, D4_Pin|D5_Pin|D6_Pin|D7_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOE, RS_Pin|E_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = Clock_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(Clock_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Dane_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(Dane_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = D0_Pin|D1_Pin|D2_Pin|D3_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = D4_Pin|D5_Pin|D6_Pin|D7_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RS_Pin|E_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int __io_putchar(int ch)
int fputc(int ch, FILE *f)
hal_uart_put_char(HAL_UART_0, ch);
if (ch == '\\n') {
hal_uart_put_char(HAL_UART_0, '\\r');
return ch;
static void SystemClock_Config(void)
top_xtal_init();
static int32_t cache_enable(hal_cache_size_t cache_size)
hal_cache_region_t region, region_number;
region_number = (hal_cache_region_t)(sizeof(region_cfg_tbl) / sizeof(region_cfg_tbl[0]));
if (region_number > HAL_CACHE_REGION_MAX) {
return -1;
hal_cache_init();
hal_cache_set_size(cache_size);
for (region = HAL_CACHE_REGION_0; region < region_number; region++) {
hal_cache_region_config(region, &region_cfg_tbl[region]);
hal_cache_region_enable(region);
for (; region < HAL_CACHE_REGION_MAX; region++) {
hal_cache_region_disable(region);
hal_cache_enable();
return 0;
static void prvSetupHardware(void)
hal_lp_handle_intr();
if (1 == hal_lp_get_wic_wakeup()) {
connsys_open();
connsys_close();
cmnCpuClkConfigureTo192M();
cmnSerialFlashClkConfTo64M();
bsp_ept_gpio_setting_init();
log_uart_init(HAL_UART_0);
if (cache_enable(HAL_CACHE_SIZE_32KB) < 0) {
LOG_E(common, "cache enable failed");
hal_flash_init();
static void _main_sys_random_init(void)
uint32_t            seed;
hal_trng_status_t   s;
s = hal_trng_init();
if (s == HAL_TRNG_STATUS_OK) {
s = hal_trng_get_generated_random_number(&seed);
if (s == HAL_TRNG_STATUS_OK) {
srand((unsigned int)seed);
if (s != HAL_TRNG_STATUS_OK) {
printf("trng init failed\\n");
} else {
void system_init(void)
time_t      t       = 12345;
SystemClock_Config();
prvSetupHardware();
nvdm_init();
log_init(NULL, NULL, NULL);
ctime(&t);
_main_sys_random_init();
LOG_I(common, "FreeRTOS Running");
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
UartHandle.Instance        = USARTx;
UartHandle.Init.BaudRate   = 9600;
UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits   = UART_STOPBITS_1;
UartHandle.Init.Parity     = UART_PARITY_ODD;
UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
UartHandle.Init.Mode       = UART_MODE_TX_RX;
if (HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
printf("\\n\\r UART Printf Example: retarget the C library printf function to the UART\\n\\r");
printf("** Test finished successfully. ** \\n\\r");
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV1;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
while(1);
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
void MX_SDIO_SD_Init(void)
hsd.Instance = SDIO;
hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
hsd.Init.ClockDiv = 0;
if (HAL_SD_Init(&hsd) != HAL_OK)
Error_Handler();
if (HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B) != HAL_OK)
Error_Handler();
void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
GPIO_InitTypeDef GPIO_InitStruct = {0};
if(sdHandle->Instance==SDIO)
__HAL_RCC_SDIO_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
|GPIO_PIN_12;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
hdma_sdio_rx.Instance = DMA2_Stream3;
hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
hdma_sdio_rx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
if (HAL_DMA_Init(&hdma_sdio_rx) != HAL_OK)
Error_Handler();
__HAL_LINKDMA(sdHandle,hdmarx,hdma_sdio_rx);
hdma_sdio_tx.Instance = DMA2_Stream6;
hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
hdma_sdio_tx.Init.Priority = DMA_PRIORITY_VERY_HIGH;
hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
if (HAL_DMA_Init(&hdma_sdio_tx) != HAL_OK)
Error_Handler();
__HAL_LINKDMA(sdHandle,hdmatx,hdma_sdio_tx);
HAL_NVIC_SetPriority(SDIO_IRQn, 3, 0);
HAL_NVIC_EnableIRQ(SDIO_IRQn);
printf("Init the low level hardware finish\\r\\n");
void HAL_SD_MspDeInit(SD_HandleTypeDef* sdHandle)
if(sdHandle->Instance==SDIO)
__HAL_RCC_SDIO_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOC, GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
|GPIO_PIN_12);
HAL_GPIO_DeInit(GPIOD, GPIO_PIN_2);
HAL_DMA_DeInit(sdHandle->hdmarx);
HAL_DMA_DeInit(sdHandle->hdmatx);
HAL_NVIC_DisableIRQ(SDIO_IRQn);
int main(void)
uint32_t capture_difference = 0;
HAL_Init();
SystemClockConfig();
Init_Pulse();
GPIO_Init();
Timer2_Init();
if(HAL_TIM_OC_Start_IT(&htimer2, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if(HAL_TIM_OC_Start_IT(&htimer2, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
if(HAL_TIM_OC_Start_IT(&htimer2, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
if(HAL_TIM_OC_Start_IT(&htimer2, TIM_CHANNEL_4) != HAL_OK)
Error_Handler();
while(1)
if(is_capture_done)
if(input_captures[1] > input_captures[0])
capture_difference = input_captures[1] - input_captures[0];
else
capture_difference = (0xffffffff - input_captures[0]) + input_captures[1];
double timer2_cnt_freq = (HAL_RCC_GetPCLK1Freq() * 2) / (htimer2.Init.Prescaler + 1);
double timer2_cnt_res = 1 / timer2_cnt_freq;
double user_signal_time_period = capture_difference * timer2_cnt_res;
double user_signal_freq = 1 / user_signal_time_period;
char usr_msg[128];
sprintf(usr_msg, "External signal frequency is: %f Hz.\\r\\n", user_signal_freq);
HAL_UART_Transmit(&uart_2, (uint8_t *)usr_msg, strlen(usr_msg), HAL_MAX_DELAY);
is_capture_done = FALSE;
return 0;
void SystemClockConfig(void)
uint32_t fLatency = FLASH_LATENCY_1;
RCC_OscInitTypeDef osc;
osc.HSEState = RCC_HSE_ON;
osc.HSIState = RCC_HSI_ON;
osc.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_HSI;
osc.PLL.PLLState = RCC_PLL_ON;
osc.PLL.PLLSource = RCC_PLLSOURCE_HSE;
osc.PLL.PLLM = 8;
osc.PLL.PLLN = 100;
osc.PLL.PLLP = RCC_PLLP_DIV2;
if(HAL_RCC_OscConfig(&osc) != HAL_OK)
Error_Handler();
RCC_ClkInitTypeDef rcc_clk;
rcc_clk.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
rcc_clk.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
rcc_clk.AHBCLKDivider = RCC_SYSCLK_DIV1;
rcc_clk.APB1CLKDivider = RCC_HCLK_DIV2;
rcc_clk.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig(&rcc_clk, fLatency);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
uint32_t sys_speed = HAL_RCC_GetSysClockFreq();
uint32_t hclck_speed = HAL_RCC_GetHCLKFreq();
uint32_t pcl1_speed = HAL_RCC_GetPCLK1Freq();
uint32_t pcl2_speed = HAL_RCC_GetPCLK2Freq();
void LSE_Configuration(void)
HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSI, RCC_MCODIV_4);
void Init_Pulse(void)
ch1_pulse = Calc_Pulse(ch1_freq);
ch2_pulse = Calc_Pulse(ch2_freq);
ch3_pulse = Calc_Pulse(ch3_freq);
ch4_pulse = Calc_Pulse(ch4_freq);
uint32_t Calc_Pulse(uint32_t ch_freq)
uint32_t pcl1_freq = HAL_RCC_GetPCLK1Freq() * 2;
uint32_t result  = ((1.0 / ch_freq) / (1.0 / (pcl1_freq / (1.0 + timer2_prescaler)))) / 2;
return result;
void UART2_Init(void)
uart_2.Instance = USART2;
uart_2.Init.BaudRate = 9600;
uart_2.Init.WordLength = UART_WORDLENGTH_8B;
uart_2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
uart_2.Init.StopBits = UART_STOPBITS_1;
uart_2.Init.Parity = UART_PARITY_NONE;
uart_2.Init.Mode = UART_MODE_TX;
if(HAL_UART_Init(&uart_2) != HAL_OK)
Error_Handler();
void Timer2_Init(void)
htimer2.Instance = TIM2;
htimer2.Init.Period = 0xffffffff;
htimer2.Init.Prescaler = timer2_prescaler;
if(HAL_TIM_OC_Init(&htimer2) != HAL_OK)
Error_Handler();
TIM_OC_InitTypeDef tim2OC_init;
tim2OC_init.OCMode = TIM_OCMODE_TOGGLE;
tim2OC_init.OCPolarity = TIM_OCPOLARITY_HIGH;
tim2OC_init.Pulse = ch1_pulse;
if(HAL_TIM_OC_ConfigChannel(&htimer2, &tim2OC_init, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
tim2OC_init.Pulse = ch2_pulse;
if(HAL_TIM_OC_ConfigChannel(&htimer2, &tim2OC_init, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
tim2OC_init.Pulse = ch3_pulse;
if(HAL_TIM_OC_ConfigChannel(&htimer2, &tim2OC_init, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
tim2OC_init.Pulse = ch4_pulse;
if(HAL_TIM_OC_ConfigChannel(&htimer2, &tim2OC_init, TIM_CHANNEL_4) != HAL_OK)
Error_Handler();
void GPIO_Init()
GPIO_InitTypeDef led_gpio;
led_gpio.Mode = GPIO_MODE_OUTPUT_PP;
led_gpio.Pin = GPIO_PIN_13;
led_gpio.Pull = GPIO_NOPULL;
led_gpio.Speed = GPIO_SPEED_LOW;
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_Init(GPIOD, &led_gpio);
void Error_Handler(void)
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htimer)
if(!is_capture_done)
if(count == 1)
uint32_t value = __HAL_TIM_GET_COMPARE(htimer, TIM_CHANNEL_1);
input_captures[0] = value;
count++;
else
uint32_t value = __HAL_TIM_GET_COMPARE(htimer, TIM_CHANNEL_1);
input_captures[1] = value;
is_capture_done = TRUE;
count = 1;
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htimer)
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
void HAL_ETH_RxCpltCallback(ETH_HandleTypeDef *heth)
DKFPRINTF(0x01, "\\n");
flgs_int |= FLG_RX;
eth_rx_count ++;
void HAL_ETH_TxCpltCallback(ETH_HandleTypeDef *heth)
DKFPRINTF(0x10, "\\n");
flgs_int |= FLG_TX;
void HAL_ETH_ErrorCallback(ETH_HandleTypeDef *heth)
DKFPRINTF(0xff, "\\n");
SYSERR_PRINT("error?\\n");
flgs_int |= FLG_ER;
static void inthdr_ether(unsigned int intnum, void *sp)
DKFPRINTF(0x01, "\\n");
int_sp = sp;
flgs_int = 0;
HAL_ETH_IRQHandler(&EthHandle);
DKFPRINTF(0x01, "flgs_int = %02x\\n", flgs_int);
if(flgs_int & FLG_RX) {
DKPRINTF(0x04, "*");
DKFPRINTF(0x01, "wakeup\\n");
event_wakeup_ISR(int_sp, &interrupt_evtque, 0);
void HAL_ETH_MspInit(ETH_HandleTypeDef* heth)
DKFPRINTF(0x01, "\\n");
GPIO_InitTypeDef GPIO_InitStruct;
if(heth->Instance==ETH) {
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
__HAL_RCC_ETH_CLK_ENABLE();
GPIO_InitStruct.Pin = RMII_TXD1_Pin|RMII_TXD0_Pin|RMII_TX_EN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
static int rmii_task(void *arg)
(void)arg;
for(;;) {
if(EthHandle.Instance->MMCRGUFCR > 0U) {
task_exit();
} else if(EthHandle.Instance->MMCRFCECR > 10U) {
SYSCFG->PMC &= ~SYSCFG_PMC_MII_RMII_SEL;
SYSCFG->PMC |= SYSCFG_PMC_MII_RMII_SEL;
EthHandle.Instance->MMCCR |= ETH_MMCCR_CR;
} else {
task_sleep(200);
return 0;
static int ether_register(struct st_device *dev, char *param)
eventqueue_register(&interrupt_evtque, "ether_int",
ether_event, sizeof(unsigned char), ETH_RXBUFNB + 1);
register_interrupt(IRQ2VECT(ETH_IRQn), inthdr_ether);
EthHandle.Instance = ETH;
EthHandle.Init.MACAddr = macaddress;
EthHandle.Init.AutoNegotiation = ETH_AUTONEGOTIATION_ENABLE;
EthHandle.Init.Speed = ETH_SPEED_100M;
EthHandle.Init.DuplexMode = ETH_MODE_FULLDUPLEX;
EthHandle.Init.MediaInterface = ETH_MEDIA_INTERFACE_RMII;
EthHandle.Init.RxMode = ETH_RXINTERRUPT_MODE;
EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_HARDWARE;
EthHandle.Init.ChecksumMode = ETH_CHECKSUM_BY_SOFTWARE;
EthHandle.Init.PhyAddress = LAN8742A_PHY_ADDRESS;
if(HAL_ETH_Init(&EthHandle) == HAL_OK) {
HAL_ETH_DMATxDescListInit(&EthHandle, DMATxDscrTab, &Tx_Buff[0][0], ETH_TXBUFNB);
HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
if(HAL_GetREVID() == 0x1000) {
tkprintf("RMII configuration Hardware Bug Version(0x1000)\\n");
task_add(rmii_task, "ether_rmii", TASK_PRIORITY_DEVICE_DRIVER, &tcb, stack, SIZEOFSTACK, 0);
return 0;
static int ether_open(struct st_device *dev)
DKFPRINTF(0x01, "\\n");
HAL_NVIC_SetPriority(ETH_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(ETH_IRQn);
HAL_ETH_Start(&EthHandle);
return 0;
static int ether_close(struct st_device *dev)
DKFPRINTF(0x01, "\\n");
HAL_ETH_Stop(&EthHandle);
return 0;
static int ether_read(struct st_device *dev, void *data, unsigned int size)
int i;
unsigned short len = 0;
unsigned char *buffer;
volatile ETH_DMADescTypeDef *dmarxdesc;
DKFPRINTF(0x81, "size = %d\\n", size);
if(HAL_ETH_GetReceivedFrame_IT(&EthHandle) != HAL_OK) {
DKPRINTF(0x07, "ETH no Receive data\\n");
goto readend;
} else {
DKPRINTF(0x01, "ETH Receive OK\\n");
DKPRINTF(0x01, "SegCount = %d\\n", (int)EthHandle.RxFrameInfos.SegCount);
DKPRINTF(0x01, "RxFrameInfos.buffer = %08X\\n", (unsigned int)EthHandle.RxFrameInfos.buffer);
len = EthHandle.RxFrameInfos.length;
buffer = (uint8_t *)EthHandle.RxFrameInfos.buffer;
DKPRINTF(0x01, "RxFrameInfos.length = %d\\n", len);
memorycopy(data, buffer, len);
KXBDUMP(0x02, data, len);
__DMB();
dmarxdesc = EthHandle.RxFrameInfos.FSRxDesc;
for(i=0; i< EthHandle.RxFrameInfos.SegCount; i++) {
__DMB();
dmarxdesc->Status |= ETH_DMARXDESC_OWN;
__DMB();
dmarxdesc = (ETH_DMADescTypeDef *)(dmarxdesc->Buffer2NextDescAddr);
EthHandle.RxFrameInfos.SegCount = 0;
__DMB();
if((EthHandle.Instance->DMASR & ETH_DMASR_RBUS) != (uint32_t)RESET) {
EthHandle.Instance->DMASR = ETH_DMASR_RBUS;
EthHandle.Instance->DMARPDR = 0;
readend:
return len;
static int ether_write(struct st_device *dev, const void *data, unsigned int size)
unsigned char *buffer = (unsigned char *)(EthHandle.TxDesc->Buffer1Addr);
int rtn = size;
HAL_StatusTypeDef res;
__IO ETH_DMADescTypeDef *DmaTxDesc;
DKFPRINTF(0x10, "size = %d\\n", size);
DmaTxDesc = EthHandle.TxDesc;
if((DmaTxDesc->Status & ETH_DMATXDESC_OWN) != (uint32_t)RESET) {
SYSERR_PRINT("DmaTxDesc use\\n");
return -1;
__DMB();
memorycopy(buffer, data, size);
KXBDUMP(0x02, buffer, size);
__DMB();
res = HAL_ETH_TransmitFrame(&EthHandle, size);
if(res != HAL_OK) {
SYSERR_PRINT("HAL_ETH_TransmitFrame error %d\\n", res);
__DMB();
if((EthHandle.Instance->DMASR & ETH_DMASR_TUS) != (uint32_t)RESET) {
EthHandle.Instance->DMASR = ETH_DMASR_TUS;
EthHandle.Instance->DMATPDR = 0;
return rtn;
static int ether_ioctl(struct st_device *dev, unsigned int com, unsigned int arg, void *param)
DKFPRINTF(0x01, "com = %ld arg = %ld\\n", com, arg);
switch(com) {
case IOCMD_ETHER_GET_MACADDR:
unsigned char *mac = (unsigned char *)param;
int i;
for(i=0; i<6; i++) {
mac[i] = macaddress[i];
DKPRINTF(0x01, "MAC Addr %02X:%02X:%02X:%02X:%02X:%02X\\n",
(int)mac[0], (int)mac[1], (int)mac[2],
(int)mac[3], (int)mac[4], (int)mac[5]);
break;
case IOCMD_ETHER_SET_MACADDR:
return -1;
break;
case IOCMD_ETHER_CLEAR_BUF:
break;
case IOCMD_ETHER_LINK_UP:
HAL_ETH_DMARxDescListInit(&EthHandle, DMARxDscrTab, &Rx_Buff[0][0], ETH_RXBUFNB);
break;
case IOCMD_ETHER_LINK_DOWN:
HAL_ETH_Stop(&EthHandle);
break;
case IOCMD_ETHER_GET_LINK_STATUS:
unsigned long phyreg;
int stat = 0;
HAL_ETH_ReadPHYRegister(&EthHandle, PHY_BSR, &phyreg);
DKPRINTF(0x01, "PHY_BSR = %08X\\n", phyreg);
switch(phyreg & PHY_FULLDUPLEX_100M) {
case PHY_FULLDUPLEX_100M:
stat |= IORTN_BIT_ETHER_100M;
stat |= IORTN_BIT_ETHER_FULLDUPLEX;
break;
case PHY_HALFDUPLEX_100M:
stat |= IORTN_BIT_ETHER_100M;
break;
case PHY_FULLDUPLEX_10M:
stat |= IORTN_BIT_ETHER_FULLDUPLEX;
break;
case PHY_HALFDUPLEX_10M:
break;
default:
break;
if((phyreg & PHY_LINKED_STATUS) != 0) {
stat |= IORTN_BIT_ETHER_LINK_UP;
return stat;
break;
default:
SYSERR_PRINT("Unknow command %08X arg %08X\\n", com, arg);
break;
return 0;
static int ether_select(struct st_device *dev, unsigned int timeout)
DKFPRINTF(0x08, "timeout = %d\\n", timeout);
int rtn = 0;
rtn = event_wait(&interrupt_evtque, 0, timeout);
DKFPRINTF(0x08, "return=%d\\n", rtn);
return rtn;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_SPI1_Init();
MX_USART2_UART_Init();
MX_I2C1_Init();
MX_TIM1_Init();
MX_TIM2_Init();
MX_RTC_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 400000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_RTC_Init(void)
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if(HAL_RTCEx_BKUPRead(&hrtc, RTC_BKP_DR0) != 0x32F2){
if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_RTCEx_BKUPWrite(&hrtc,RTC_BKP_DR0,0x32F2);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_TIM1_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig;
TIM_MasterConfigTypeDef sMasterConfig;
htim1.Instance = TIM1;
htim1.Init.Prescaler = 84;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 1000;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_TIM2_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig;
TIM_MasterConfigTypeDef sMasterConfig;
TIM_OC_InitTypeDef sConfigOC;
htim2.Instance = TIM2;
htim2.Init.Prescaler = 1;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 0;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV4;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_TIM_PWM_Init(&htim2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_LOW;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_TIM_MspPostInit(&htim2);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_DMA_Init(void)
__HAL_RCC_DMA2_CLK_ENABLE();
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Stream0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream0_IRQn);
HAL_NVIC_SetPriority(DMA1_Stream6_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream6_IRQn);
HAL_NVIC_SetPriority(DMA1_Stream7_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream7_IRQn);
HAL_NVIC_SetPriority(DMA2_Stream0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream0_IRQn);
HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, BackLight_Pin|LCD_RST_Pin|LCD_D1_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, LCD_RD_Pin|LCD_WR_Pin|LCD_RS_Pin|LCD_D7_Pin
|LCD_D0_Pin|LCD_D2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, LCD_CS_Pin|LCD_D6_Pin|LCD_D3_Pin|LCD_D5_Pin
|LCD_D4_Pin|SD_CS_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BackLight_Pin|LCD_RST_Pin|LCD_D1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LCD_RD_Pin|LCD_WR_Pin|LCD_RS_Pin|LCD_D7_Pin
|LCD_D0_Pin|LCD_D2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LCD_CS_Pin|LCD_D6_Pin|LCD_D3_Pin|LCD_D5_Pin
|LCD_D4_Pin|SD_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void _Error_Handler(char * file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
uint32_t j = 0;
uint32_t check_vdata[N] = {0};
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED2);
__HAL_RCC_SYSCFG_CLK_ENABLE();
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWR_EnableBkUpAccess();
if (READ_REG(RTC->BKP4R) == 0)
WRITE_REG( RTC->BKP4R, 0x1 );
WRITE_REG( RTC->BKP0R, 0x0 );
WRITE_REG( RTC->BKP1R, 0x0 );
WRITE_REG( RTC->BKP2R, 0x0 );
WRITE_REG( RTC->BKP3R, 0x0 );
__HAL_RCC_CLEAR_RESET_FLAGS();
else
if ((__HAL_RCC_GET_FLAG(RCC_FLAG_FWRST) != RESET)
&&  ((READ_REG(RTC->BKP0R) == 2)))
WRITE_REG( RTC->BKP4R, 0x0 );
BSP_LED_On(LED2);
while (1)
else if ((__HAL_RCC_GET_FLAG(RCC_FLAG_FWRST) != RESET)
&&  ((READ_REG(RTC->BKP0R) == 1)))
WRITE_REG( RTC->BKP4R, 0x2 );
WRITE_REG( RTC->BKP0R, 0x0 );
__HAL_RCC_CLEAR_RESET_FLAGS();
else
WRITE_REG( RTC->BKP1R, 0x1 );
Error_Handler();
fw_init.CodeSegmentStartAddress      = 0x08010000;
fw_init.CodeSegmentLength            = 512;
fw_init.NonVDataSegmentStartAddress = 0x080FF000;
fw_init.NonVDataSegmentLength       = 256;
fw_init.VDataSegmentStartAddress    = 0x20000000;
fw_init.VDataSegmentLength          = 576;
fw_init.VolatileDataExecution       = FIREWALL_VOLATILEDATA_NOT_EXECUTABLE;
fw_init.VolatileDataShared          = FIREWALL_VOLATILEDATA_SHARED;
if (HAL_FIREWALL_Config(&fw_init) != HAL_OK)
Error_Handler();
HAL_FIREWALL_EnableFirewall();
protected_function();
if (READ_REG(RTC->BKP4R) == 2)
WRITE_REG( RTC->BKP0R, 0x2 );
for (j=0; j<N; j++)
check_vdata[j] = protected_volatile_array[j];
if (READ_REG(RTC->BKP4R) == 2)
WRITE_REG( RTC->BKP3R, 0x1 );
Error_Handler();
data_cmp(check_vdata, expected_vdata, N);
WRITE_REG( RTC->BKP0R, 0x1 );
check_vdata[0] = protected_non_volatile_array[0];
WRITE_REG( RTC->BKP2R, 0x1 );
Error_Handler();
return  check_vdata[0];
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
while(1);
void Error_Handler(void)
WRITE_REG( RTC->BKP4R, 0x0 );
while(1)
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(300);
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(300);
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(300);
BSP_LED_On(LED2);
HAL_Delay(700);
BSP_LED_Off(LED2);
HAL_Delay(700);
BSP_LED_On(LED2);
HAL_Delay(700);
BSP_LED_Off(LED2);
HAL_Delay(700);
BSP_LED_On(LED2);
HAL_Delay(700);
BSP_LED_Off(LED2);
HAL_Delay(700);
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(300);
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(300);
BSP_LED_On(LED2);
HAL_Delay(300);
BSP_LED_Off(LED2);
HAL_Delay(800);
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
void data_cmp(uint32_t *Text, uint32_t *RefText, uint32_t Size)
uint32_t i;
for (i=0;i<Size;i++)
if (Text[i] != RefText[i])
Error_Handler();
void assert_failed(char *file, uint32_t line)
while (1)
int main(void)
int32_t timeout;
SCB_EnableICache();
SCB_EnableDCache();
timeout = 0xFFFF;
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) != RESET) && (timeout-- > 0));
if ( timeout < 0 )
Error_Handler();
HAL_Init();
SystemClock_Config();
__HAL_RCC_HSEM_CLK_ENABLE();
HAL_HSEM_FastTake(HSEM_ID_0);
HAL_HSEM_Release(HSEM_ID_0,0);
timeout = 0xFFFF;
while((__HAL_RCC_GET_FLAG(RCC_FLAG_D2CKRDY) == RESET) && (timeout-- > 0));
if ( timeout < 0 )
Error_Handler();
MX_GPIO_Init();
while (1)
HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_14);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 160;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
|RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_14;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
pikaScriptInit();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
xdev_out(uart_putc);
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_TIM3_Init();
MX_TIM1_Init();
MX_TIM2_Init();
MX_TIM4_Init();
MX_TIM10_Init();
MX_USART6_UART_Init();
uint8_t buf[5];
uint16_t tx_rpm[4] = { 500, 500, 500, 500 };
if (HAL_TIM_Encoder_Init(&htim1, &sConfig1) != HAL_OK) {
Error_Handler();
HAL_TIM_Encoder_Start(&htim1, TIM_CHANNEL_ALL);
TIM1->CNT = 30000;
if (HAL_TIM_Encoder_Init(&htim2, &sConfig2) != HAL_OK) {
Error_Handler();
HAL_TIM_Encoder_Start(&htim2, TIM_CHANNEL_ALL);
TIM2->CNT = 30000;
if (HAL_TIM_Encoder_Init(&htim3, &sConfig3) != HAL_OK) {
Error_Handler();
HAL_TIM_Encoder_Start(&htim3, TIM_CHANNEL_ALL);
TIM3->CNT = 30000;
if (HAL_TIM_Encoder_Init(&htim4, &sConfig4) != HAL_OK) {
Error_Handler();
HAL_TIM_Encoder_Start(&htim4, TIM_CHANNEL_ALL);
TIM4->CNT = 30000;
HAL_TIM_Base_Start_IT(&htim10);
while (1) {
for (int i = 0; i < 4; i++) {
tx_rpm[i] = (int)pwm[i] + 500;
buf[0] = (tx_rpm[0] & 0xFF);
buf[1] = (((tx_rpm[0] >> 8) + (tx_rpm[1] << 2)) & 0xFF);
buf[2] = (((tx_rpm[1] >> 6) + (tx_rpm[2] << 4)) & 0xFF);
buf[3] = (((tx_rpm[2] >> 4) + (tx_rpm[3] << 6)) & 0xFF);
buf[4] = ((tx_rpm[3] >> 2) & 0xFF);
HAL_UART_Transmit(&huart6, buf, sizeof(buf), 0xFFFF);
xprintf("%d,%d,%d,%d\\r\\n",(int)pwm[0],(int)pwm[1],(int)pwm[2],(int)pwm[3]);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
htim1.Instance = TIM1;
htim1.Init.Prescaler = 1;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 59999;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
sConfig1.EncoderMode = TIM_ENCODERMODE_TI1;
sConfig1.IC1Polarity = TIM_ICPOLARITY_RISING;
sConfig1.IC1Selection = TIM_ICSELECTION_DIRECTTI;
sConfig1.IC1Prescaler = TIM_ICPSC_DIV1;
sConfig1.IC1Filter = 0;
sConfig1.IC2Polarity = TIM_ICPOLARITY_RISING;
sConfig1.IC2Selection = TIM_ICSELECTION_DIRECTTI;
sConfig1.IC2Prescaler = TIM_ICPSC_DIV1;
sConfig1.IC2Filter = 0;
if (HAL_TIM_Encoder_Init(&htim1, &sConfig1) != HAL_OK)
Error_Handler();
sMasterConfig1.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig1.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig1) != HAL_OK)
Error_Handler();
static void MX_TIM2_Init(void)
htim2.Instance = TIM2;
htim2.Init.Prescaler = 1;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 59999;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
sConfig2.EncoderMode = TIM_ENCODERMODE_TI1;
sConfig2.IC1Polarity = TIM_ICPOLARITY_RISING;
sConfig2.IC1Selection = TIM_ICSELECTION_DIRECTTI;
sConfig2.IC1Prescaler = TIM_ICPSC_DIV1;
sConfig2.IC1Filter = 0;
sConfig2.IC2Polarity = TIM_ICPOLARITY_RISING;
sConfig2.IC2Selection = TIM_ICSELECTION_DIRECTTI;
sConfig2.IC2Prescaler = TIM_ICPSC_DIV1;
sConfig2.IC2Filter = 0;
if (HAL_TIM_Encoder_Init(&htim2, &sConfig2) != HAL_OK)
Error_Handler();
sMasterConfig2.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig2.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig2) != HAL_OK)
Error_Handler();
static void MX_TIM3_Init(void)
htim3.Instance = TIM3;
htim3.Init.Prescaler = 1;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 59999;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
sConfig3.EncoderMode = TIM_ENCODERMODE_TI1;
sConfig3.IC1Polarity = TIM_ICPOLARITY_RISING;
sConfig3.IC1Selection = TIM_ICSELECTION_DIRECTTI;
sConfig3.IC1Prescaler = TIM_ICPSC_DIV1;
sConfig3.IC1Filter = 0;
sConfig3.IC2Polarity = TIM_ICPOLARITY_RISING;
sConfig3.IC2Selection = TIM_ICSELECTION_DIRECTTI;
sConfig3.IC2Prescaler = TIM_ICPSC_DIV1;
sConfig3.IC2Filter = 0;
if (HAL_TIM_Encoder_Init(&htim3, &sConfig3) != HAL_OK)
Error_Handler();
sMasterConfig3.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig3.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig3) != HAL_OK)
Error_Handler();
static void MX_TIM4_Init(void)
htim4.Instance = TIM4;
htim4.Init.Prescaler = 1;
htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
htim4.Init.Period = 59999;
htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
sConfig4.EncoderMode = TIM_ENCODERMODE_TI1;
sConfig4.IC1Polarity = TIM_ICPOLARITY_RISING;
sConfig4.IC1Selection = TIM_ICSELECTION_DIRECTTI;
sConfig4.IC1Prescaler = TIM_ICPSC_DIV1;
sConfig4.IC1Filter = 0;
sConfig4.IC2Polarity = TIM_ICPOLARITY_RISING;
sConfig4.IC2Selection = TIM_ICSELECTION_DIRECTTI;
sConfig4.IC2Prescaler = TIM_ICPSC_DIV1;
sConfig4.IC2Filter = 0;
if (HAL_TIM_Encoder_Init(&htim4, &sConfig4) != HAL_OK)
Error_Handler();
sMasterConfig4.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig4.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig4) != HAL_OK)
Error_Handler();
static void MX_TIM10_Init(void)
htim10.Instance = TIM10;
htim10.Init.Prescaler = 999;
htim10.Init.CounterMode = TIM_COUNTERMODE_UP;
htim10.Init.Period = 8400;
htim10.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim10.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim10) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_USART6_UART_Init(void)
huart6.Instance = USART6;
huart6.Init.BaudRate = 115200;
huart6.Init.WordLength = UART_WORDLENGTH_8B;
huart6.Init.StopBits = UART_STOPBITS_1;
huart6.Init.Parity = UART_PARITY_NONE;
huart6.Init.Mode = UART_MODE_TX_RX;
huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart6.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart6) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main( void )
int16_t i, j;
uint16_t chan;
uint32_t n;
int16_t lo, hi;
uint16_t err[4];
int16_t tc_temp[4];
int16_t ref_temp[4];
uint32_t count;
HAL_StatusTypeDef status;
HAL_Init( );
SystemClock_Config( );
MX_USART2_UART_Init();
MX_GPIO_Init( );
MX_ADC_Init( );
MX_I2C1_Init( );
MX_SPI1_Init( );
MX_USART1_UART_Init();
HAL_GPIO_WritePin( UART2_DE1_GPIO_Port, UART2_DE1_Pin, GPIO_PIN_SET );
HAL_GPIO_WritePin( UART2_RE1_N_GPIO_Port, UART2_RE1_N_Pin, GPIO_PIN_SET );
HAL_GPIO_WritePin( UART2_DE2_GPIO_Port, UART2_DE2_Pin, GPIO_PIN_RESET );
HAL_GPIO_WritePin( UART2_RE2_N_GPIO_Port, UART2_RE2_N_Pin, GPIO_PIN_RESET );
MX_DMA_Init();
MX_TIM2_Init();
HAL_TIM_Base_Start(&htim2);
MX_NVIC_Init( );
printf( "\\r\\nHello World.\\r\\n" );
printf( "Build: %s %s\\r\\n", __DATE__, __TIME__ );
HAL_GPIO_WritePin( LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET );
EEPROM_ReadMac48( );
printf("MAC: " );
for ( i = 0; i < 6; i++ )
if ( i ) printf(":");
printf( "%02X", EEPROM_buffer[i] );
printf("\\r\\n" );
EEPROM_ReadSN128( );
printf( "SN: " );
for ( i = 0; i < 16; i++ )
printf( "%02X", EEPROM_buffer[i] );
printf( "\\r\\n" );
printf( "MCU ID: ");
for (i=11; i>=0; i--)
uint8_t reg = READ_REG(*(   (uint8_t *)(UID_BASE + i) ) );
printf( "%02X", (int)reg );
printf("\\r\\n");
printf("MCU ID: '");
for (i=11; i>=0; i--)
uint8_t reg = READ_REG(*( (uint8_t *)(UID_BASE + i) ));
if (i > 4)
printf("%c", (char)reg );
else
printf("%02X", (int)reg );
printf("'\\r\\n");
printf( "MCU ID: %08lX%08lX%08lX\\r\\n", HAL_GetUIDw2( ), HAL_GetUIDw1( ),
HAL_GetUIDw0( ) );
for ( j = 0; j < 15; j++ )
status = EEPROM_ReadBlock( j );
if ( HAL_OK != status )
printf( "Read Status: %d\\r\\n", (int) status );
printf( "BLK[%02X]: ", j );
for ( i = 0; i < 16; i++ )
printf( "%02X", EEPROM_buffer[i] );
printf( "\\r\\n" );
HAL_GPIO_WritePin( LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET );
count = 0;
while ( 1 )
count++;
HAL_GPIO_WritePin( LED_GRN_GPIO_Port, LED_GRN_Pin, GPIO_PIN_SET );
uint32_t start = htim2.Instance->CNT;
for ( chan = 0; chan < 4; chan++ )
n = SPI_Read32( chan );
lo = n & 0xFFFF;
hi = n >> 16;
err[chan] = n & 0x07;
if ( err[chan] )
tc_temp[chan] = 0;
else
tc_temp[chan] = ((int16_t)hi / 4);
ref_temp[chan] = ( (int16_t)lo /16 );
uint32_t finish = htim2.Instance->CNT;
printf( "Start: %lu\\r\\n", start);
printf( "End:   %lu\\r\\n", finish);
printf( "Delta: %lu\\r\\n", finish - start);
for ( chan = 0; chan < 4; chan++ )
printf("%d: %04X_%04X,%1d,", chan, hi, lo, err[chan]);
PrintQuarter(ref_temp[chan]/4);
printf(",");
PrintQuarter(tc_temp[chan]);
if (chan == 3) printf("\\r\\n");
printf( "%06ld,", count );
for ( chan = 0; chan < 4; chan++ )
printf( "%1d,", err[chan] );
for ( chan = 0; chan < 4; chan++ )
printf( "%d,", ref_temp[chan] );
for ( chan = 0; chan < 4; chan++ )
printf( "%6d,", tc_temp[chan] );
printf( "\\r\\n" );
HAL_GPIO_WritePin( LED_GRN_GPIO_Port, LED_GRN_Pin, GPIO_PIN_RESET );
Delay_ms(2000);
void SystemClock_Config( void )
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI14
|RCC_OSCILLATORTYPE_HSI48;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.HSI14CalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if ( HAL_RCC_OscConfig( &RCC_OscInitStruct ) != HAL_OK )
Error_Handler( );
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
| RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if ( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_1 ) != HAL_OK )
Error_Handler( );
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART1
|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;
if ( HAL_RCCEx_PeriphCLKConfig( &PeriphClkInit ) != HAL_OK )
Error_Handler( );
static void MX_NVIC_Init( void )
HAL_NVIC_SetPriority( USART2_IRQn, 0, 0 );
HAL_NVIC_EnableIRQ( USART2_IRQn );
HAL_NVIC_SetPriority( USART1_IRQn, 0, 0 );
HAL_NVIC_EnableIRQ( USART1_IRQn );
void Delay_ms(uint32_t delay_ms)
uint32_t start_time_ms = HAL_GetTick();
while ( (HAL_GetTick() - start_time_ms) < delay_ms)
return;
void PrintQuarter( int16_t value )
printf( "%d", (uint16_t) (value/4) );
switch (value & 3)
case 0:
printf( ".00" );
break;
case 1:
printf( ".25" );
break;
case 2:
printf( ".50" );
break;
case 3:
printf( ".75" );
break;
void Error_Handler( void )
__disable_irq( );
while ( 1 )
void assert_failed(uint8_t *file, uint32_t line)
void SystemApp_Init(void)
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
Gpio_PreInit();
DBG_Init();
UTIL_ADV_TRACE_Init();
UTIL_ADV_TRACE_RegisterTimeStampFunction(TimestampNow);
UTIL_ADV_TRACE_SetVerboseLevel(VERBOSE_LEVEL);
SYS_InitMeasurement();
UTIL_LPM_Init();
UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);
MBMUXIF_Init();
UTIL_TIMER_Init();
void Process_Sys_Notif(MBMUX_ComParam_t *ComObj)
uint32_t  notif_ack_id;
notif_ack_id = ComObj->MsgId;
switch (notif_ack_id)
case SYS_OTHER_MSG_ID:
APP_LOG(TS_ON, VLEVEL_H, "CM4<(System)\\r\\n");
ComObj->ParamCnt = 0;
ComObj->ReturnVal = 7;
break;
default:
break;
APP_LOG(TS_ON, VLEVEL_H, "CM4>(System)\\r\\n");
MBMUXIF_SystemSendAck(FEAT_INFO_SYSTEM_ID);
void UTIL_SEQ_EvtIdle(uint32_t task_id_bm, uint32_t evt_waited_bm)
UTIL_SEQ_Run(~task_id_bm);
return;
void UTIL_SEQ_Idle(void)
UTIL_LPM_EnterLowPower();
uint8_t GetBatteryLevel(void)
uint8_t batteryLevel = 0;
uint16_t batteryLevelmV;
batteryLevelmV = (uint16_t) SYS_GetBatteryLevel();
if (batteryLevelmV > VDD_BAT)
batteryLevel = LORAWAN_MAX_BAT;
else if (batteryLevelmV < VDD_MIN)
batteryLevel = 0;
else
batteryLevel = (((uint32_t)(batteryLevelmV - VDD_MIN) * LORAWAN_MAX_BAT) / (VDD_BAT - VDD_MIN));
APP_LOG(TS_ON, VLEVEL_M, "VDDA= %d\\r\\n", batteryLevel);
return batteryLevel;
uint16_t GetTemperatureLevel(void)
uint16_t temperatureLevel = 0;
temperatureLevel = (uint16_t)(SYS_GetTemperatureLevel() / 256);
return temperatureLevel;
static void MBMUXIF_Init(void)
FEAT_INFO_List_t *p_cm0plus_supprted_features_list;
int8_t init_status;
APP_LOG(TS_ON, VLEVEL_H, "\\r\\nCM4: System Initialisation started \\r\\n");
init_status = MBMUXIF_SystemInit();
if (init_status < 0)
while (1) {}
HAL_PWREx_ReleaseCore(PWR_CORE_CPU2);
MBMUXIF_SetCpusSynchroFlag(CPUS_BOOT_SYNC_ALLOW_CPU2_TO_START);
APP_LOG(TS_ON, VLEVEL_H, "CM4: System Initialisation done: Wait for CM0PLUS \\r\\n");
MBMUXIF_WaitCm0MbmuxIsInitialised();
APP_LOG(TS_ON, VLEVEL_H, "CM0PLUS: System Initialisation started \\r\\n");
p_cm0plus_supprted_features_list = MBMUXIF_SystemSendCm0plusInfoListReq();
MBMUX_SetCm0plusFeatureListPtr(p_cm0plus_supprted_features_list);
APP_LOG(TS_ON, VLEVEL_H, "System Initialisation CM4-CM0PLUS completed \\r\\n");
init_status = MBMUXIF_SystemPrio_Add(FEAT_INFO_SYSTEM_NOTIF_PRIO_A_ID);
if (init_status < 0)
Error_Handler();
MBMUXIF_SetCpusSynchroFlag(CPUS_BOOT_SYNC_RTC_REGISTERED);
APP_LOG(TS_ON, VLEVEL_H, "System_Priority_A Registration for RTC Alarm handling completed \\r\\n");
init_status = MBMUXIF_TraceInit();
if (init_status < 0)
Error_Handler();
APP_LOG(TS_ON, VLEVEL_H, "Trace registration CM4-CM0PLUS completed \\r\\n");
init_status = MBMUXIF_LoraInit();
if (init_status < 0)
Error_Handler();
APP_LOG(TS_ON, VLEVEL_H, "Radio registration CM4-CM0PLUS completed \\r\\n");
init_status = MBMUXIF_RadioInit();
if (init_status < 0)
Error_Handler();
APP_LOG(TS_ON, VLEVEL_H, "Radio registration CM4-CM0PLUS completed \\r\\n");
static void TimestampNow(uint8_t *buff, uint16_t *size)
SysTime_t curtime = SysTimeGet();
tiny_snprintf_like((char *)buff, MAX_TS_SIZE, "%ds%03d:", curtime.Seconds, curtime.SubSeconds);
*size = strlen((char *)buff);
static void Gpio_PreInit(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Pin = GPIO_PIN_All & (~(GPIO_PIN_13 | GPIO_PIN_14));
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_All;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
__HAL_RCC_GPIOA_CLK_DISABLE();
__HAL_RCC_GPIOB_CLK_DISABLE();
__HAL_RCC_GPIOC_CLK_DISABLE();
__HAL_RCC_GPIOH_CLK_DISABLE();
void UTIL_ADV_TRACE_PreSendHook(void)
UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);
void UTIL_ADV_TRACE_PostSendHook(void)
UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);
static void tiny_snprintf_like(char *buf, uint32_t maxsize, const char *strFormat, ...)
va_list vaArgs;
va_start(vaArgs, strFormat);
UTIL_ADV_TRACE_VSNPRINTF(buf, maxsize, strFormat, vaArgs);
va_end(vaArgs);
HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
return HAL_OK;
uint32_t HAL_GetTick(void)
return TIMER_IF_GetTimerValue();
void HAL_Delay(__IO uint32_t Delay)
TIMER_IF_DelayMs(Delay);
int main(void)
SCB->SHCSR |= SCB_SHCSR_SECUREFAULTENA_Msk;
HAL_Init();
SystemClock_Config();
MX_GTZC_S_Init();
MX_GPIO_Init();
MX_ICACHE_Init();
SecureInitIODone = 1;
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
HAL_GPIO_ConfigPinAttributes(GPIOA, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOB, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOC, (GPIO_PIN_All & ~(GPIO_PIN_7)), GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOD, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOE, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOF, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOG, GPIO_PIN_All, GPIO_PIN_NSEC);
HAL_GPIO_ConfigPinAttributes(GPIOH, GPIO_PIN_All, GPIO_PIN_NSEC);
NonSecure_Init();
while (1)
static void NonSecure_Init(void)
funcptr_NS NonSecure_ResetHandler;
SCB_NS->VTOR = VTOR_TABLE_NS_START_ADDR;
__TZ_set_MSP_NS((*(uint32_t *)VTOR_TABLE_NS_START_ADDR));
NonSecure_ResetHandler = (funcptr_NS)(*((uint32_t *)((VTOR_TABLE_NS_START_ADDR) + 4U)));
NonSecure_ResetHandler();
static void MX_GTZC_S_Init(void)
MPCBB_ConfigTypeDef MPCBB_NonSecureArea_Desc = {0};
MPCBB_NonSecureArea_Desc.SecureRWIllegalMode = GTZC_MPCBB_SRWILADIS_ENABLE;
MPCBB_NonSecureArea_Desc.InvertSecureState = GTZC_MPCBB_INVSECSTATE_NOT_INVERTED;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[8] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[9] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[10] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[11] =   0xFFFFFFFF;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[12] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[13] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[14] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[15] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[16] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[17] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[18] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[19] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[20] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[21] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[22] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[23] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
if (HAL_GTZC_MPCBB_ConfigMem(SRAM1_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
Error_Handler();
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[0] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[1] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[2] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[3] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[4] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[5] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[6] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_SecConfig_array[7] =   0x00000000;
MPCBB_NonSecureArea_Desc.AttributeConfig.MPCBB_LockConfig_array[0] =   0x00000000;
if (HAL_GTZC_MPCBB_ConfigMem(SRAM2_BASE, &MPCBB_NonSecureArea_Desc) != HAL_OK)
Error_Handler();
static void MX_ICACHE_Init(void)
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK)
Error_Handler();
if (HAL_ICACHE_Enable() != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
HAL_GPIO_ConfigPinAttributes(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_NSEC);
static void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK)
Error_Handler();
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 55;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void HAL_SYSTICK_Callback(void)
if (SecureTimingDelay != 0U)
SecureTimingDelay--;
else
HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_7);
SecureTimingDelay = SECURE_IO_TOGGLE_DELAY;
void Error_Handler(void)
if (SecureInitIODone != 0)
MX_GPIO_Init();
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_SET);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
RCC_SystemClock_Config();
GPIO_Output_Config();
UART_Config();
TIM_Config();
while (1)
encoderCount = __HAL_TIM_GET_COUNTER(&timHandle);
encoderDirection = __HAL_TIM_IS_TIM_COUNTING_DOWN(&timHandle);
printf("Count,Direction=%i,%i\\n", encoderCount, encoderDirection);
HAL_Delay(500);
void RCC_SystemClock_Config(void)
RCC_ClkInitTypeDef rccClkInit;
RCC_OscInitTypeDef rccOscInit;
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE;
rccOscInit.HSEState       = RCC_HSE_ON;
rccOscInit.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
rccOscInit.PLL.PLLState   = RCC_PLL_ON;
rccOscInit.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
rccOscInit.PLL.PLLMUL     = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&rccOscInit) != HAL_OK)
Error_Handler();
rccClkInit.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
rccClkInit.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
rccClkInit.AHBCLKDivider  = RCC_SYSCLK_DIV1;
rccClkInit.APB2CLKDivider = RCC_HCLK_DIV1;
rccClkInit.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void GPIO_Output_Config(void)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_GPIOB_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9;
gpioInit.Mode  = GPIO_MODE_OUTPUT_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &gpioInit);
void UART_Config(void)
uartHandle.Instance        = USART2;
uartHandle.Init.BaudRate   = 9600;
uartHandle.Init.WordLength = UART_WORDLENGTH_8B;
uartHandle.Init.StopBits   = UART_STOPBITS_1;
uartHandle.Init.Parity     = UART_PARITY_NONE;
uartHandle.Init.Mode       = UART_MODE_TX;
uartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
if (HAL_UART_Init(&uartHandle) != HAL_OK)
Error_Handler();
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_USART2_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_2;
gpioInit.Mode  = GPIO_MODE_AF_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOA, &gpioInit);
void TIM_Config(void)
TIM_Encoder_InitTypeDef timEncoderInit;
timHandle.Instance               = TIM1;
timHandle.Init.Prescaler         = 0;
timHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
timHandle.Init.Period            = 0xFFFF;
timHandle.Init.ClockDivision     = 0;
timHandle.Init.RepetitionCounter = 0;
if (HAL_TIM_Base_Init(&timHandle) != HAL_OK)
Error_Handler();
timEncoderInit.EncoderMode  = TIM_ENCODERMODE_TI12;
timEncoderInit.IC1Polarity  = TIM_ICPOLARITY_RISING;
timEncoderInit.IC1Selection = TIM_ICSELECTION_DIRECTTI;
timEncoderInit.IC1Prescaler = TIM_ICPSC_DIV1;
timEncoderInit.IC1Filter    = 0;
timEncoderInit.IC2Polarity  = TIM_ICPOLARITY_FALLING;
timEncoderInit.IC2Selection = TIM_ICSELECTION_DIRECTTI;
timEncoderInit.IC2Prescaler = TIM_ICPSC_DIV1;
timEncoderInit.IC2Filter    = 0;
if(HAL_TIM_Encoder_Init(&timHandle, &timEncoderInit) != HAL_OK)
Error_Handler();
if(HAL_TIM_Encoder_Start(&timHandle, TIM_CHANNEL_ALL) != HAL_OK)
Error_Handler();
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_TIM1_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
gpioInit.Pin  = GPIO_PIN_8 | GPIO_PIN_9;
gpioInit.Mode = GPIO_MODE_AF_INPUT;
gpioInit.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &gpioInit);
void Error_Handler(void)
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
while (1);
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
RTC_Event_Callback();
int main(void)
HAL_Init();
usermain_init();
while (1)
usermain_loop();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE2) != HAL_OK)
Error_Handler();
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
HAL_RCCEx_EnableMSIPLLMode();
void MX_ADC1_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV2;
hadc1.Init.Resolution = ADC_RESOLUTION_10B;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
hadc1.Init.LowPowerAutoWait = ENABLE;
hadc1.Init.ContinuousConvMode = DISABLE;
hadc1.Init.NbrOfConversion = 1;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.DMAContinuousRequests = DISABLE;
hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
hadc1.Init.OversamplingMode = DISABLE;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_VREFINT;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
sConfig.SingleDiff = ADC_SINGLE_ENDED;
sConfig.OffsetNumber = ADC_OFFSET_NONE;
sConfig.Offset = 0;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
void MX_RTC_Init(void)
RTC_TimeTypeDef sTime = {0};
RTC_DateTypeDef sDate = {0};
RTC_AlarmTypeDef sAlarm = {0};
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
if(HAL_RTCEx_BKUPRead(&hrtc, 0) != 0)
return;
sTime.Hours = 0x23;
sTime.Minutes = 0x59;
sTime.Seconds = 0x45;
sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
sTime.StoreOperation = RTC_STOREOPERATION_RESET;
if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
sDate.WeekDay = RTC_WEEKDAY_WEDNESDAY;
sDate.Month = RTC_MONTH_JULY;
sDate.Date = 0x1;
sDate.Year = 0x20;
if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
sAlarm.AlarmTime.Hours = 0x0;
sAlarm.AlarmTime.Minutes = 0x0;
sAlarm.AlarmTime.Seconds = 0x0;
sAlarm.AlarmTime.SubSeconds = 0x0;
sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
sAlarm.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY;
sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
sAlarm.AlarmDateWeekDay = 0x1;
sAlarm.Alarm = RTC_ALARM_A;
if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LSH01_Pin|LSH10_Pin|HS1_Pin|HS2_Pin
|HS8_Pin|HS4_Pin|LSM01_Pin|LSM10_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(BMA_CS_GPIO_Port, BMA_CS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_7|GPIO_PIN_8
|GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LSH01_Pin|LSH10_Pin|HS1_Pin|HS2_Pin
|HS8_Pin|HS4_Pin|LSM01_Pin|LSM10_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_7;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BMA_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(BMA_CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_3;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
SCB_InvalidateICache();
SCB->CCR |= (1 <<18);
__DSB();
SCB_InvalidateICache();
SCB_EnableICache();
SCB_InvalidateDCache();
SCB_EnableDCache();
HAL_Init();
SystemClock_Config();
k_BspInit();
k_CalendarBkupInit();
osThreadDef(GUI_Thread, GUIThread, osPriorityNormal, 0, 2 * 1024);
osThreadCreate (osThread(GUI_Thread), NULL);
k_ModuleInit();
k_ModuleAdd(&audio_player_board);
k_ModuleAdd(&video_player_board);
k_ModuleAdd(&audio_recorder_board);
k_ModuleAdd(&vnc_server);
k_ModuleAdd(&gardening_control_board);
k_ModuleAdd(&home_alarm_board);
k_ModuleAdd(&games_board);
k_ModuleAdd(&settings_board);
osKernelStart ();
for( ;; );
static void GUIThread(void const * argument)
k_StorageInit();
GUI_Init();
WM_MULTIBUF_Enable(1);
GUI_SetLayerVisEx (1, 0);
GUI_SelectLayer(0);
GUI_SetBkColor(GUI_WHITE);
GUI_Clear();
k_SetGuiProfile();
k_StartUp();
osTimerDef(TS_Timer, TimerCallback);
lcd_timer =  osTimerCreate(osTimer(TS_Timer), osTimerPeriodic, (void *)0);
osTimerStart(lcd_timer, 100);
k_InitMenu();
while(1) {
GUI_Exec();
k_PeriodicProcesses();
osDelay(20);
static void TimerCallback(void const *n)
k_TouchUpdate();
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x20010000;
MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER4;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL1;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0xC0000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_8MB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER5;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
float maxC = 0;
float maxAsm = 0;
float maxCMSIS = 0;
uint32_t maxIndexC;
uint32_t maxIndexAsm;
uint32_t maxIndexCMSIS;
float array[10] = {48.21, 79.48, 24.27, 28.82, 78.24, 88.49, 31.19, 5.52, 82.70, 77.73};
float cResult[10];
float asmResult[10];
float CMSISResult[10];
float stdC;
float stdAsm;
float stdCMSIS;
while (1)
ITM_Port32(31) = 1;
for (uint32_t i=0; i<1000; i++) {
cStd(&array, 10, &stdC);
ITM_Port32(31) = 2;
for (uint32_t i=0; i<1000; i++) {
asmStd(&array, 10, &stdAsm);
ITM_Port32(31) = 3;
for (uint32_t i=0; i<1000; i++) {
arm_std_f32(&array, 10, &stdCMSIS);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
osMessageQDef(osqueue, QUEUE_SIZE, uint16_t);
osQueue = osMessageCreate (osMessageQ(osqueue), NULL);
osThreadDef(QCons, MessageQueueConsumer, osPriorityBelowNormal, 0, blckqSTACK_SIZE);
osThreadCreate(osThread(QCons), NULL);
osThreadDef(QProd, MessageQueueProducer, osPriorityBelowNormal, 0, blckqSTACK_SIZE);
osThreadCreate(osThread(QProd), NULL);
osKernelStart();
for(;;);
static void MessageQueueProducer (const void *argument)
for(;;)
if(osMessagePut (osQueue, ProducerValue, 100) != osOK)
BSP_LED_Toggle(LED3);
else
++ProducerValue;
BSP_LED_Toggle(LED1);
osDelay(250);
static void MessageQueueConsumer (const void *argument)
osEvent event;
for(;;)
event = osMessageGet(osQueue, 100);
if(event.status == osEventMessage)
if(event.value.v != ConsumerValue)
ConsumerValue = event.value.v;
BSP_LED_Toggle(LED3);
else
++ConsumerValue;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 6;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
Error_Handler();
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
initialise_monitor_handles();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
printf("Please enter your name: \\n");
gets(buffer);
printf("\\nAh, I know you, %s!\\n", buffer);
FILE *fd= fopen("D:\\\\test.out", "w+");
if(fd) {
fwrite(buffer, sizeof(char), strlen(buffer), fd);
fclose(fd);
while (1)
printf("counter = %d\\n", counter++);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, LD4_Pin|LD3_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_SPI1_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.Timing = 0x2000090E;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
GPIO_InitStruct.Pin = REL1_Pin|REL3_Pin|ROT_A_Pin|ROT_B_Pin
|ROT_S_Pin|FSELECT_Pin|SDATA_Pin|FSYNC_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = SCLK_Pin|DATAEN_Pin|TXEN_Pin|DIGITAL_OUT_1_Pin
|PSEL1_Pin|PSEL0_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
int main(void)
uint32_t counter = 0, transparency = 0;
uint8_t str[30];
uwInternelBuffer = (uint8_t *)0xC0260000;
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
LCD_Config();
BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_GPIO);
BSP_SD_Init();
while(BSP_SD_IsDetected() != SD_PRESENT)
BSP_LCD_SetTextColor(LCD_COLOR_RED);
BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  Please insert SD Card                  ");
BSP_LCD_Clear(LCD_COLOR_BLACK);
if(FATFS_LinkDriver(&SD_Driver, SD_Path) == 0)
for (counter = 0; counter < MAX_BMP_FILES; counter++)
pDirectoryFiles[counter] = malloc(MAX_BMP_FILE_NAME);
if(pDirectoryFiles[counter] == NULL)
BSP_LCD_SetTextColor(LCD_COLOR_RED);
BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  Cannot allocate memory ");
while(1)
ubNumberOfFiles = Storage_GetDirectoryBitmapFiles("/Media", pDirectoryFiles);
if (ubNumberOfFiles == 0)
for (counter = 0; counter < MAX_BMP_FILES; counter++)
free(pDirectoryFiles[counter]);
BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"  No Bitmap files...      ");
while(1)
else
Error_Handler();
while(1)
counter = 0;
while ((counter) < ubNumberOfFiles)
sprintf ((char*)str, "Media/%-11.11s", pDirectoryFiles[counter]);
if (Storage_CheckBitmapFile((const char*)str, &uwBmplen) == 0)
sprintf ((char*)str, "Media/%-11.11s", pDirectoryFiles[counter]);
BSP_LCD_SelectLayer(1);
Storage_OpenReadFile(uwInternelBuffer, (const char*)str);
BSP_LCD_DrawBitmap(0, 0, uwInternelBuffer);
for (transparency = 0; transparency < 255; (transparency++))
BSP_LCD_SetTransparency(1, transparency);
HAL_Delay(2);
while (BSP_PB_GetState(BUTTON_TAMPER) == RESET)
for (transparency = 255; transparency > 0; transparency--)
BSP_LCD_SetTransparency(1, transparency);
HAL_Delay(2);
BSP_LCD_Clear(LCD_COLOR_BLACK);
counter++;
sprintf ((char*)str, "Media/%-11.11s", pDirectoryFiles[counter]);
if ((Storage_CheckBitmapFile((const char*)str, &uwBmplen) == 0) || (counter < (ubNumberOfFiles)))
BSP_LCD_SelectLayer(0);
sprintf ((char*)str, "Media/%-11.11s", pDirectoryFiles[counter]);
Storage_OpenReadFile(uwInternelBuffer, (const char*)str);
BSP_LCD_DrawBitmap(0, 0, uwInternelBuffer);
for (transparency = 0; transparency < 255; (transparency++))
BSP_LCD_SetTransparency(0, transparency);
HAL_Delay(2);
while (BSP_PB_GetState(BUTTON_TAMPER) == RESET)
for (transparency = 255; transparency > 0; transparency--)
BSP_LCD_SetTransparency(0, transparency);
HAL_Delay(2);
BSP_LCD_Clear(LCD_COLOR_BLACK);
counter++;
else if (Storage_CheckBitmapFile((const char*)str, &uwBmplen) == 0)
BSP_LCD_SetTextColor(LCD_COLOR_RED);
BSP_LCD_DisplayStringAtLine(7, (uint8_t *) str);
BSP_LCD_DisplayStringAtLine(8, (uint8_t*)"    File type not supported. ");
while(1)
static void LCD_Config(void)
BSP_LCD_Init();
BSP_LCD_LayerDefaultInit(0, LCD_FB_START_ADDRESS);
BSP_LCD_LayerDefaultInit(1, LCD_FB_START_ADDRESS+(BSP_LCD_GetXSize()*BSP_LCD_GetYSize()*4));
BSP_LCD_DisplayOn();
BSP_LCD_SelectLayer(0);
BSP_LCD_Clear(LCD_COLOR_BLACK);
BSP_LCD_SelectLayer(1);
BSP_LCD_Clear(LCD_COLOR_BLACK);
BSP_LCD_SetTransparency(0, 0);
BSP_LCD_SetTransparency(1, 100);
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 8;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
if(ret != HAL_OK)
while(1) { ; }
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0xC0000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_32MB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER1;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0xA0000000;
MPU_InitStruct.Size = MPU_REGION_SIZE_8KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER2;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x0;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
LCD_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
HAL_Delay(500);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_SET);
Demo4_Routine();
while (1) {
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
switch (GPIO_Pin) {
case KEY0_Pin:
if (HAL_GPIO_ReadPin(KEY0_GPIO_Port, KEY0_Pin) == GPIO_PIN_RESET)
Engine_KeyPressed = -1;
break;
case KEY1_Pin:
if (HAL_GPIO_ReadPin(KEY1_GPIO_Port, KEY1_Pin) == GPIO_PIN_RESET)
Engine_KeyPressed = 1;
break;
case KEY_WK_Pin:
if (HAL_GPIO_ReadPin(KEY_WK_GPIO_Port, KEY_WK_Pin) == GPIO_PIN_SET)
HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);
HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
break;
default:
break;
void Error_Handler(void)
printlnf("error");
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_USART2_UART_Init();
char buffer[512] = {0};
while (1)
printf("Please input : \\n");
fgets(buffer, sizeof(buffer), stdin);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_TIM1_Init();
while (1)
int i =
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_TIM1;
PeriphClkInit.Tim1ClockSelection = RCC_TIM1CLK_HCLK;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = 72-1;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 1000;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4) != HAL_OK)
Error_Handler();
sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
sBreakDeadTimeConfig.DeadTime = 0;
sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
sBreakDeadTimeConfig.BreakFilter = 0;
sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
sBreakDeadTimeConfig.Break2Filter = 0;
sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim1);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 38400;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FAST;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
while (1)
HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);
HAL_Delay(100);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_TIM3_Init();
MX_TIM2_Init();
Luos_Init();
Led_Init();
while (1)
Luos_Loop();
Led_Loop();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
void dacInit(void)
uint32_t i;
uint32_t j;
for (i=0; i<DAC_MAX_CH; i++)
dac_tbl[i].buffer = dac_buffer;
for (j=0; j<DAC_BUFFER_MAX; j++)
dac_tbl[i].buffer[j] = 0;
tx_buf.ptr_in  = 0;
tx_buf.ptr_out = 0;
tx_buf.p_buf   = (uint16_t *)dac_tbl[0].buffer;
tx_buf.length  = DAC_BUFFER_MAX;
DacHandle.Instance = DAC1;
HAL_DAC_Init(&DacHandle);
dac_tbl[0].channel    = DAC_CHANNEL_1;
dac_tbl[0].resolution = 12;
dac_tbl[0].sConfig.DAC_SampleAndHold = DAC_SAMPLEANDHOLD_ENABLE;
dac_tbl[0].sConfig.DAC_Trigger      = DAC_TRIGGER_T6_TRGO;
dac_tbl[0].sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
dac_tbl[0].sConfig.DAC_ConnectOnChipPeripheral = DAC_CHIPCONNECT_ENABLE;
dac_tbl[0].sConfig.DAC_UserTrimming = DAC_TRIMMING_FACTORY;
HAL_DAC_ConfigChannel(&DacHandle, &dac_tbl[0].sConfig, dac_tbl[0].channel);
HAL_DAC_Start_DMA(&DacHandle, dac_tbl[0].channel, (uint32_t *)dac_tbl[0].buffer, DAC_BUFFER_MAX, DAC_ALIGN_12B_R);
cmdifAdd("dac", dacCmdif);
void dacSetup(uint32_t hz)
dac_hz = hz;
dacInitTimer(dac_hz);
void dacStart(void)
HAL_TIM_Base_Start(&htim);
is_stop = false;
bool dacIsStarted(void)
return !is_stop;
void dacStop(void)
uint32_t i;
uint32_t j;
is_stop = true;
delay(10);
for (i=0; i<DAC_MAX_CH; i++)
for (j=0; j<DAC_BUFFER_MAX; j++)
dac_tbl[i].buffer[j] = 0;
delay(10);
HAL_TIM_Base_Stop(&htim);
tx_buf.ptr_in  = (tx_buf.length - 1) - ((DMA_Stream_TypeDef   *)hdma_dac1.Instance)->NDTR;
tx_buf.ptr_out = tx_buf.ptr_in;
void dacInitTimer(uint32_t hz)
TIM_MasterConfigTypeDef sMasterConfig;
__HAL_RCC_TIM6_CLK_ENABLE();
htim.Instance      = TIM6;
htim.Init.Period            = 10-1;
htim.Init.Prescaler         = (uint32_t)((SystemCoreClock / 2) / (hz*10)) - 1;
htim.Init.ClockDivision     = 0;
htim.Init.CounterMode       = TIM_COUNTERMODE_UP;
htim.Init.RepetitionCounter = 0;
HAL_TIM_Base_Init(&htim);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode     = TIM_MASTERSLAVEMODE_DISABLE;
HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig);
uint32_t dacAvailable(void)
uint32_t length = 0;
tx_buf.ptr_in = (tx_buf.length - 1) - ((DMA_Stream_TypeDef   *)hdma_dac1.Instance)->NDTR;
/
length = tx_buf.length - 1 - length;
return length;
void dacPutch(uint8_t data)
uint32_t index;
uint32_t next_index;
if (is_stop == true) return;
index      = tx_buf.ptr_out;
next_index = tx_buf.ptr_out + 1;
tx_buf.p_buf[index] = data<<4;
tx_buf.ptr_out      = next_index % tx_buf.length;
void dacPut16(uint16_t data)
uint32_t index;
uint32_t next_index;
if (is_stop == true) return;
index      = tx_buf.ptr_out;
next_index = tx_buf.ptr_out + 1;
tx_buf.p_buf[index] = data;
tx_buf.ptr_out      = next_index % tx_buf.length;
void dacWrite(uint8_t *p_data, uint32_t length)
uint32_t i;
for (i=0; i<length; i++)
dacPutch(p_data[i]);
void dacWrite16(uint16_t *p_data, uint32_t length)
uint32_t i;
for (i=0; i<length; i++)
dacPut16(p_data[i]);
uint32_t dacGetDebug(void)
return ((DMA_Stream_TypeDef   *)hdma_dac1.Instance)->NDTR;
uint32_t dacGetBufLength(void)
return DAC_BUFFER_MAX;
void dacCmdif()
bool ret = true;
if (cmdifGetParamCnt() == 1)
if(cmdifHasString("demo", 0) == true)
uint32_t index = 0;
int i;
uint32_t length;
int16_t out = 0;
dacSetup(8000);
dacStart();
while(cmdifRxAvailable() == 0)
delay(1);
length = dacAvailable();
for (i=0; i<length-1; i++)
out  = (wave_data[index] - 128) * 2;
out += 128;
if (out > 255) out = 255;
if (out < 0  ) out = 0;
dacPutch(out);
if (index < NUM_ELEMENTS)
index++;
dacStop();
else
ret = false;
else
ret = false;
if (ret == false)
cmdifPrintf( "dac on/off/toggle/demo number ...\\n");
return;
void HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac)
dac_isr_count++;
void HAL_DAC_ConvCpltCallbackCh1(DAC_HandleTypeDef* hdac)
void DMA2_Stream6_IRQHandler(void)
HAL_DMA_IRQHandler(DacHandle.DMA_Handle1);
void DACx_IRQHandler(void)
HAL_DAC_IRQHandler(&DacHandle);
void HAL_DAC_MspInit(DAC_HandleTypeDef *hdac)
GPIO_InitTypeDef          GPIO_InitStruct;
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_DAC12_CLK_ENABLE();
__HAL_RCC_DMA2_CLK_ENABLE();
GPIO_InitStruct.Pin   = GPIO_PIN_4;
GPIO_InitStruct.Mode  = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull  = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
hdma_dac1.Instance                  = DMA2_Stream6;
hdma_dac1.Init.Request              = DMA_REQUEST_DAC1;
hdma_dac1.Init.Direction            = DMA_MEMORY_TO_PERIPH;
hdma_dac1.Init.PeriphInc            = DMA_PINC_DISABLE;
hdma_dac1.Init.MemInc               = DMA_MINC_ENABLE;
hdma_dac1.Init.PeriphDataAlignment  = DMA_PDATAALIGN_HALFWORD;
hdma_dac1.Init.MemDataAlignment     = DMA_PDATAALIGN_HALFWORD;
hdma_dac1.Init.Mode                 = DMA_CIRCULAR;
hdma_dac1.Init.Priority             = DMA_PRIORITY_LOW;
hdma_dac1.Init.FIFOMode             = DMA_FIFOMODE_DISABLE;
HAL_DMA_DeInit(&hdma_dac1);
HAL_DMA_Init(&hdma_dac1);
__HAL_LINKDMA(hdac, DMA_Handle1, hdma_dac1);
void HAL_DAC_MspDeInit(DAC_HandleTypeDef *hdac)
__HAL_RCC_DAC12_FORCE_RESET();
__HAL_RCC_DAC12_RELEASE_RESET();
HAL_GPIO_DeInit(GPIOA, GPIO_PIN_4);
int main(void)
HAL_Init();
MX_GPIO_Init();
while (1)
if (UserButtonPressed == 1U)
if (SystemCoreClock == 4000000U)
SECURE_SystemClock_MSI_PLL_110Mhz_Config();
SysTickUpdate();
ToggleDelay = FAST_DELAY;
else if (SystemCoreClock == 110000000U)
SECURE_SystemClock_MSI_4Mhz_Config();
SysTickUpdate();
ToggleDelay = SLOW_DELAY;
else
UserButtonPressed = 0U;
HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);
HAL_Delay(ToggleDelay);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = BUTTON_USER_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BUTTON_USER_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI13_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI13_IRQn);
static void SysTickUpdate(void)
SystemCoreClockUpdate();
if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
Error_Handler();
void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == BUTTON_USER_Pin)
UserButtonPressed = 1;
void Error_Handler(void)
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
RCC_SystemClock_Config();
GPIO_Output_Config();
GPIO_Input_Config();
UART_Config();
I2C_Config();
while (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_15) == GPIO_PIN_SET);
EEPROM_WritePage(EEPROM_DEV_ADDR, 0x0000, text, COUNT_OF(text));
HAL_Delay(5);
EEPROM_ReadPage(EEPROM_DEV_ADDR, 0x0000, eepromData, COUNT_OF(text));
while (1);
void RCC_SystemClock_Config(void)
RCC_ClkInitTypeDef rccClkInit;
RCC_OscInitTypeDef rccOscInit;
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE;
rccOscInit.HSEState       = RCC_HSE_ON;
rccOscInit.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
rccOscInit.PLL.PLLState   = RCC_PLL_ON;
rccOscInit.PLL.PLLSource  = RCC_PLLSOURCE_HSE;
rccOscInit.PLL.PLLMUL     = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&rccOscInit) != HAL_OK)
Error_Handler();
rccClkInit.ClockType      = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
rccClkInit.SYSCLKSource   = RCC_SYSCLKSOURCE_PLLCLK;
rccClkInit.AHBCLKDivider  = RCC_SYSCLK_DIV1;
rccClkInit.APB2CLKDivider = RCC_HCLK_DIV1;
rccClkInit.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void GPIO_Output_Config(void)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_GPIOB_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9;
gpioInit.Mode  = GPIO_MODE_OUTPUT_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &gpioInit);
void GPIO_Input_Config(void)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_GPIOC_CLK_ENABLE();
gpioInit.Pin  = GPIO_PIN_15;
gpioInit.Mode = GPIO_MODE_INPUT;
gpioInit.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOC, &gpioInit);
void UART_Config(void)
uartHandle.Instance        = USART2;
uartHandle.Init.BaudRate   = 9600;
uartHandle.Init.WordLength = UART_WORDLENGTH_8B;
uartHandle.Init.StopBits   = UART_STOPBITS_1;
uartHandle.Init.Parity     = UART_PARITY_NONE;
uartHandle.Init.Mode       = UART_MODE_TX;
uartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
if (HAL_UART_Init(&uartHandle) != HAL_OK)
Error_Handler();
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
GPIO_InitTypeDef gpioInit;
__HAL_RCC_USART2_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_2;
gpioInit.Mode  = GPIO_MODE_AF_PP;
gpioInit.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOA, &gpioInit);
void I2C_Config(void)
i2cHandle.Instance             = I2C2;
i2cHandle.Init.ClockSpeed      = 100000;
i2cHandle.Init.DutyCycle       = I2C_DUTYCYCLE_2;
i2cHandle.Init.OwnAddress1     = 0x00;
i2cHandle.Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
i2cHandle.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
i2cHandle.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
i2cHandle.Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
if(HAL_I2C_Init(&i2cHandle) != HAL_OK)
Error_Handler();
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c)
GPIO_InitTypeDef gpioInit;
static DMA_HandleTypeDef dmaTxHandle;
static DMA_HandleTypeDef dmaRxHandle;
__HAL_RCC_I2C2_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_DMA1_CLK_ENABLE();
gpioInit.Pin   = GPIO_PIN_10 | GPIO_PIN_11;
gpioInit.Mode  = GPIO_MODE_AF_OD;
gpioInit.Pull  = GPIO_PULLUP;
gpioInit.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOB, &gpioInit);
dmaTxHandle.Instance                 = DMA1_Channel4;
dmaTxHandle.Init.Direction           = DMA_MEMORY_TO_PERIPH;
dmaTxHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
dmaTxHandle.Init.MemInc              = DMA_MINC_ENABLE;
dmaTxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
dmaTxHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
dmaTxHandle.Init.Mode                = DMA_NORMAL;
dmaTxHandle.Init.Priority            = DMA_PRIORITY_LOW;
HAL_DMA_Init(&dmaTxHandle);
__HAL_LINKDMA(hi2c, hdmatx, dmaTxHandle);
dmaRxHandle.Instance                 = DMA1_Channel5;
dmaRxHandle.Init.Direction           = DMA_PERIPH_TO_MEMORY;
dmaRxHandle.Init.PeriphInc           = DMA_PINC_DISABLE;
dmaRxHandle.Init.MemInc              = DMA_MINC_ENABLE;
dmaRxHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
dmaRxHandle.Init.MemDataAlignment    = DMA_MDATAALIGN_BYTE;
dmaRxHandle.Init.Mode                = DMA_NORMAL;
dmaRxHandle.Init.Priority            = DMA_PRIORITY_HIGH;
HAL_DMA_Init(&dmaRxHandle);
__HAL_LINKDMA(hi2c, hdmarx, dmaRxHandle);
HAL_NVIC_SetPriority(DMA1_Channel4_IRQn, 1, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel4_IRQn);
HAL_NVIC_SetPriority(DMA1_Channel5_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel5_IRQn);
void HAL_I2C_MemRxCpltCallback(I2C_HandleTypeDef *I2cHandle)
if(BufferCmp(eepromData, text, COUNT_OF(text)))
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);
printf("%s\\n", text);
printf("%s\\n", eepromData);
else
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
printf("%s\\n", text);
printf("%s\\n", eepromData);
void EEPROM_WritePage(uint8_t devAddr, uint16_t ee10bAddr, uint8_t *eeData,
uint8_t size)
uint8_t i2cData[2];
i2cData[0] = devAddr | (((uint8_t)ee10bAddr >> 7) & 0xFE);
i2cData[1] = (uint8_t)ee10bAddr;
if (HAL_I2C_Mem_Write_DMA(&i2cHandle, i2cData[0], i2cData[1],
I2C_MEMADD_SIZE_8BIT, eeData, size) != HAL_OK)
Error_Handler();
while (HAL_I2C_GetState(&i2cHandle) != HAL_I2C_STATE_READY);
void EEPROM_ReadPage(uint8_t devAddr, uint16_t ee10bAddr, uint8_t *eeData,
uint8_t size)
uint8_t i2cData[2];
i2cData[0] = devAddr | (((uint8_t)ee10bAddr >> 7) & 0xFE);
i2cData[1] = (uint8_t)ee10bAddr;
if (HAL_I2C_Mem_Read_DMA(&i2cHandle, i2cData[0], i2cData[1],
I2C_MEMADD_SIZE_8BIT, eeData, size) != HAL_OK)
Error_Handler();
while (HAL_I2C_GetState(&i2cHandle) != HAL_I2C_STATE_READY);
uint8_t BufferCmp(uint8_t *pBuff1, uint8_t *pBuff2, uint16_t len)
while (len--)
if((*pBuff1) != *pBuff2)
return 1;
pBuff1++;
pBuff2++;
return 0;
void Error_Handler(void)
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
while (1);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_I2C2_Init();
App_Init();
while (1)
App_Run();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_I2C2;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
Error_Handler();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.Timing = 0x10909CEC;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOE, ISM43362_RESET_Pin|ISM43362_NSS_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB, ISM43362_WAKEUP_Pin|LED2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_WIFI_ACTIVITY_GPIO_Port, LED_WIFI_ACTIVITY_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = ISM43362_RESET_Pin|ISM43362_NSS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = ISM43362_WAKEUP_Pin|LED2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_WIFI_ACTIVITY_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_WIFI_ACTIVITY_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = ISM43362_DATA_READY_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(ISM43362_DATA_READY_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI1_IRQn);
int App_Init(void)
uint32_t err = 0;
LPS22HB_Obj.IO.BusType       =  LPS22HB_I2C_BUS;
LPS22HB_Obj.IO.Address       =  LPS22HB_I2C_ADDRESS;
LPS22HB_Obj.IO.hi2c          = &LPS22HB_I2C_HANDLER;
LPS22HB_Obj.is_initialized   = 0;
LPS22HB_Obj.press_is_enabled = 0;
LPS22HB_Obj.temp_is_enabled  = 0;
err = LPS22HB_Init        (&LPS22HB_Obj);
err = LPS22HB_ReadID      (&LPS22HB_Obj, &PRESS_Id);
err = LPS22HB_PRESS_Enable(&LPS22HB_Obj);
err = LPS22HB_TEMP_Enable (&LPS22HB_Obj);
if(err) { printf("LPS22 error\\r\\n");}
return err;
int App_Run(void)
uint32_t err = 0;
float          fPressure;
err = LPS22HB_PRESS_GetPressure(&LPS22HB_Obj, &fPressure   );
if(err)
printf("Error reading from sensor\\r\\n");
else
printf("Pressure: %d\\r\\n", (int)fPressure);
HAL_Delay(1000);
return err;
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
uint32_t index = 0;
RTC_TamperTypeDef  stamperstructure;
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
BSP_PB_Init(BUTTON_USER,BUTTON_MODE_GPIO);
RtcHandle.Instance            = RTC;
RtcHandle.Init.HourFormat     = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv   = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv    = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut         = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType     = RTC_OUTPUT_TYPE_OPENDRAIN;
__HAL_RTC_RESET_HANDLE_STATE(&RtcHandle);
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
stamperstructure.Tamper                       = RTC_TAMPER_1;
stamperstructure.PinSelection                 = RTC_TAMPERPIN_PC13;
stamperstructure.Trigger                      = RTC_TAMPERTRIGGER_FALLINGEDGE;
stamperstructure.Filter                       = RTC_TAMPERFILTER_DISABLE;
stamperstructure.SamplingFrequency            = RTC_TAMPERSAMPLINGFREQ_RTCCLK_DIV32768;
stamperstructure.PrechargeDuration            = RTC_TAMPERPRECHARGEDURATION_1RTCCLK;
stamperstructure.TamperPullUp                 = RTC_TAMPER_PULLUP_ENABLE;
stamperstructure.TimeStampOnTamperDetection   = RTC_TIMESTAMPONTAMPERDETECTION_DISABLE;
if (HAL_RTCEx_SetTamper_IT(&RtcHandle, &stamperstructure) != HAL_OK)
Error_Handler();
__HAL_RTC_TAMPER_CLEAR_FLAG(&RtcHandle,RTC_FLAG_TAMP1F);
for (index = 0; index < BACKUP_COUNT; index++)
HAL_RTCEx_BKUPWrite(&RtcHandle, aBKPDataReg[index], 0xDF59 + (index * 0x5A));
for (index = 0; index < BACKUP_COUNT; index++)
if (HAL_RTCEx_BKUPRead(&RtcHandle, aBKPDataReg[index]) != (0xDF59 + (index * 0x5A)))
Error_Handler();
while (TamperStatus != SET)
BSP_LED_Toggle(LED1);
HAL_Delay(1000);
HAL_RTCEx_DeactivateTamper(&RtcHandle, RTC_TAMPER_1);
for (index = 0; index < BACKUP_COUNT; index++)
if (HAL_RTCEx_BKUPRead(&RtcHandle, aBKPDataReg[index]) != 0x00)
Error_Handler();
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(100);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_TIM3_Init();
MX_TIM2_Init();
Luos_Init();
ControllerMotor_Init();
while (1)
Luos_Loop();
ControllerMotor_Loop();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
static void LCD1602_EnablePulse(void)
HAL_GPIO_WritePin(PORT_RS_and_E, PIN_E, GPIO_PIN_SET);
LCD1602_TIM_MicorSecDelay(writeTimeConstant);
HAL_GPIO_WritePin(PORT_RS_and_E, PIN_E, GPIO_PIN_RESET);
LCD1602_TIM_MicorSecDelay(60);
static void LCD1602_RS(bool state)
if(state) HAL_GPIO_WritePin(PORT_RS_and_E, PIN_RS, GPIO_PIN_SET);
else HAL_GPIO_WritePin(PORT_RS_and_E, PIN_RS, GPIO_PIN_RESET);
static void LCD1602_write(uint8_t byte)
uint8_t LSB_nibble = byte&0xF, MSB_nibble = (byte>>4)&0xF;
if(mode_8_4_I2C == 1)
HAL_GPIO_WritePin(PORT_LSB, D0_PIN, (GPIO_PinState)(LSB_nibble&0x1));
HAL_GPIO_WritePin(PORT_LSB, D1_PIN, (GPIO_PinState)(LSB_nibble&0x2));
HAL_GPIO_WritePin(PORT_LSB, D2_PIN, (GPIO_PinState)(LSB_nibble&0x4));
HAL_GPIO_WritePin(PORT_LSB, D3_PIN, (GPIO_PinState)(LSB_nibble&0x8));
HAL_GPIO_WritePin(PORT_MSB, D4_PIN, (GPIO_PinState)(MSB_nibble&0x1));
HAL_GPIO_WritePin(PORT_MSB, D5_PIN, (GPIO_PinState)(MSB_nibble&0x2));
HAL_GPIO_WritePin(PORT_MSB, D6_PIN, (GPIO_PinState)(MSB_nibble&0x4));
HAL_GPIO_WritePin(PORT_MSB, D7_PIN, (GPIO_PinState)(MSB_nibble&0x8));
LCD1602_EnablePulse();
else if(mode_8_4_I2C == 2)
HAL_GPIO_WritePin(PORT_MSB, D4_PIN, (GPIO_PinState)(MSB_nibble&0x1));
HAL_GPIO_WritePin(PORT_MSB, D5_PIN, (GPIO_PinState)(MSB_nibble&0x2));
HAL_GPIO_WritePin(PORT_MSB, D6_PIN, (GPIO_PinState)(MSB_nibble&0x4));
HAL_GPIO_WritePin(PORT_MSB, D7_PIN, (GPIO_PinState)(MSB_nibble&0x8));
LCD1602_EnablePulse();
HAL_GPIO_WritePin(PORT_MSB, D4_PIN, (GPIO_PinState)(LSB_nibble&0x1));
HAL_GPIO_WritePin(PORT_MSB, D5_PIN, (GPIO_PinState)(LSB_nibble&0x2));
HAL_GPIO_WritePin(PORT_MSB, D6_PIN, (GPIO_PinState)(LSB_nibble&0x4));
HAL_GPIO_WritePin(PORT_MSB, D7_PIN, (GPIO_PinState)(LSB_nibble&0x8));
LCD1602_EnablePulse();
static void LCD1602_TIM_Config(void)
RCC_ClkInitTypeDef myCLKtypeDef;
uint32_t clockSpeed;
uint32_t flashLatencyVar;
HAL_RCC_GetClockConfig(&myCLKtypeDef, &flashLatencyVar);
if(myCLKtypeDef.APB1CLKDivider == RCC_HCLK_DIV1)
clockSpeed = HAL_RCC_GetPCLK1Freq();
else
clockSpeed = HAL_RCC_GetPCLK1Freq()*2;
clockSpeed *= 0.000001;
RCC->APB1ENR |= RCC_APB1ENR_TIM3EN;
TIM3->CR1 &= ~(0x0010);
TIM3->CR1 &= ~(0x0001);
TIM3->CR1 &= ~(1UL << 2);
TIM3->CR1 |= (1UL << 3);
TIM3->PSC = clockSpeed-1;
TIM3->ARR = 10-1;
TIM3->EGR = 1;
TIM3->SR &= ~(0x0001);
static void LCD1602_TIM_MicorSecDelay(uint32_t uSecDelay)
TIM3->ARR = uSecDelay-1;
TIM3->SR &= ~(0x0001);
TIM3->CR1 |= 1UL;
while((TIM3->SR&0x0001) != 1);
static void LCD1602_writeCommand(uint8_t command)
LCD1602_RS(false);
LCD1602_write(command);
static void LCD1602_writeData(uint8_t data)
LCD1602_RS(true);
LCD1602_write(data);
static void LCD1602_write4bitCommand(uint8_t nibble)
uint8_t LSB_nibble = nibble&0xF;
LCD1602_RS(false);
HAL_GPIO_WritePin(D4_GPIO_Port, D4_Pin, (GPIO_PinState)(LSB_nibble&0x1));
HAL_GPIO_WritePin(D5_GPIO_Port, D5_Pin, (GPIO_PinState)(LSB_nibble&0x2));
HAL_GPIO_WritePin(D6_GPIO_Port, D6_Pin, (GPIO_PinState)(LSB_nibble&0x4));
HAL_GPIO_WritePin(D7_GPIO_Port, D7_Pin, (GPIO_PinState)(LSB_nibble&0x8));
LCD1602_EnablePulse();
void LCD1602_Begin8BIT(GPIO_TypeDef* PORT_RS_E, uint16_t RS, uint16_t E, GPIO_TypeDef* PORT_LSBs0to3, uint16_t D0, uint16_t D1, uint16_t D2, uint16_t D3, GPIO_TypeDef* PORT_MSBs4to7, uint16_t D4, uint16_t D5, uint16_t D6, uint16_t D7)
PORT_RS_and_E = PORT_RS_E;
PIN_RS = RS;
PIN_E = E;
PORT_LSB = PORT_LSBs0to3;
D0_PIN = D0;
D1_PIN = D1;
D2_PIN = D2;
D3_PIN = D3;
PORT_MSB = PORT_MSBs4to7;
D4_PIN = D4;
D5_PIN = D5;
D6_PIN = D6;
D7_PIN = D7;
LCD1602_TIM_Config();
mode_8_4_I2C = 1;
FunctionSet = 0x38;
HAL_Delay(20);
LCD1602_writeCommand(0x30);
HAL_Delay(5);
LCD1602_writeCommand(0x30);
HAL_Delay(1);
LCD1602_writeCommand(0x30);
HAL_Delay(1);
LCD1602_writeCommand(LCD_FUNCTIONSET | LCD_FUNCTION_N | LCD_FUNCTION_DL);
LCD1602_writeCommand(LCD_DISPLAYCONTROL | LCD_DISPLAY_B | LCD_DISPLAY_C | LCD_DISPLAY_D);
LCD1602_writeCommand(LCD_CLEARDISPLAY);
HAL_Delay(2);
void LCD1602_Begin4BIT(GPIO_TypeDef* PORT_RS_E, uint16_t RS, uint16_t E, GPIO_TypeDef* PORT_MSBs4to7, uint16_t D4, uint16_t D5, uint16_t D6, uint16_t D7)
PORT_RS_and_E = PORT_RS_E;
PIN_RS = RS;
PIN_E = E;
PORT_MSB = PORT_MSBs4to7;
D4_PIN = D4;
D5_PIN = D5;
D6_PIN = D6;
D7_PIN = D7;
LCD1602_TIM_Config();
mode_8_4_I2C = 2;
FunctionSet = 0x28;
HAL_Delay(20);
LCD1602_write4bitCommand(0x3);
HAL_Delay(5);
LCD1602_write4bitCommand(0x3);
HAL_Delay(1);
LCD1602_write4bitCommand(0x3);
HAL_Delay(1);
LCD1602_write4bitCommand(0x2);
HAL_Delay(1);
LCD1602_writeCommand(LCD_DISPLAYCONTROL | LCD_DISPLAY_B | LCD_DISPLAY_C | LCD_DISPLAY_D);
LCD1602_writeCommand(LCD_CLEARDISPLAY);
HAL_Delay(3);
LCD1602_writeCommand(LCD_FUNCTIONSET | LCD_FUNCTION_N);
HAL_Delay(3);
void LCD1602_print(char string[])
for(uint8_t i=0;  i< 16 && string[i]!=NULL; i++)
LCD1602_writeData((uint8_t)string[i]);
void LCD1602_setCursor(uint8_t row, uint8_t col)
uint8_t maskData;
maskData = (col-1)&0x0F;
if(row==1)
maskData |= (0x80);
LCD1602_writeCommand(maskData);
else
maskData |= (0xc0);
LCD1602_writeCommand(maskData);
void LCD1602_1stLine(void)
LCD1602_setCursor(1,1);
void LCD1602_2ndLine(void)
LCD1602_setCursor(2,1);
void LCD1602_TwoLines(void)
FunctionSet |= (0x08);
LCD1602_writeCommand(FunctionSet);
void LCD1602_OneLine(void)
FunctionSet &= ~(0x08);
LCD1602_writeCommand(FunctionSet);
void LCD1602_noCursor(void)
DisplayControl &= ~(0x02);
LCD1602_writeCommand(DisplayControl);
void LCD1602_cursor(void)
DisplayControl |= (0x02);
LCD1602_writeCommand(DisplayControl);
void LCD1602_clear(void)
LCD1602_writeCommand(LCD_CLEARDISPLAY);
HAL_Delay(3);
void LCD1602_noBlink(void)
DisplayControl &= ~(0x01);
LCD1602_writeCommand(DisplayControl);
void LCD1602_blink(void)
DisplayControl |= 0x01;
LCD1602_writeCommand(DisplayControl);
void LCD1602_noDisplay(void)
DisplayControl &= ~(0x04);
LCD1602_writeCommand(DisplayControl);
void LCD1602_display(void)
DisplayControl |= (0x04);
LCD1602_writeCommand(DisplayControl);
void LCD1602_shiftToRight(uint8_t num)
for(uint8_t i=0; i<num;i++)
LCD1602_writeCommand(0x1c);
void LCD1602_shiftToLeft(uint8_t num)
for(uint8_t i=0; i<num;i++)
LCD1602_writeCommand(0x18);
void LCD1602_PrintInt(int number)
char numStr[16];
sprintf(numStr,"%d", number);
LCD1602_print(numStr);
void LCD1602_PrintFloat(float number, int decimalPoints)
char numStr[16];
sprintf(numStr,"%.*f",decimalPoints, number);
LCD1602_print(numStr);
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
osMessageQDef(osqueue, QUEUE_SIZE, uint16_t);
osQueue = osMessageCreate (osMessageQ(osqueue), NULL);
osThreadDef(QCons, MessageQueueConsumer, osPriorityBelowNormal, 0, blckqSTACK_SIZE);
osThreadCreate(osThread(QCons), NULL);
osThreadDef(QProd, MessageQueueProducer, osPriorityBelowNormal, 0, blckqSTACK_SIZE);
osThreadCreate(osThread(QProd), NULL);
osKernelStart();
for(;;);
static void MessageQueueProducer (const void *argument)
for(;;)
if(osMessagePut (osQueue, ProducerValue, 100) != osOK)
BSP_LED_Toggle(LED3);
else
++ProducerValue;
BSP_LED_Toggle(LED1);
osDelay(250);
static void MessageQueueConsumer (const void *argument)
osEvent event;
for(;;)
event = osMessageGet(osQueue, 100);
if(event.status == osEventMessage)
if(event.value.v != ConsumerValue)
ConsumerValue = event.value.v;
BSP_LED_Toggle(LED3);
else
++ConsumerValue;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED6);
BSP_LED_Init(LED5);
MPU_SRAM_Config();
MPU_AccessPermConfig();
while (1)
BSP_LED_Toggle(LED6);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1) {};
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
while(1) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
while(1) {};
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
SystemClock_Config();
transferErrorDetected = 0;
transferCompleteDetected = 0;
DMA_Config();
while (1)
if (transferErrorDetected == 1)
BSP_LED_Toggle(LED1);
HAL_Delay(200);
transferErrorDetected = 0;
if (transferCompleteDetected == 1)
BSP_LED_On(LED1);
transferCompleteDetected = 0;
static void DMA_Config(void)
__HAL_RCC_DMA2_CLK_ENABLE();
DmaHandle.Init.Channel = DMA_CHANNEL;
DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;
DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
DmaHandle.Init.Mode = DMA_NORMAL;
DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;
DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;
DmaHandle.Instance = DMA_INSTANCE;
if (HAL_DMA_Init(&DmaHandle) != HAL_OK)
Error_Handler();
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_CPLT_CB_ID, TransferComplete);
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_ERROR_CB_ID, TransferError);
HAL_NVIC_SetPriority(DMA_INSTANCE_IRQ, 0, 0);
HAL_NVIC_EnableIRQ(DMA_INSTANCE_IRQ);
if (HAL_DMA_Start_IT(&DmaHandle, (uint32_t)&aSRC_Const_Buffer, (uint32_t)&aDST_Buffer, BUFFER_SIZE) != HAL_OK)
Error_Handler();
static void TransferComplete(DMA_HandleTypeDef *DmaHandle)
BSP_LED_On(LED1);
static void TransferError(DMA_HandleTypeDef *DmaHandle)
transferErrorDetected = 1;
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
char *w_buf = "AT24CXX I2C WRITE THEN READ TEST FOR LONG TIME";
uint8_t len = strlen(w_buf);
uint8_t r_buf[50] = {0};
int i = 0;
SystemClock_Config(CPU_CLK_160M);
printf("enter main\\r\\n");
printf("len = %d\\n", len);
GPIO_Init();
I2C_Init();
for (i = 0; i < len; i++)
HAL_I2C_Write(&hi2c, DEVICE_ADDR, 0x00 + i, (uint8_t *)(w_buf + i), 1);
HAL_Delay(10);
while (1)
memset(r_buf, 0, len);
if (HAL_I2C_Read(&hi2c, DEVICE_ADDR, 0x00, r_buf, len) != HAL_OK)
printf("read failed\\r\\n");
if (memcmp(w_buf, r_buf, len))
printf("err: %s\\r\\n", r_buf);
i++;
if ((i % 10000) == 0)
printf("i = %d\\r\\n", i);
while (1)
HAL_Delay(1000);
static void I2C_Init(void)
hi2c.Instance = I2C;
hi2c.Frequency = 400000;
HAL_I2C_Init(&hi2c);
static void GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIO_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_1;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void Error_Handler(void)
while (1)
void assert_failed(uint8_t *file, uint32_t line)
printf("Wrong parameters value: file %s on line %d\\r\\n", file, line);
int main(void)
uint32_t Res = FUNC_OK;
HAL_Init();
SystemClock_Config();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_TIM1_CLK_ENABLE();
Res = InitTIM(48);
if(Res != FUNC_OK)
return 0;
Res = AlcoholColumnCreate();
if(Res == FUNC_OK)
DeviceDS18B20Param DevParam;
ExtCodeDeviceDS18B20 DS18B20ExCode;
DevParam.GPIOTXPin = "PA10";
DevParam.GPIORXPin = "PA9";
Res = DeviceDS18B20Create(&DevParam, &DS18B20ExCode);
if(Res == FUNC_OK)
int8_t Temp, OverflowTemp;
uint8_t ReadyTemp;
int8_t Blink = -1;
Res = DeviceDS18B20ConversionTemperature();
if(Res != FUNC_OK)
return 0;
while (1)
DeviceDS18B20GetReadyTemperature(&ReadyTemp);
if(ReadyTemp)
Res = DeviceDS18B20GetTemperature(&Temp, &DS18B20ExCode);
if(Res == FUNC_OK)
AlcoholColumnSet(Temp);
if(Temp > TEMPERATURE_MAX || Temp < TEMPERATURE_MIN)
Blink = 0;
if(Temp > TEMPERATURE_MAX)
OverflowTemp = TEMPERATURE_MAX;
else
OverflowTemp = TEMPERATURE_MIN;
}else
Blink = -1;
DeviceDS18B20ConversionTemperature();
if(Blink != -1)
Blink = 1 - Blink;
if(Blink)
AlcoholColumnSet(OverflowTemp);
else
AlcoholColumnReset();
TIMDelay(SYS_DELAY);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
return;
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
return;
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
return;
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(TIM1_BRK_UP_TRG_COM_IRQn);
HAL_NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 1, 0);
int main(void)
HAL_Init();
SystemClock_Config();
init_led();
init_spi();
init_lis();
while (1)
int8_t x = read_x();
if (x > 0) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET);
} else {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET);
int8_t y = read_y();
if (y > 0) {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);
} else {
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 50;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART1_UART_Init();
SET_BIT(huart1.Instance->CR3, USART_CR3_DMAR);
__HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);
__HAL_DMA_DISABLE(&hdma_usart1_rx);
while(hdma_usart1_rx.Instance->CR & DMA_SxCR_EN)
__HAL_DMA_DISABLE(&hdma_usart1_rx);
hdma_usart1_rx.Instance->PAR = (uint32_t)&(USART1->DR);
hdma_usart1_rx.Instance->M0AR = (uint32_t) dmaRxBuffer[0];
hdma_usart1_rx.Instance->M1AR = (uint32_t) dmaRxBuffer[1];
hdma_usart1_rx.Instance->NDTR = 36;
SET_BIT(hdma_usart1_rx.Instance->CR, DMA_SxCR_DBM);
__HAL_DMA_ENABLE(&hdma_usart1_rx);
while (1)
if (((dmaData[5] >> 6) & mask) == 0x3)
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
else if (((dmaData[5] >> 6) & mask) == 0x2)
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET);
else
HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET);
if (((dmaData[5] >> 4) & mask) == 0x3)
HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_SET);
else if (((dmaData[5] >> 4) & mask) == 0x2)
HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_SET);
else
HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_RESET);
HAL_Delay(10);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 6;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
static int32_t platform_write(void *handle, uint8_t Reg, uint8_t *Bufp,
uint16_t len)
if (handle == &hi2c1)
HAL_I2C_Mem_Write(handle, slave_address, Reg,
I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000);
else if (handle == &hspi2)
HAL_GPIO_WritePin(CS_SPI2_GPIO_Port, CS_SPI2_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Transmit(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_SPI2_GPIO_Port, CS_SPI2_Pin, GPIO_PIN_SET);
else if (handle == &hspi1)
HAL_GPIO_WritePin(CS_SPI1_GPIO_Port, CS_SPI1_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Transmit(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_SPI1_GPIO_Port, CS_SPI1_Pin, GPIO_PIN_SET);
return 0;
static int32_t platform_read(void *handle, uint8_t Reg, uint8_t *Bufp,
uint16_t len)
if (handle == &hi2c1)
HAL_I2C_Mem_Read(handle, slave_address, Reg,
I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000);
else if (handle == &hspi2)
Reg |= 0x80;
HAL_GPIO_WritePin(CS_DEV_GPIO_Port, CS_DEV_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Receive(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_DEV_GPIO_Port, CS_DEV_Pin, GPIO_PIN_SET);
else
Reg |= 0x80;
HAL_GPIO_WritePin(CS_RF_GPIO_Port, CS_RF_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &Reg, 1, 1000);
HAL_SPI_Receive(handle, Bufp, len, 1000);
HAL_GPIO_WritePin(CS_RF_GPIO_Port, CS_RF_Pin, GPIO_PIN_SET);
return 0;
static void tx_com(uint8_t *tx_buffer, uint16_t len)
HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
CDC_Transmit_FS(tx_buffer, len);
static void platform_delay(uint32_t timeout)
volatile uint32_t i;
for(i = 0; i < timeout; i++);
static void platform_init(void)
uint8_t i;
GPIO_InitTypeDef GPIO_InitStruct;
GPIO_InitStruct.Pin = GPIO_PIN_8;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
for (i = 0; i < 9; i++) {
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
platform_delay(100);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_RESET);
platform_delay(100);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_8, GPIO_PIN_SET);
MX_I2C1_Init();
void example_main_double_tap_lsm6dsox(void)
lsm6dsox_ctx_t dev_ctx;
uint8_t whoamI, rst;
lsm6dsox_pin_int1_route_t int1_route;
lsm6dsox_pin_int2_route_t int2_route;
dev_ctx.write_reg = platform_write;
dev_ctx.read_reg = platform_read;
dev_ctx.handle = &hi2c1;
platform_init();
lsm6dsox_device_id_get(&dev_ctx, &whoamI);
if (whoamI != LSM6DSOX_ID)
while(1);
lsm6dsox_reset_set(&dev_ctx, PROPERTY_ENABLE);
do {
lsm6dsox_reset_get(&dev_ctx, &rst);
} while (rst);
lsm6dsox_i3c_disable_set(&dev_ctx, LSM6DSOX_I3C_DISABLE);
lsm6dsox_xl_data_rate_set(&dev_ctx, LSM6DSOX_XL_ODR_417Hz);
lsm6dsox_xl_full_scale_set(&dev_ctx, LSM6DSOX_2g);
lsm6dsox_tap_detection_on_z_set(&dev_ctx, PROPERTY_ENABLE);
lsm6dsox_tap_detection_on_y_set(&dev_ctx, PROPERTY_ENABLE);
lsm6dsox_tap_detection_on_x_set(&dev_ctx, PROPERTY_ENABLE);
lsm6dsox_tap_threshold_x_set(&dev_ctx, 0x08);
lsm6dsox_tap_threshold_y_set(&dev_ctx, 0x08);
lsm6dsox_tap_threshold_z_set(&dev_ctx, 0x08);
lsm6dsox_tap_dur_set(&dev_ctx, 0x07);
lsm6dsox_tap_quiet_set(&dev_ctx, 0x03);
lsm6dsox_tap_shock_set(&dev_ctx, 0x03);
lsm6dsox_tap_mode_set(&dev_ctx, LSM6DSOX_BOTH_SINGLE_DOUBLE);
lsm6dsox_pin_int1_route_get(&dev_ctx, &int1_route);
int1_route.md1_cfg.int1_double_tap = PROPERTY_ENABLE;
int1_route.md1_cfg.int1_single_tap = PROPERTY_ENABLE;
lsm6dsox_pin_int1_route_set(&dev_ctx, &int1_route);
lsm6dsox_pin_int2_route_get(&dev_ctx, &int2_route);
int2_route.md2_cfg.int2_double_tap = PROPERTY_ENABLE;
int2_route.md2_cfg.int2_single_tap = PROPERTY_ENABLE;
lsm6dsox_pin_int2_route_set(&dev_ctx, &int2_route);
while(1)
lsm6dsox_all_sources_t all_source;
lsm6dsox_all_sources_get(&dev_ctx, &all_source);
if (all_source.tap_src.double_tap)
sprintf((char*)tx_buffer, "D-Tap: ");
if (all_source.tap_src.x_tap)
strcat((char*)tx_buffer, "x-axis");
else if (all_source.tap_src.y_tap)
strcat((char*)tx_buffer, "y-axis");
else
strcat((char*)tx_buffer, "z-axis");
if (all_source.tap_src.tap_sign)
strcat((char*)tx_buffer, " negative");
else
strcat((char*)tx_buffer, " positive");
strcat((char*)tx_buffer, " sign\\r\\n");
tx_com(tx_buffer, strlen((char const*)tx_buffer));
if (all_source.tap_src.single_tap)
sprintf((char*)tx_buffer, "S-Tap: ");
if (all_source.tap_src.x_tap)
strcat((char*)tx_buffer, "x-axis");
else if (all_source.tap_src.y_tap)
strcat((char*)tx_buffer, "y-axis");
else
strcat((char*)tx_buffer, "z-axis");
if (all_source.tap_src.tap_sign)
strcat((char*)tx_buffer, " negative");
else
strcat((char*)tx_buffer, " positive");
strcat((char*)tx_buffer, " sign\\r\\n");
tx_com(tx_buffer, strlen((char const*)tx_buffer));
int main(void)
HAL_Init();
system_t sys ;
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_I2C1_Init();
MX_USART1_UART_Init();
MX_TIM2_Init();
SCHEDULER_init(&sys);
EVENT_init(&sys, &htim2);
LED_SEQUENCE_init(&sys.led, LED_1_GPIO_Port, LED_1_Pin, SEQUENCE_LED_1, 200, 12, 1);
MPU_init(&sys.sensors.mpu, &hi2c1);
GYRO_init(&sys.sensors.gyro, &sys.sensors.mpu);
if(sys.sensors.gyro.state != SENSOR_IDDLE)
LED_SEQUENCE_set_sequence(&sys.led, SEQUENCE_LED_2);
while (1)
SCHEDULER_run();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USB_DEVICE_Init();
MX_TIM3_Init();
MX_TIM9_Init();
HAL_TIM_PWM_Start(&htim9, TIM_CHANNEL_2);
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
while (1)
TIM3->CCR2 = DR;
TIM9->CCR2 = DL;
switch(status){
case RWHEEL_SPEEDUP:
if (DR <= 62000)
DR = DR + 3000;
status = -1;
break;
case RWHEEL_SLOWDOWN:
if (DR >= 3000)
DR = DR - 3000;
status = -1;
break;
case RWHEEL_STOP:
DR = 0;
status = -1;
break;
case RWHEEL_FORWARD:
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);
status = -1;
break;
case RWHEEL_BACKWARD:
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_SET);
status = -1;
break;
case LWHEEL_SPEEDUP:
if (DL <= 62000)
DL = DL + 3000;
status = -1;
break;
case LWHEEL_SLOWDOWN:
if (DL >= 3000)
DL = DL - 3000;
status = -1;
break;
case LWHEEL_STOP:
DL = 0;
status = -1;
break;
case LWHEEL_FORWARD:
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_RESET);
status = -1;
break;
case LWHEEL_BACKWARD:
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_7, GPIO_PIN_SET);
status = -1;
break;
default:
break;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 144;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 3;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_TIM3_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
htim3.Instance = TIM3;
htim3.Init.Prescaler = 0;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 65535;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim3) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim3);
static void MX_TIM9_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
htim9.Instance = TIM9;
htim9.Init.Prescaler = 0;
htim9.Init.CounterMode = TIM_COUNTERMODE_UP;
htim9.Init.Period = 65535;
htim9.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim9.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim9) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim9, &sClockSourceConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Init(&htim9) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = 0;
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
if (HAL_TIM_PWM_ConfigChannel(&htim9, &sConfigOC, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim9);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5|GPIO_PIN_6, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6|GPIO_PIN_7, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_6|GPIO_PIN_7;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED4);
BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);
DacHandle.Instance = DAC;
TIM6_Config();
while (1)
if (ubKeyPressed != RESET)
HAL_DAC_DeInit(&DacHandle);
if (ubSelectedWavesForm == 1)
DAC_Ch1_TriangleConfig();
else
DAC_Ch1_EscalatorConfig();
ubKeyPressed = RESET;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
static void Error_Handler(void)
BSP_LED_On(LED4);
while(1)
static void DAC_Ch1_EscalatorConfig(void)
if(HAL_DAC_Init(&DacHandle) != HAL_OK)
Error_Handler();
sConfig.DAC_Trigger = DAC_TRIGGER_T6_TRGO;
sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
if(HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL1) != HAL_OK)
Error_Handler();
if(HAL_DAC_Start_DMA(&DacHandle, DACx_CHANNEL1, (uint32_t*)aEscalator8bit, 6, DAC_ALIGN_8B_R) != HAL_OK)
Error_Handler();
static void DAC_Ch1_TriangleConfig(void)
if(HAL_DAC_Init(&DacHandle) != HAL_OK)
Error_Handler();
sConfig.DAC_Trigger = DAC_TRIGGER_T6_TRGO;
sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
if(HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL1) != HAL_OK)
Error_Handler();
if(HAL_DACEx_TriangleWaveGenerate(&DacHandle, DACx_CHANNEL1, DAC_TRIANGLEAMPLITUDE_1023) != HAL_OK)
Error_Handler();
if(HAL_DAC_Start(&DacHandle, DACx_CHANNEL1) != HAL_OK)
Error_Handler();
if(HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL1, DAC_ALIGN_12B_R, 0x100) != HAL_OK)
Error_Handler();
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
ubKeyPressed = 1;
ubSelectedWavesForm = !ubSelectedWavesForm;
void TIM6_Config(void)
static TIM_HandleTypeDef htim;
TIM_MasterConfigTypeDef  sMasterConfig;
htim.Instance = TIM6;
htim.Init.Period = 0x7FF;
htim.Init.Prescaler = 0;
htim.Init.ClockDivision = 0;
htim.Init.CounterMode = TIM_COUNTERMODE_UP;
HAL_TIM_Base_Init(&htim);
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
HAL_TIMEx_MasterConfigSynchronization(&htim, &sMasterConfig);
HAL_TIM_Base_Start(&htim);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int __io_putchar(int ch)
HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 5);
return ch;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART3_UART_Init();
MX_USB_OTG_FS_PCD_Init();
osThreadDef(defaultTask, StartDefaultTask, osPriorityIdle, 0, 128);
defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
osThreadDef(tcpSocketServer, StartTcpSocketServerTask, osPriorityAboveNormal, 0, 256);
tcpSocketServerHandle = osThreadCreate(osThread(tcpSocketServer), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart3) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USB_OTG_FS_PCD_Init(void)
hpcd_USB_OTG_FS.Instance = USB_OTG_FS;
hpcd_USB_OTG_FS.Init.dev_endpoints = 4;
hpcd_USB_OTG_FS.Init.speed = PCD_SPEED_FULL;
hpcd_USB_OTG_FS.Init.dma_enable = DISABLE;
hpcd_USB_OTG_FS.Init.ep0_mps = DEP0CTL_MPS_64;
hpcd_USB_OTG_FS.Init.phy_itface = PCD_PHY_EMBEDDED;
hpcd_USB_OTG_FS.Init.Sof_enable = ENABLE;
hpcd_USB_OTG_FS.Init.low_power_enable = DISABLE;
hpcd_USB_OTG_FS.Init.lpm_enable = DISABLE;
hpcd_USB_OTG_FS.Init.vbus_sensing_enable = ENABLE;
hpcd_USB_OTG_FS.Init.use_dedicated_ep1 = DISABLE;
if (HAL_PCD_Init(&hpcd_USB_OTG_FS) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USER_Btn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD3_Pin|LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
void StartDefaultTask(void const * argument)
for(;;){osDelay(1);}
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM1) {
HAL_IncTick();
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED_RED);
BSP_LED_Toggle(LED_RED);
HAL_Delay(1000);
BSP_LED_Toggle(LED_RED);
BSP_LED_Init(LED_GREEN);
while(1)
BSP_LED_Toggle(LED_GREEN);
HAL_Delay(200);
var++;
if(var > 20)
HAL_NVIC_SystemReset();
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 8;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 8;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);
if(ret != HAL_OK)
while(1) { ; }
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED5);
DacHandle.Instance = DACx;
if (HAL_DAC_DeInit(&DacHandle) != HAL_OK)
Error_Handler();
if (HAL_DAC_Init(&DacHandle) != HAL_OK)
Error_Handler();
sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
if (HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL) != HAL_OK)
Error_Handler();
if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_8B_R, 0xFF) != HAL_OK)
Error_Handler();
if (HAL_DAC_Start(&DacHandle, DACx_CHANNEL) != HAL_OK)
Error_Handler();
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1) {};
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
while(1) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
while(1) {};
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void Error_Handler(void)
BSP_LED_On(LED5);
while(1)
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
printf("STM32F7 Calibration Completed!\\r\\n");
HAL_Delay(500);
while (1)
HAL_UART_Transmit(&huart1,(uint8_t *)&ch,100,0xFFFF);
printf("\\t");
printf("The value of counter is %d",c);
printf("\\r\\n");
c++;
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 400;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 9600;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
MPU_RegionConfig();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
MPU_AccessPermConfig();
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(100);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED2);
SystemClock_Config();
HAL_FLASH_Unlock();
EraseInitStruct.TypeErase   = FLASH_TYPEERASE_PAGES;
EraseInitStruct.PageAddress = FLASH_USER_START_ADDR;
EraseInitStruct.NbPages     = (FLASH_USER_END_ADDR - FLASH_USER_START_ADDR) / FLASH_PAGE_SIZE;
if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK)
while (1)
BSP_LED_On(LED2);
HAL_Delay(100);
BSP_LED_Off(LED2);
HAL_Delay(2000);
Address = FLASH_USER_START_ADDR;
while (Address < FLASH_USER_END_ADDR)
if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, DATA_32) == HAL_OK)
Address = Address + 4;
else
while (1)
BSP_LED_On(LED2);
HAL_Delay(100);
BSP_LED_Off(LED2);
HAL_Delay(2000);
HAL_FLASH_Lock();
Address = FLASH_USER_START_ADDR;
MemoryProgramStatus = 0x0;
while (Address < FLASH_USER_END_ADDR)
data32 = *(__IO uint32_t *)Address;
if (data32 != DATA_32)
MemoryProgramStatus++;
Address = Address + 4;
if (MemoryProgramStatus == 0)
BSP_LED_On(LED2);
else
while (1)
BSP_LED_On(LED2);
HAL_Delay(1000);
BSP_LED_Off(LED2);
HAL_Delay(1000);
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSI;
oscinitstruct.HSEState        = RCC_HSE_OFF;
oscinitstruct.LSEState        = RCC_LSE_OFF;
oscinitstruct.HSIState        = RCC_HSI_ON;
oscinitstruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
oscinitstruct.HSEPredivValue    = RCC_HSE_PREDIV_DIV1;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSI_DIV2;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL16;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
while(1);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
SystemClock_Config();
BSP_LED_On(LED1);
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if(HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
if(HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR0) != 0x32F2)
RTC_CalendarConfig();
else
if(__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
BSP_LED_On(LED2);
if(__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
BSP_LED_On(LED4);
__HAL_RCC_CLEAR_RESET_FLAGS();
while (1)
RTC_CalendarShow(aShowTime, aShowDate);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
static void RTC_CalendarConfig(void)
RTC_DateTypeDef sdatestructure;
RTC_TimeTypeDef stimestructure;
sdatestructure.Year = 0x14;
sdatestructure.Month = RTC_MONTH_FEBRUARY;
sdatestructure.Date = 0x18;
sdatestructure.WeekDay = RTC_WEEKDAY_TUESDAY;
if(HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
stimestructure.Hours = 0x02;
stimestructure.Minutes = 0x00;
stimestructure.Seconds = 0x00;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
if(HAL_RTC_SetTime(&RtcHandle,&stimestructure,RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&RtcHandle,RTC_BKP_DR0,0x32F2);
static void RTC_CalendarShow(uint8_t* showtime, uint8_t* showdate)
RTC_DateTypeDef sdatestructureget;
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char*)showtime,"%02d:%02d:%02d",stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
sprintf((char*)showdate,"%02d-%02d-%02d",sdatestructureget.Month, sdatestructureget.Date, 2000 + sdatestructureget.Year);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
GPIO_InitTypeDef GPIO_InitStruct;
HAL_Init();
BSP_LED_Init(LED2);
SystemClock_Config();
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);
while (1)
HAL_Delay(5000);
BSP_LED_Off(LED2);
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Pin = GPIO_PIN_All;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOF, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
__HAL_RCC_GPIOA_CLK_DISABLE();
__HAL_RCC_GPIOB_CLK_DISABLE();
__HAL_RCC_GPIOD_CLK_DISABLE();
__HAL_RCC_GPIOE_CLK_DISABLE();
__HAL_RCC_GPIOF_CLK_DISABLE();
__HAL_RCC_GPIOG_CLK_DISABLE();
__HAL_RCC_GPIOH_CLK_DISABLE();
HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
SYSCLKConfig_STOP();
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 40;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
static void SYSCLKConfig_STOP(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
uint32_t pFLatency = 0;
__HAL_RCC_PWR_CLK_ENABLE();
HAL_RCC_GetOscConfig(&RCC_OscInitStruct);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_NONE;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
HAL_RCC_GetClockConfig(&RCC_ClkInitStruct, &pFLatency);
RCC_ClkInitStruct.ClockType     = RCC_CLOCKTYPE_SYSCLK;
RCC_ClkInitStruct.SYSCLKSource  = RCC_SYSCLKSOURCE_PLLCLK;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, pFLatency) != HAL_OK)
Error_Handler();
void Error_Handler(void)
HAL_SuspendTick();
BSP_LED_On(LED2);
while (1)
void HAL_SYSTICK_Callback(void)
HAL_IncTick();
if (TimingDelay != 0)
TimingDelay--;
else
BSP_LED_Toggle(LED2);
TimingDelay = LED_TOGGLE_DELAY;
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == USER_BUTTON_PIN)
BSP_LED_Init(LED2);
BSP_LED_On(LED2);
void assert_failed(char *file, uint32_t line)
while (1)
for (int k = 0; k < nTail; k++)
if (tailX[k] == j && tailY[k] == i)
ssd1331_draw_point(j, i, GREEN);
print = true;
if (!print)
ssd1331_draw_point(j, i, BLACK);
if (j == width - 1)
ssd1331_draw_point(j, i, BLUE);
for (int i = 0; i < width ; i++) {
ssd1331_draw_point(i, 40, BLUE);
for (int i = 1; i < nTail; i++)
prev2X = tailX[i];
prev2Y = tailY[i];
tailX[i] = prevX;
tailY[i] = prevY;
prevX = prev2X;
prevY = prev2Y;
for (int i = 0; i < nTail; i++)
if (tailX[i] == x && tailY[i] == y)
GameOver = true;
int main(void)
int16_t xyz[3]={0};
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
MX_I2C1_Init();
MX_I2S3_Init();
BSP_ACCELERO_Init();
ssd1331_init();
Setup();
while(!GameOver)
Draw();
Logic();
BSP_ACCELERO_GetXYZ(xyz);
if(xyz[2] <= 920  && xyz[0] <= 300 && xyz[0] >= -300 && xyz[1] <= 100){
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET);
dir = UP;
}else{
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET);
if(xyz[0] <= -250 && xyz[1] <= 300){
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);
dir = RIGHT;
}else{
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);
if(xyz[1] >= 250 ){
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET);
dir = DOWN;
}else{
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET);
if(xyz[0] >= 300 ){
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET);
dir = LEFT;
}else{
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET);
ssd1331_clear_screen(BLACK);
ssd1331_display_string(20, 21, "GAME OVER!  ", FONT_1206,YELLOW);
ssd1331_display_string(20, 41, "Score:  ", FONT_1206,YELLOW);
ssd1331_display_num(55, 41, score, 3, FONT_1206,YELLOW);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue =16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN =168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_I2S;
PeriphClkInitStruct.PLLI2S.PLLI2SN = 50;
PeriphClkInitStruct.PLLI2S.PLLI2SR = 2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 1000000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_I2S3_Init(void)
hi2s3.Instance = SPI3;
hi2s3.Init.Mode = I2S_MODE_MASTER_TX;
hi2s3.Init.Standard = I2S_STANDARD_PHILIPS;
hi2s3.Init.DataFormat = I2S_DATAFORMAT_16B;
hi2s3.Init.MCLKOutput = I2S_MCLKOUTPUT_DISABLE;
hi2s3.Init.AudioFreq = I2S_AUDIOFREQ_8K;
hi2s3.Init.CPOL = I2S_CPOL_LOW;
hi2s3.Init.ClockSource = I2S_CLOCK_PLL;
hi2s3.Init.FullDuplexMode = I2S_FULLDUPLEXMODE_ENABLE;
if (HAL_I2S_Init(&hi2s3) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3|RES_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(DC_GPIO_Port, DC_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_3|RES_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = DC_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(DC_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
SCB_EnableICache();
SCB_EnableDCache();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
MX_FMC_Init();
MX_QUADSPI_Init();
MX_SDMMC1_SD_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 3;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLQ = 4;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
|RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_QUADSPI_Init(void)
hqspi.Instance = QUADSPI;
hqspi.Init.ClockPrescaler = 1;
hqspi.Init.FifoThreshold = 3;
hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;
hqspi.Init.FlashSize = 24;
hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_2_CYCLE;
hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
hqspi.Init.FlashID = QSPI_FLASH_ID_1;
hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
if (HAL_QSPI_Init(&hqspi) != HAL_OK)
Error_Handler();
static void MX_SDMMC1_SD_Init(void)
hsd1.Instance = SDMMC1;
hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
hsd1.Init.BusWide = SDMMC_BUS_WIDE_4B;
hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
hsd1.Init.ClockDiv = 4;
if (HAL_SD_Init(&hsd1) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
Error_Handler();
static void MX_FMC_Init(void)
FMC_SDRAM_TimingTypeDef SdramTiming = {0};
hsdram1.Instance = FMC_SDRAM_DEVICE;
hsdram1.Init.SDBank = FMC_SDRAM_BANK1;
hsdram1.Init.ColumnBitsNumber = FMC_SDRAM_COLUMN_BITS_NUM_9;
hsdram1.Init.RowBitsNumber = FMC_SDRAM_ROW_BITS_NUM_12;
hsdram1.Init.MemoryDataWidth = FMC_SDRAM_MEM_BUS_WIDTH_32;
hsdram1.Init.InternalBankNumber = FMC_SDRAM_INTERN_BANKS_NUM_4;
hsdram1.Init.CASLatency = FMC_SDRAM_CAS_LATENCY_2;
hsdram1.Init.WriteProtection = FMC_SDRAM_WRITE_PROTECTION_DISABLE;
hsdram1.Init.SDClockPeriod = FMC_SDRAM_CLOCK_PERIOD_2;
hsdram1.Init.ReadBurst = FMC_SDRAM_RBURST_ENABLE;
hsdram1.Init.ReadPipeDelay = FMC_SDRAM_RPIPE_DELAY_0;
SdramTiming.LoadToActiveDelay = 2;
SdramTiming.ExitSelfRefreshDelay = 7;
SdramTiming.SelfRefreshTime = 5;
SdramTiming.RowCycleDelay = 6;
SdramTiming.WriteRecoveryTime = 3;
SdramTiming.RPDelay = 2;
SdramTiming.RCDDelay = 2;
if (HAL_SDRAM_Init(&hsdram1, &SdramTiming) != HAL_OK)
Error_Handler( );
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOI_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = LED_RED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_RED_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
trace_printf("Hello\\n");
uint16_t ConvertedValue = 0;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
BSP_ADC_Init(&hadc_bsp3,ADC_IN0,1,Indepenent_Mode);
HAL_ADC_Start_DMA(&hadc_bsp3,ConvertedValue,1);
while (1)
ConvertedValue = HAL_ADC_GetValue(&hadc_bsp3);
trace_printf("%04d\\n\\r",ConvertedValue);
HAL_Delay(500);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 210;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_HSE_DIV8;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc)
void assert_failed(uint8_t* file, uint32_t line)
static void DelayLoop( volatile uint32_t nCount )
volatile uint32_t index = 0;
for( index = ( 5000 * nCount ); index != 0; index-- )
int main( void )
uint8_t regValue = 0;
uint8_t status = 0;
uint16_t offset = 0;
HAL_Init( );
SystemClockConfig( );
I2cInit( &I2c, I2C_SCL, I2C_SDA );
GpioInit( &Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led3, LED_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
SX9500Init( );
DelayLoop( 100 );
SX9500Write( SX9500_REG_IRQMSK, 0x10 );
SX9500Write( SX9500_REG_IRQSRC, 0x10 );
do
SX9500Read( SX9500_REG_IRQSRC, &status );
}while( ( status & 0x10 ) == 0x00 );
SX9500Read( SX9500_REG_OFFSETMSB, ( uint8_t* )&regValue );
offset = regValue << 8;
SX9500Read( SX9500_REG_OFFSETLSB, ( uint8_t* )&regValue );
offset |= regValue;
if( offset < 2000 )
if( ( ( *( volatile uint32_t* )USBD_DFU_APP_DEFAULT_ADD ) & 0x2FFE0000 ) == 0x20000000 )
JumpAddress = *( volatile uint32_t* ) ( USBD_DFU_APP_DEFAULT_ADD + 4 );
JumpToApplication = ( pFunction ) JumpAddress;
__set_MSP( *( volatile uint32_t* ) USBD_DFU_APP_DEFAULT_ADD );
JumpToApplication( );
USBD_Init( &USBD_Device, &DFU_Desc, 0 );
USBD_RegisterClass( &USBD_Device, USBD_DFU_CLASS );
USBD_DFU_RegisterMedia( &USBD_Device, &USBD_DFU_Flash_fops );
USBD_Start( &USBD_Device );
while( 1 )
GpioWrite( &Led1, 0 );
GpioWrite( &Led2, 0 );
GpioWrite( &Led3, 0 );
DelayLoop( 500 );
GpioWrite( &Led1, 1 );
GpioWrite( &Led2, 1 );
GpioWrite( &Led3, 1 );
DelayLoop( 500 );
void SystemClockConfig( void )
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLL_DIV3;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 );
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_1 );
void SysTick_Handler( void )
HAL_IncTick( );
void USB_LP_IRQHandler( void )
HAL_PCD_IRQHandler( &hpcd );
void assert_failed( uint8_t* file, uint32_t line )
while( 1 )
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
transferErrorDetected = 0;
transferCompleteDetected = 0;
DMA_Config();
while (1)
if (transferErrorDetected == 1)
BSP_LED_On(LED2);
transferErrorDetected = 0;
if (transferCompleteDetected == 1)
BSP_LED_On(LED1);
transferCompleteDetected = 0;
static void DMA_Config(void)
__HAL_RCC_DMA1_CLK_ENABLE();
DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;
DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
DmaHandle.Init.Mode = DMA_NORMAL;
DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;
DmaHandle.Instance = DMA_INSTANCE;
DmaHandle.XferCpltCallback  = TransferComplete;
DmaHandle.XferErrorCallback = TransferError;
if (HAL_DMA_Init(&DmaHandle) != HAL_OK)
Error_Handler();
HAL_NVIC_SetPriority(DMA_INSTANCE_IRQ, 0, 0);
HAL_NVIC_EnableIRQ(DMA_INSTANCE_IRQ);
if (HAL_DMA_Start_IT(&DmaHandle, (uint32_t)&aSRC_Const_Buffer, (uint32_t)&aDST_Buffer, BUFFER_SIZE) != HAL_OK)
Error_Handler();
static void TransferComplete(DMA_HandleTypeDef *DmaHandle)
transferCompleteDetected = 1;
static void TransferError(DMA_HandleTypeDef *DmaHandle)
transferErrorDetected = 1;
void SystemClock_Config(void)
RCC_ClkInitTypeDef clkinitstruct = {0};
RCC_OscInitTypeDef oscinitstruct = {0};
oscinitstruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;
oscinitstruct.HSEState        = RCC_HSE_ON;
oscinitstruct.HSEPredivValue  = RCC_HSE_PREDIV_DIV1;
oscinitstruct.PLL.PLLState    = RCC_PLL_ON;
oscinitstruct.PLL.PLLSource   = RCC_PLLSOURCE_HSE;
oscinitstruct.PLL.PLLMUL      = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK)
while(1);
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK)
while(1);
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART1_UART_Init();
osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 256);
defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
RCC_OscInitStruct.PLL.PLLN = 85;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_8) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1;
PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&huart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&huart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&huart1) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMAMUX1_CLK_ENABLE();
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 5, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
HAL_NVIC_SetPriority(DMA1_Channel2_IRQn, 5, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void StartDefaultTask(void const * argument)
for(;;)
osDelay(1);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM17) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED6);
BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_EXTI);
while (1)
HAL_Delay(1000);
BSP_LED_Toggle(LED6);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == WAKEUP_BUTTON_PIN)
if (uwIncrementState == 0)
HAL_SuspendTick();
uwIncrementState = 1;
else
HAL_ResumeTick();
uwIncrementState = 0;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef  ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
UartHandle.Instance        = USARTx;
UartHandle.Init.BaudRate   = 9600;
UartHandle.Init.WordLength = UART_WORDLENGTH_8B;
UartHandle.Init.StopBits   = UART_STOPBITS_1;
UartHandle.Init.Parity     = UART_PARITY_ODD;
UartHandle.Init.HwFlowCtl  = UART_HWCONTROL_NONE;
UartHandle.Init.Mode       = UART_MODE_TX_RX;
UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&UartHandle) != HAL_OK)
Error_Handler();
printf("\\n\\r UART Printf Example: retarget the C library printf function to the UART\\n\\r");
printf("** Test finished successfully. ** \\n\\r");
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if(ret != HAL_OK)
while(1) { ; }
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
IMU_init_ok = false;
SCB_EnableICache();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_ADC1_Init();
MX_DAC_Init();
MX_I2C1_Init();
MX_I2C3_Init();
MX_SDMMC1_SD_Init();
MX_SPI2_Init();
MX_SPI3_Init();
MX_TIM2_Init();
MX_TIM3_Init();
MX_TIM4_Init();
MX_TIM5_Init();
MX_TIM6_Init();
MX_TIM7_Init();
MX_USART1_UART_Init();
MX_USART2_UART_Init();
MX_FATFS_Init();
CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
DWT->LAR = 0xC5ACCE55;
DWT->CYCCNT = 0;
DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3);
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);
IMU_init_ok = IMU_Init();
HAL_TIM_Base_Start_IT(&htim4);
while (1)
double start = DWT->CYCCNT;
IMU_calcAngle();
double stop = DWT->CYCCNT;
looptime = (stop - start)/216000000.0;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2
|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C3
|RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48;
PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;
PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL;
PeriphClkInitStruct.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_CLK48;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_GPIO);
if(BSP_PB_GetState(BUTTON_WAKEUP) == 0x00)
if(((*(__IO uint32_t*)USBD_DFU_APP_DEFAULT_ADD) & 0x2FF80000 ) == 0x20000000)
JumpAddress = *(__IO uint32_t*) (USBD_DFU_APP_DEFAULT_ADD + 4);
JumpToApplication = (pFunction) JumpAddress;
__set_MSP(*(__IO uint32_t*) USBD_DFU_APP_DEFAULT_ADD);
JumpToApplication();
USBD_Init(&USBD_Device, &DFU_Desc, 0);
USBD_RegisterClass(&USBD_Device, USBD_DFU_CLASS);
USBD_DFU_RegisterMedia(&USBD_Device, &USBD_DFU_Flash_fops);
USBD_Start(&USBD_Device);
while (1)
void HAL_Delay(__IO uint32_t Delay)
while(Delay)
if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)
Delay--;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
PeriphClkInitStruct.PLLI2S.PLLI2SM = 8;
PeriphClkInitStruct.PLLI2S.PLLI2SQ = 4;
PeriphClkInitStruct.PLLI2S.PLLI2SN = 192;
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLI2SQ;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main( void )
BaseType_t x;
prvSetupHardware();
xControlMessageBuffer = xMessageBufferCreateStatic(
mbaCONTROL_MESSAGE_BUFFER_SIZE,
ucControlBufferStorage,
&xControlMessageBufferStruct );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xDataMessageBuffers[ x ] = xMessageBufferCreateStatic( mbaTASK_MESSAGE_BUFFER_SIZE,
&( ucDataBufferStorage[ x ][ 0 ] ),
&( xDataMessageBufferStructs[ x ] ) );
prvWaitForOtherCoreToStart( mainINDEX_TO_TEST, mainINDEX_TO_INCREMENT );
xTaskCreate( prvM7CoreTasks,
"AMPM7Core",
configMINIMAL_STACK_SIZE,
NULL,
tskIDLE_PRIORITY,
&xM7AMPTask );
vTaskStartScheduler();
for( ;; );
static void prvM7CoreTasks( void *pvParameters )
BaseType_t x;
uint32_t ulNextValue = 0;
char cString[ 15 ];
size_t xStringLength;
( void ) pvParameters;
for( ;; )
sprintf( cString, "%lu", ( unsigned long ) ulNextValue );
xStringLength = strlen( cString );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
while( xMessageBufferSend( 	xDataMessageBuffers[ x ],
( void * ) cString,
xStringLength,
portMAX_DELAY ) != xStringLength );
ulNextValue++;
void vGenerateM7ToM4Interrupt( void * xUpdatedMessageBuffer )
MessageBufferHandle_t xUpdatedBuffer = ( MessageBufferHandle_t ) xUpdatedMessageBuffer;
if( xUpdatedBuffer != xControlMessageBuffer )
while( xMessageBufferSend( xControlMessageBuffer, &xUpdatedBuffer, sizeof( xUpdatedBuffer ), mbaDONT_BLOCK ) != sizeof( xUpdatedBuffer ) )
HAL_EXTI_D1_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, DISABLE );
HAL_EXTI_D2_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, ENABLE );
HAL_EXTI_GenerateSWInterrupt( EXTI_LINE0 );
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, uint32_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
static StaticTask_t xIdleTaskTCB;
static uint32_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];
*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
*ppxIdleTaskStackBuffer = uxIdleTaskStack;
*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
static void prvWaitForOtherCoreToStart( uint32_t ulIndexToTest, uint32_t ulIndexToIncrement )
volatile uint32_t ulInitialCount = ulStartSyncCounters[ ulIndexToTest ], x;
const uint32_t ulCrudeLoopDelay = 0xfffffUL;
while( ulStartSyncCounters[ ulIndexToTest ] == ulInitialCount );
ulInitialCount = ulStartSyncCounters[ ulIndexToTest ];
for( ;; )
ulStartSyncCounters[ ulIndexToIncrement ]++;
if( ulStartSyncCounters[ ulIndexToTest ] != ulInitialCount )
ulStartSyncCounters[ ulIndexToIncrement ]++;
break;
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_Off( LED2 );
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_On( LED2 );
void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
uint32_t x;
configASSERT( xM7AMPTask );
HAL_EXTI_D1_ClearFlag( EXTI_LINE1 );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xMessageBufferReceiveCompletedFromISR( xDataMessageBuffers[ x ], &xHigherPriorityTaskWoken );
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
static void prvSetupHardware( void )
MPU_Region_InitTypeDef MPU_InitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = D3_SRAM_BASE;
MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
SCB_EnableICache();
SCB_EnableDCache();
HAL_Init();
BSP_LED_Init(LED1);
HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while( !__HAL_PWR_GET_FLAG( PWR_FLAG_VOSRDY ) )
__asm volatile ( "NOP" );
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 160;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLQ = 4;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
configASSERT( HAL_RCC_OscConfig( &RCC_OscInitStruct ) == HAL_OK );
RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \\
RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1 );
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
configASSERT( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_4 ) == HAL_OK );
HAL_EXTI_EdgeConfig( EXTI_LINE0, EXTI_RISING_EDGE );
HAL_NVIC_SetPriority( EXTI1_IRQn, 0xFU, 0U );
HAL_NVIC_EnableIRQ( EXTI1_IRQn );
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_LPUART1_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;
RCC_OscInitStruct.PLL.PLLN = 85;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1;
PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_LPUART1_UART_Init(void)
hlpuart1.Instance = LPUART1;
hlpuart1.Init.BaudRate = 115200;
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
hlpuart1.Init.StopBits = UART_STOPBITS_1;
hlpuart1.Init.Parity = UART_PARITY_NONE;
hlpuart1.Init.Mode = UART_MODE_TX_RX;
hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;
hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&hlpuart1) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)
Error_Handler();
if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART2_UART_Init();
MX_ADC1_Init();
MX_I2C1_Init();
HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED);
HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&adc_data[ 0 ], ADC_BUFFER_SIZE_HALF);
printf("Voltmeter 3000\\n");
holed1.hi2cx = &hi2c1;
ssd1306_Init(&holed1);
ssd1306_Fill(&holed1, Black);
ssd1306_SetCursor(&holed1, 2, 0);
ssd1306_WriteString(&holed1, "Voltmeter", Font_7x10, White);
ssd1306_UpdateScreen(&holed1);
while (1)
float volts = (float)adc_data[0] *3.3f / 4096.0f;
char lcd_string[32];
sprintf(lcd_string, "%.3f V", volts);
printf(lcd_string);
printf("\\n");
ssd1306_SetCursor(&holed1, 2, 15);
ssd1306_WriteString(&holed1, lcd_string, Font_16x26, White);
ssd1306_UpdateScreen(&holed1);
HAL_Delay(500);
HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC1_Init(void)
ADC_MultiModeTypeDef multimode = {0};
ADC_ChannelConfTypeDef sConfig = {0};
hadc1.Instance = ADC1;
hadc1.Init.ClockPrescaler = ADC_CLOCK_SYNC_PCLK_DIV1;
hadc1.Init.Resolution = ADC_RESOLUTION_12B;
hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
hadc1.Init.ContinuousConvMode = ENABLE;
hadc1.Init.DiscontinuousConvMode = DISABLE;
hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc1.Init.NbrOfConversion = 1;
hadc1.Init.DMAContinuousRequests = ENABLE;
hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
hadc1.Init.LowPowerAutoWait = DISABLE;
hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
if (HAL_ADC_Init(&hadc1) != HAL_OK)
Error_Handler();
multimode.Mode = ADC_MODE_INDEPENDENT;
if (HAL_ADCEx_MultiModeConfigChannel(&hadc1, &multimode) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_7;
sConfig.Rank = ADC_REGULAR_RANK_1;
sConfig.SingleDiff = ADC_SINGLE_ENDED;
sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
sConfig.OffsetNumber = ADC_OFFSET_NONE;
sConfig.Offset = 0;
if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.Timing = 0x2000090E;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
Error_Handler();
if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 19200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
HAL_FLASH_Unlock();
FirstSector = GetSector(FLASH_USER_START_ADDR);
NbOfSectors = GetSector(FLASH_USER_END_ADDR) - FirstSector + 1;
EraseInitStruct.TypeErase     = FLASH_TYPEERASE_SECTORS;
EraseInitStruct.VoltageRange  = FLASH_VOLTAGE_RANGE_3;
EraseInitStruct.Sector        = FirstSector;
EraseInitStruct.NbSectors     = NbOfSectors;
if (HAL_FLASHEx_Erase(&EraseInitStruct, &SECTORError) != HAL_OK)
while (1)
BSP_LED_On(LED3);
Address = FLASH_USER_START_ADDR;
while (Address < FLASH_USER_END_ADDR)
if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, DATA_32) == HAL_OK)
Address = Address + 4;
else
while (1)
BSP_LED_On(LED3);
HAL_FLASH_Lock();
Address = FLASH_USER_START_ADDR;
MemoryProgramStatus = 0x0;
while (Address < FLASH_USER_END_ADDR)
data32 = *(__IO uint32_t *)Address;
if (data32 != DATA_32)
MemoryProgramStatus++;
Address = Address + 4;
if (MemoryProgramStatus == 0)
BSP_LED_On(LED1);
else
BSP_LED_On(LED2);
while (1)
static uint32_t GetSector(uint32_t Address)
uint32_t sector = 0;
if((Address < ADDR_FLASH_SECTOR_1) && (Address >= ADDR_FLASH_SECTOR_0))
sector = FLASH_SECTOR_0;
else if((Address < ADDR_FLASH_SECTOR_2) && (Address >= ADDR_FLASH_SECTOR_1))
sector = FLASH_SECTOR_1;
else if((Address < ADDR_FLASH_SECTOR_3) && (Address >= ADDR_FLASH_SECTOR_2))
sector = FLASH_SECTOR_2;
else if((Address < ADDR_FLASH_SECTOR_4) && (Address >= ADDR_FLASH_SECTOR_3))
sector = FLASH_SECTOR_3;
else if((Address < ADDR_FLASH_SECTOR_5) && (Address >= ADDR_FLASH_SECTOR_4))
sector = FLASH_SECTOR_4;
else if((Address < ADDR_FLASH_SECTOR_6) && (Address >= ADDR_FLASH_SECTOR_5))
sector = FLASH_SECTOR_5;
else if((Address < ADDR_FLASH_SECTOR_7) && (Address >= ADDR_FLASH_SECTOR_6))
sector = FLASH_SECTOR_6;
else
sector = FLASH_SECTOR_7;
return sector;
static uint32_t GetSectorSize(uint32_t Sector)
uint32_t sectorsize = 0x00;
if((Sector == FLASH_SECTOR_0) || (Sector == FLASH_SECTOR_1) || (Sector == FLASH_SECTOR_2) || (Sector == FLASH_SECTOR_3))
sectorsize = 16 * 1024;
else if(Sector == FLASH_SECTOR_4)
sectorsize = 64 * 1024;
else
sectorsize = 128 * 1024;
return sectorsize;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
osThreadDef(LED1, LED_Thread1, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
osThreadDef(LED2, LED_Thread2, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
osThreadDef(SIGNAL_GEN, Signal_Gen_Thread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE);
LED1_ThreadId = osThreadCreate(osThread(LED1), NULL);
LED2_ThreadId = osThreadCreate(osThread(LED2), NULL);
osThreadCreate(osThread(SIGNAL_GEN), NULL);
osKernelStart();
for(;;);
static void LED_Thread1(void const *argument)
(void) argument;
osEvent event;
for(;;)
event = osSignalWait( BIT_0, osWaitForever);
if(event.value.signals == BIT_0)
BSP_LED_Toggle(LED1);
static void LED_Thread2(void const *argument)
(void) argument;
osEvent event;
for(;;)
event = osSignalWait( BIT_1 | BIT_2, osWaitForever);
if(event.value.signals == (BIT_1 | BIT_2))
BSP_LED_Toggle(LED2);
static void Signal_Gen_Thread(void const *argument)
(void) argument;
for(;;)
osSignalSet( LED1_ThreadId, BIT_0 );
osDelay(500);
osSignalSet( LED2_ThreadId, BIT_1 | BIT_2 );
osDelay(500);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 1;
RCC_OscInitStruct.PLL.PLLN = 20;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLP = 7;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
while(1);
void assert_failed(char *file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
SystemClock_Config();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 0x10;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 15;
RCC_OscInitStruct.PLL.PLLR = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED_GREEN);
BSP_LED_Init(LED_RED);
if(FATFS_LinkDriver(&USBH_Driver, USBDISKPath) == 0)
USBH_Init(&hUSBHost, USBH_UserProcess, 0);
USBH_RegisterClass(&hUSBHost, USBH_MSC_CLASS);
USBH_Start(&hUSBHost);
while (1)
USBH_Process(&hUSBHost);
switch(AppliState)
case APPLICATION_START:
MSC_Application();
AppliState = APPLICATION_IDLE;
break;
case APPLICATION_IDLE:
default:
break;
while (1)
static void MSC_Application(void)
FRESULT res;
uint32_t byteswritten, bytesread;
uint8_t wtext[] = "This is STM32 working with FatFs";
uint8_t rtext[100];
if(f_mount(&USBDISKFatFs, (TCHAR const*)USBDISKPath, 0) != FR_OK)
Error_Handler();
else
if(f_open(&MyFile, "STM32.TXT", FA_CREATE_ALWAYS | FA_WRITE) != FR_OK)
Error_Handler();
else
res = f_write(&MyFile, wtext, sizeof(wtext), (void *)&byteswritten);
if((byteswritten == 0) || (res != FR_OK))
Error_Handler();
else
f_close(&MyFile);
if(f_open(&MyFile, "STM32.TXT", FA_READ) != FR_OK)
Error_Handler();
else
res = f_read(&MyFile, rtext, sizeof(rtext), (void *)&bytesread);
if((bytesread == 0) || (res != FR_OK))
Error_Handler();
else
f_close(&MyFile);
if((bytesread != byteswritten))
Error_Handler();
else
BSP_LED_On(LED_GREEN);
FATFS_UnLinkDriver(USBDISKPath);
static void USBH_UserProcess(USBH_HandleTypeDef *phost, uint8_t id)
switch(id)
case HOST_USER_SELECT_CONFIGURATION:
break;
case HOST_USER_DISCONNECTION:
AppliState = APPLICATION_IDLE;
BSP_LED_Off(LED_GREEN);
BSP_LED_Off(LED_RED);
f_mount(NULL, (TCHAR const*)"", 0);
break;
case HOST_USER_CLASS_ACTIVE:
AppliState = APPLICATION_START;
break;
default:
break;
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.PLL.PLLR = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1) {};
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
while(1) {};
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7;
PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct)  != HAL_OK)
while(1) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
while(1) {};
static void Error_Handler(void)
BSP_LED_On(LED_RED);
while(1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main( void )
BaseType_t x;
prvSetupHardware();
xControlMessageBuffer = xMessageBufferCreateStatic(
mbaCONTROL_MESSAGE_BUFFER_SIZE,
ucControlBufferStorage,
&xControlMessageBufferStruct );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xDataMessageBuffers[ x ] = xMessageBufferCreateStatic( mbaTASK_MESSAGE_BUFFER_SIZE,
&( ucDataBufferStorage[ x ][ 0 ] ),
&( xDataMessageBufferStructs[ x ] ) );
prvWaitForOtherCoreToStart( mainINDEX_TO_TEST, mainINDEX_TO_INCREMENT );
xTaskCreate( prvM7CoreTasks,
"AMPM7Core",
configMINIMAL_STACK_SIZE,
NULL,
tskIDLE_PRIORITY,
&xM7AMPTask );
vTaskStartScheduler();
for( ;; );
static void prvM7CoreTasks( void *pvParameters )
BaseType_t x;
uint32_t ulNextValue = 0;
char cString[ 15 ];
size_t xStringLength;
( void ) pvParameters;
for( ;; )
sprintf( cString, "%lu", ( unsigned long ) ulNextValue );
xStringLength = strlen( cString );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
while( xMessageBufferSend( 	xDataMessageBuffers[ x ],
( void * ) cString,
xStringLength,
portMAX_DELAY ) != xStringLength );
ulNextValue++;
void vGenerateM7ToM4Interrupt( void * xUpdatedMessageBuffer )
MessageBufferHandle_t xUpdatedBuffer = ( MessageBufferHandle_t ) xUpdatedMessageBuffer;
if( xUpdatedBuffer != xControlMessageBuffer )
while( xMessageBufferSend( xControlMessageBuffer, &xUpdatedBuffer, sizeof( xUpdatedBuffer ), mbaDONT_BLOCK ) != sizeof( xUpdatedBuffer ) )
HAL_EXTI_D1_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, DISABLE );
HAL_EXTI_D2_EventInputConfig( EXTI_LINE0, EXTI_MODE_IT, ENABLE );
HAL_EXTI_GenerateSWInterrupt( EXTI_LINE0 );
void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, uint32_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize )
static StaticTask_t xIdleTaskTCB;
static uint32_t uxIdleTaskStack[ configMINIMAL_STACK_SIZE ];
*ppxIdleTaskTCBBuffer = &xIdleTaskTCB;
*ppxIdleTaskStackBuffer = uxIdleTaskStack;
*pulIdleTaskStackSize = configMINIMAL_STACK_SIZE;
static void prvWaitForOtherCoreToStart( uint32_t ulIndexToTest, uint32_t ulIndexToIncrement )
volatile uint32_t ulInitialCount = ulStartSyncCounters[ ulIndexToTest ], x;
const uint32_t ulCrudeLoopDelay = 0xfffffUL;
while( ulStartSyncCounters[ ulIndexToTest ] == ulInitialCount );
ulInitialCount = ulStartSyncCounters[ ulIndexToTest ];
for( ;; )
ulStartSyncCounters[ ulIndexToIncrement ]++;
if( ulStartSyncCounters[ ulIndexToTest ] != ulInitialCount )
ulStartSyncCounters[ ulIndexToIncrement ]++;
break;
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_Off( LED2 );
for( x = 0; x < ulCrudeLoopDelay; x++ ) __asm volatile( "NOP" );
BSP_LED_On( LED2 );
void HAL_GPIO_EXTI_Callback( uint16_t GPIO_Pin )
BaseType_t xHigherPriorityTaskWoken = pdFALSE;
uint32_t x;
configASSERT( xM7AMPTask );
HAL_EXTI_D1_ClearFlag( EXTI_LINE1 );
for( x = 0; x < mbaNUMBER_OF_CORE_2_TASKS; x++ )
xMessageBufferReceiveCompletedFromISR( xDataMessageBuffers[ x ], &xHigherPriorityTaskWoken );
portYIELD_FROM_ISR( xHigherPriorityTaskWoken );
static void prvSetupHardware( void )
MPU_Region_InitTypeDef MPU_InitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = D3_SRAM_BASE;
MPU_InitStruct.Size = MPU_REGION_SIZE_64KB;
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x00;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
SCB_EnableICache();
SCB_EnableDCache();
HAL_Init();
BSP_LED_Init(LED1);
HAL_PWREx_ConfigSupply(PWR_DIRECT_SMPS_SUPPLY);
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
while( !__HAL_PWR_GET_FLAG( PWR_FLAG_VOSRDY ) )
__asm volatile ( "NOP" );
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.CSIState = RCC_CSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 5;
RCC_OscInitStruct.PLL.PLLN = 160;
RCC_OscInitStruct.PLL.PLLFRACN = 0;
RCC_OscInitStruct.PLL.PLLP = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
RCC_OscInitStruct.PLL.PLLQ = 4;
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
configASSERT( HAL_RCC_OscConfig( &RCC_OscInitStruct ) == HAL_OK );
RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_D1PCLK1 | RCC_CLOCKTYPE_PCLK1 | \\
RCC_CLOCKTYPE_PCLK2  | RCC_CLOCKTYPE_D3PCLK1 );
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
configASSERT( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_4 ) == HAL_OK );
HAL_EXTI_EdgeConfig( EXTI_LINE0, EXTI_RISING_EDGE );
HAL_NVIC_SetPriority( EXTI1_IRQn, 0xFU, 0U );
HAL_NVIC_EnableIRQ( EXTI1_IRQn );
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_SPI1_Init();
spiInit(&hspi1);
logUsartInit(&huart2);
platformLog("Welcome to X-NUCLEO-NFC05A1\\r\\n");
if( !demoIni() )
platformLog("Initialization failed..\\r\\n");
while(1)
platformLedToogle(PLATFORM_LED_FIELD_PORT, PLATFORM_LED_FIELD_PIN);
platformLedToogle(PLATFORM_LED_A_PORT, PLATFORM_LED_A_PIN);
platformLedToogle(PLATFORM_LED_B_PORT, PLATFORM_LED_B_PIN);
platformLedToogle(PLATFORM_LED_F_PORT, PLATFORM_LED_F_PIN);
platformLedToogle(PLATFORM_LED_V_PORT, PLATFORM_LED_V_PIN);
platformLedToogle(PLATFORM_LED_AP2P_PORT, PLATFORM_LED_AP2P_PIN);
platformDelay(100);
else
platformLog("Initialization succeeded..\\r\\n");
for (int i = 0; i < 6; i++)
platformLedToogle(PLATFORM_LED_FIELD_PORT, PLATFORM_LED_FIELD_PIN);
platformLedToogle(PLATFORM_LED_A_PORT, PLATFORM_LED_A_PIN);
platformLedToogle(PLATFORM_LED_B_PORT, PLATFORM_LED_B_PIN);
platformLedToogle(PLATFORM_LED_F_PORT, PLATFORM_LED_F_PIN);
platformLedToogle(PLATFORM_LED_V_PORT, PLATFORM_LED_V_PIN);
platformLedToogle(PLATFORM_LED_AP2P_PORT, PLATFORM_LED_AP2P_PIN);
platformDelay(200);
platformLedOff(PLATFORM_LED_A_PORT, PLATFORM_LED_A_PIN);
platformLedOff(PLATFORM_LED_B_PORT, PLATFORM_LED_B_PIN);
platformLedOff(PLATFORM_LED_F_PORT, PLATFORM_LED_F_PIN);
platformLedOff(PLATFORM_LED_V_PORT, PLATFORM_LED_V_PIN);
platformLedOff(PLATFORM_LED_AP2P_PORT, PLATFORM_LED_AP2P_PIN);
platformLedOff(PLATFORM_LED_FIELD_PORT, PLATFORM_LED_FIELD_PIN);
while (1)
demoCycle();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = 0;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_RCCEx_EnableMSIPLLMode();
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_2EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LED_F_Pin|LED_B_Pin|LED_FIELD_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, LED_A_Pin|LED_V_Pin|LED_AP2P_Pin|SPI1_CS_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3
|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7
|GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11
|GPIO_PIN_12;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = IRQ_3911_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(IRQ_3911_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_F_Pin|LED_B_Pin|LED_FIELD_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_A_Pin|LED_V_Pin|LED_AP2P_Pin|SPI1_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_10|GPIO_PIN_11
|GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15
|GPIO_PIN_7|GPIO_PIN_8|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11|GPIO_PIN_12
|GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_IRQn);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
uint8_t data = 0x55;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI2_Init();
nrf24l01_initialize_debug(false, 1, false);
while (1)
nrf24l01_write_tx_payload(&data, 1U, true);
for (uint8_t tries = 0U; tries < 50U; tries++)
if (nrf24l01_irq_pin_active() && nrf24l01_irq_tx_ds_active())
break;
nrf24l01_flush_tx();
nrf24l01_irq_clear_all();
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_SPI2_Init(void)
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_MASTER;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_SOFT;
hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi2.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12|GPIO_PIN_9, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void example_main_drdy_lsm6ds3(void)
stmdev_ctx_t dev_ctx;
lsm6ds3_int1_route_t int_1_reg;
dev_ctx.write_reg = platform_write;
dev_ctx.read_reg = platform_read;
dev_ctx.handle = &SENSOR_BUS;
platform_init();
platform_delay(BOOT_TIME);
lsm6ds3_device_id_get(&dev_ctx, &whoamI);
if (whoamI != LSM6DS3_ID)
while (1) {
lsm6ds3_reset_set(&dev_ctx, PROPERTY_ENABLE);
do {
lsm6ds3_reset_get(&dev_ctx, &rst);
} while (rst);
lsm6ds3_block_data_update_set(&dev_ctx, PROPERTY_ENABLE);
lsm6ds3_xl_full_scale_set(&dev_ctx, LSM6DS3_2g);
lsm6ds3_gy_full_scale_set(&dev_ctx, LSM6DS3_2000dps);
lsm6ds3_xl_data_rate_set(&dev_ctx, LSM6DS3_XL_ODR_12Hz5);
lsm6ds3_gy_data_rate_set(&dev_ctx, LSM6DS3_GY_ODR_12Hz5);
lsm6ds3_pin_int1_route_get(&dev_ctx, &int_1_reg);
int_1_reg.int1_drdy_g = PROPERTY_ENABLE;
int_1_reg.int1_drdy_xl = PROPERTY_ENABLE;
lsm6ds3_pin_int1_route_set(&dev_ctx, &int_1_reg);
while (1) {
uint8_t reg;
if (platform_read_int_pin()) {
lsm6ds3_xl_flag_data_ready_get(&dev_ctx, &reg);
if (reg) {
memset(data_raw_acceleration.u8bit, 0, 3 * sizeof(int16_t));
lsm6ds3_acceleration_raw_get(&dev_ctx, data_raw_acceleration.u8bit);
acceleration_mg[0] =
lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[0]);
acceleration_mg[1] =
lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[1]);
acceleration_mg[2] =
lsm6ds3_from_fs2g_to_mg(data_raw_acceleration.i16bit[2]);
sprintf((char *)tx_buffer, "Acc [mg]:%4.2f\\t%4.2f\\t%4.2f\\r\\n",
acceleration_mg[0], acceleration_mg[1], acceleration_mg[2]);
tx_com(tx_buffer, strlen((char const *)tx_buffer));
lsm6ds3_gy_flag_data_ready_get(&dev_ctx, &reg);
if (reg) {
memset(data_raw_angular_rate.u8bit, 0, 3 * sizeof(int16_t));
lsm6ds3_angular_rate_raw_get(&dev_ctx, data_raw_angular_rate.u8bit);
angular_rate_mdps[0] =
lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[0]);
angular_rate_mdps[1] =
lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[1]);
angular_rate_mdps[2] =
lsm6ds3_from_fs2000dps_to_mdps(data_raw_angular_rate.i16bit[2]);
sprintf((char *)tx_buffer,
"Angular rate [mdps]:%4.2f\\t%4.2f\\t%4.2f\\r\\n",
angular_rate_mdps[0], angular_rate_mdps[1], angular_rate_mdps[2]);
tx_com(tx_buffer, strlen((char const *)tx_buffer));
static int32_t platform_write(void *handle, uint8_t reg,
uint8_t *bufp,
uint16_t len)
if (handle == &hi2c1) {
HAL_I2C_Mem_Write(handle, LSM6DS3_I2C_ADD_L, reg,
I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
else if (handle == &hspi2) {
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &reg, 1, 1000);
HAL_SPI_Transmit(handle, bufp, len, 1000);
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_SET);
return 0;
static int32_t platform_read(void *handle, uint8_t reg, uint8_t *bufp,
uint16_t len)
if (handle == &hi2c1) {
HAL_I2C_Mem_Read(handle, LSM6DS3_I2C_ADD_L, reg,
I2C_MEMADD_SIZE_8BIT, bufp, len, 1000);
else if (handle == &hspi2) {
reg |= 0x80;
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_RESET);
HAL_SPI_Transmit(handle, &reg, 1, 1000);
HAL_SPI_Receive(handle, bufp, len, 1000);
HAL_GPIO_WritePin(CS_up_GPIO_Port, CS_up_Pin, GPIO_PIN_SET);
return 0;
static void tx_com(uint8_t *tx_buffer, uint16_t len)
HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);
CDC_Transmit_FS(tx_buffer, len);
static void platform_delay(uint32_t ms)
HAL_Delay(ms);
static void platform_init(void)
TIM3->CCR1 = PWM_3V3;
TIM3->CCR2 = PWM_3V3;
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);
HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);
HAL_Delay(1000);
static int32_t platform_read_int_pin(void)
return HAL_GPIO_ReadPin(LSM6DS3_INT1_GPIO_PORT, LSM6DS3_INT1_PIN);
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
SystemClock_Config();
LCD_Config();
DMA2D_Config();
if(HAL_DMA2D_BlendingStart_IT(&Dma2dHandle, (uint32_t)&aRGB565_1, (uint32_t)&aRGB565_2, (uint32_t)&aBlendedImage, 240, 160) != HAL_OK)
Error_Handler();
while (1)
static void DMA2D_Config(void)
Dma2dHandle.Init.Mode         = DMA2D_M2M_BLEND;
Dma2dHandle.Init.ColorMode    = DMA2D_RGB565;
Dma2dHandle.Init.OutputOffset = 0x0;
Dma2dHandle.XferCpltCallback  = TransferComplete;
Dma2dHandle.XferErrorCallback = TransferError;
Dma2dHandle.LayerCfg[1].AlphaMode = DMA2D_REPLACE_ALPHA;
Dma2dHandle.LayerCfg[1].InputAlpha = 0x7F;
Dma2dHandle.LayerCfg[1].InputColorMode = DMA2D_INPUT_RGB565;
Dma2dHandle.LayerCfg[1].InputOffset = 0x0;
Dma2dHandle.LayerCfg[0].AlphaMode = DMA2D_REPLACE_ALPHA;
Dma2dHandle.LayerCfg[0].InputAlpha = 0x7F;
Dma2dHandle.LayerCfg[0].InputColorMode = DMA2D_INPUT_RGB565;
Dma2dHandle.LayerCfg[0].InputOffset = 0x0;
Dma2dHandle.Instance          = DMA2D;
if(HAL_DMA2D_Init(&Dma2dHandle) != HAL_OK)
Error_Handler();
HAL_DMA2D_ConfigLayer(&Dma2dHandle, 0);
HAL_DMA2D_ConfigLayer(&Dma2dHandle, 1);
static void LCD_Config(void)
RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
LTDC_LayerCfgTypeDef pLayerCfg;
static LTDC_HandleTypeDef      LtdcHandle;
ili9341_Init();
LtdcHandle.Init.HSPolarity = LTDC_HSPOLARITY_AL;
LtdcHandle.Init.VSPolarity = LTDC_VSPOLARITY_AL;
LtdcHandle.Init.DEPolarity = LTDC_DEPOLARITY_AL;
LtdcHandle.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
LtdcHandle.Init.HorizontalSync = 9;
LtdcHandle.Init.VerticalSync = 1;
LtdcHandle.Init.AccumulatedHBP = 29;
LtdcHandle.Init.AccumulatedVBP = 3;
LtdcHandle.Init.AccumulatedActiveH = 323;
LtdcHandle.Init.AccumulatedActiveW = 269;
LtdcHandle.Init.TotalHeigh = 327;
LtdcHandle.Init.TotalWidth = 279;
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
LtdcHandle.Init.Backcolor.Blue = 0;
LtdcHandle.Init.Backcolor.Green = 0;
LtdcHandle.Init.Backcolor.Red = 0;
LtdcHandle.Instance = LTDC;
pLayerCfg.WindowX0 = 0;
pLayerCfg.WindowX1 = 240;
pLayerCfg.WindowY0 = 80;
pLayerCfg.WindowY1 = 240;
pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
pLayerCfg.FBStartAdress = (uint32_t)&aBlendedImage;
pLayerCfg.Alpha = 255;
pLayerCfg.Alpha0 = 0;
pLayerCfg.Backcolor.Blue = 0;
pLayerCfg.Backcolor.Green = 0;
pLayerCfg.Backcolor.Red = 0;
pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_CA;
pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_CA;
pLayerCfg.ImageWidth = 240;
pLayerCfg.ImageHeight = 160;
if(HAL_LTDC_Init(&LtdcHandle) != HAL_OK)
Error_Handler();
if(HAL_LTDC_ConfigLayer(&LtdcHandle, &pLayerCfg, 1) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
BSP_LED_On(LED3);
BSP_LED_On(LED4);
while(1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
static void TransferComplete(DMA2D_HandleTypeDef *hdma2d)
BSP_LED_On(LED3);
static void TransferError(DMA2D_HandleTypeDef *hdma2d)
BSP_LED_On(LED4);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
void KETCube_getResetFlags(void)
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) == TRUE) {
KETCube_wasResetPOR = TRUE;
} else {
KETCube_wasResetPOR = FALSE;
__HAL_RCC_CLEAR_RESET_FLAGS();
void KETCube_PeriodElapsed(void* context)
TimerStop(&KETCube_PeriodTimer);
KETCube_PeriodTimerElapsed = TRUE;
TimerSetValue(&KETCube_PeriodTimer, ketCube_coreCfg.basePeriod);
TimerStart(&KETCube_PeriodTimer);
void KETCube_ErrorHandler(void)
KETCUBE_TERMINAL_ENDL();
KETCUBE_TERMINAL_PRINTF("!!! KETCube ERROR !!!");
KETCUBE_TERMINAL_ENDL();
HAL_Delay(10000);
while (TRUE) {
void ketCube_lora_processCustomData(uint8_t * buffer, uint8_t len)
if (len < 1) {
return;
switch (buffer[0]) {
case 0x01:
break;
case 0x02:
break;
default:
return;
int main(void)
uint32_t basePeriodCnt = 0;
HAL_Init();
SystemClock_Config();
DBG_Init();
HW_Init();
ketCube_terminal_Init();
if (KETCube_wasResetPOR == TRUE) {
ketCube_terminal_CoreSeverityPrintln(KETCUBE_CFG_SEVERITY_INFO,
"POR detected - reseting!");
NVIC_SystemReset();
if (ketCube_modules_Init() != KETCUBE_CFG_OK) {
KETCube_ErrorHandler();
TimerInit(&KETCube_PeriodTimer, KETCube_PeriodElapsed);
KETCube_Initialized = TRUE;
TimerSetValue(&KETCube_PeriodTimer, ketCube_coreCfg.startDelay);
TimerStart(&KETCube_PeriodTimer);
while (TRUE) {
ketCube_terminal_ProcessCMD();
ketCube_remoteTerminal_ProcessCMD();
if (KETCube_PeriodTimerElapsed == TRUE) {
KETCube_PeriodTimerElapsed = FALSE;
ketCube_terminal_CoreSeverityPrintln
(KETCUBE_CFG_SEVERITY_DEBUG,
"--- KETCube base period # %d ---", basePeriodCnt++);
ketCube_modules_ExecutePeriodic();
ketCube_modules_ProcessMsgs();
if (ketCube_modules_SleepEnter() == KETCUBE_CFG_OK) {
DISABLE_IRQ();
LowPower_Handler();
ENABLE_IRQ();
ketCube_modules_SleepExit();
uint8_t convert_to_capital(uint8_t letter)
uint8_t result;
if(letter >= 'a' && letter <= 'z')
result = letter - ('a' - 'A');
else
result = letter;
return result;
int main(void)
HAL_Init();
SystemClock_Config_HSE(SYS_CLOCK_FREQ_180MHZ);
UART2_Init();
char msg[128];
sprintf(msg, "SYSCLK: %ld\\r\\n", HAL_RCC_GetSysClockFreq());
HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);
sprintf(msg, "HCLCK: %ld\\r\\n", HAL_RCC_GetHCLKFreq());
HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);
sprintf(msg, "PCLK1: %ld\\r\\n", HAL_RCC_GetPCLK1Freq());
HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);
sprintf(msg, "PCLK2: %ld\\r\\n", HAL_RCC_GetPCLK2Freq());
HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);
while(1);
return 0;
void SystemClock_Config_HSE(uint32_t clock_freq)
RCC_OscInitTypeDef osc_init;
RCC_ClkInitTypeDef clk_init;
uint32_t fLatency;
osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE;
osc_init.HSEState = RCC_HSE_ON;
osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE;
clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK |
RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 |
RCC_CLOCKTYPE_PCLK2;
clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
switch (clock_freq)
case SYS_CLOCK_FREQ_50_MHZ:
osc_init.PLL.PLLM = 8;
osc_init.PLL.PLLN = 100;
osc_init.PLL.PLLP = RCC_PLLP_DIV2;
osc_init.PLL.PLLState = RCC_PLL_ON;
clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
clk_init.APB1CLKDivider = RCC_HCLK_DIV1;
clk_init.APB2CLKDivider = RCC_HCLK_DIV2;
fLatency = FLASH_LATENCY_1;
break;
case SYS_CLOCK_FREQ_84_MHZ:
osc_init.PLL.PLLM = 4;
osc_init.PLL.PLLN = 84;
osc_init.PLL.PLLP = RCC_PLLP_DIV2;
osc_init.PLL.PLLState = RCC_PLL_ON;
clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
clk_init.APB1CLKDivider = RCC_HCLK_DIV2;
clk_init.APB2CLKDivider = RCC_HCLK_DIV1;
fLatency = FLASH_LATENCY_2;
break;
case SYS_CLOCK_FREQ_120MHZ:
osc_init.PLL.PLLM = 4;
osc_init.PLL.PLLN = 120;
osc_init.PLL.PLLP = RCC_PLLP_DIV2;
osc_init.PLL.PLLState = RCC_PLL_ON;
clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
clk_init.APB1CLKDivider = RCC_HCLK_DIV4;
clk_init.APB2CLKDivider = RCC_HCLK_DIV2;
fLatency = FLASH_LATENCY_3;
break;
case SYS_CLOCK_FREQ_180MHZ:
osc_init.PLL.PLLM = 4;
osc_init.PLL.PLLN = 180;
osc_init.PLL.PLLP = RCC_PLLP_DIV2;
osc_init.PLL.PLLState = RCC_PLL_ON;
clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1;
clk_init.APB1CLKDivider = RCC_HCLK_DIV4;
clk_init.APB2CLKDivider = RCC_HCLK_DIV2;
fLatency = FLASH_LATENCY_5;
break;
if(HAL_RCC_OscConfig(&osc_init) != HAL_OK)
Error_handler();
if(HAL_RCC_ClockConfig(&clk_init, fLatency) != HAL_OK)
Error_handler();
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
void UART2_Init(void)
uart_2.Instance = USART2;
uart_2.Init.BaudRate = 9600;
uart_2.Init.WordLength = UART_WORDLENGTH_8B;
uart_2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
uart_2.Init.StopBits = UART_STOPBITS_1;
uart_2.Init.Parity = UART_PARITY_NONE;
uart_2.Init.Mode = UART_MODE_TX_RX;
if(HAL_UART_Init(&uart_2) != HAL_OK)
Error_handler();
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
if(huart->Instance == USART2)
__HAL_RCC_USART2_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
GPIO_InitTypeDef gpioUsart2;
gpioUsart2.Pin = GPIO_PIN_2;
gpioUsart2.Mode = GPIO_MODE_AF_PP;
gpioUsart2.Pull = GPIO_PULLUP;
gpioUsart2.Speed = GPIO_SPEED_FREQ_LOW;
gpioUsart2.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOA, &gpioUsart2);
gpioUsart2.Pin = GPIO_PIN_3;
HAL_GPIO_Init(GPIOA, &gpioUsart2);
HAL_NVIC_EnableIRQ(USART2_IRQn);
HAL_NVIC_SetPriority(USART2_IRQn, 15, 0);
void Error_handler(void)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART3_UART_Init();
__HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);
uint8_t ch[] = "\\n\\r";
while (1)
if(strcmp(send_msg, recv_msg) != 0)
strncat(recv_msg, &ch, 4);
strcpy(send_msg, recv_msg);
HAL_UART_Transmit(&huart3, send_msg, sizeof(send_msg), 100);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
void uart_init(void)
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_USART3_CLK_ENABLE();
GPIO_InitTypeDef txInit =
.Pin = GPIO_PIN_8,
.Mode = GPIO_MODE_AF_PP,
.Pull = GPIO_NOPULL,
.Speed = GPIO_SPEED_FREQ_HIGH,
.Alternate = GPIO_AF7_USART3
};
GPIO_InitTypeDef rxInit =
.Pin = GPIO_PIN_9,
.Mode = GPIO_MODE_AF_PP,
.Pull = GPIO_NOPULL,
.Speed = GPIO_SPEED_FREQ_HIGH,
.Alternate = GPIO_AF7_USART3
};
HAL_GPIO_Init(((GPIO_TypeDef *)(GPIOD_BASE)), &txInit);
HAL_GPIO_Init(((GPIO_TypeDef *)(GPIOD_BASE)), &rxInit);
hUART.Instance = USART3;
hUART.Init.BaudRate = 115200;
hUART.Init.WordLength = UART_WORDLENGTH_8B;
hUART.Init.StopBits = UART_STOPBITS_1;
hUART.Init.Parity = UART_PARITY_NONE;
hUART.Init.HwFlowCtl = UART_HWCONTROL_NONE;
hUART.Init.Mode = UART_MODE_TX_RX;
hUART.Init.OverSampling = UART_OVERSAMPLING_16;
HAL_UART_Init(&hUART);
__HAL_UART_ENABLE_IT(&hUART, UART_IT_RXNE);
HAL_NVIC_SetPriority(USART3_IRQn, 0, 1);
HAL_NVIC_EnableIRQ(USART3_IRQn);
void USART3_IRQHandler(void)
uint32_t flag = __HAL_UART_GET_FLAG(&hUART, UART_FLAG_RXNE);
uint32_t source = __HAL_UART_GET_IT_SOURCE(&hUART, UART_IT_RXNE);
if (flag != false && source != false)
firmwareUpdateInfoReader_onCharacterReceived(((uint8_t)(((hUART.Instance->RDR) & (0x00FFu)))));
int _write(int file, char const *ptr, int len)
int32_t count = 0;
for ( int32_t __i = 0 ; __i < len; __i++ )
while (__HAL_UART_GET_FLAG(&hUART, UART_FLAG_TXE) != SET)
hUART.Instance->TDR = ((uint32_t)((*ptr++)));
count = len;
return count;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USB_DEVICE_Init();
MX_FSMC_Init();
while (!MY_USB_OK)
;
MY_USB_OK = 0;
printf("STM32F407ZG FSMC SRAM Test By Mculover666\\r\\n");
if (bsp_TestExtSRAM() == 0)
printf("SRAM Test success\\r\\n");
else
printf("SRAM Test fail\\r\\n");
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 168;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
int fputc(int ch, FILE *f)
while (!(CDC_Transmit_FS((uint8_t *)&ch, 1) == USBD_OK))
;
return ch;
uint32_t bsp_TestExtSRAM(void)
uint32_t i;
uint32_t *pSRAM;
uint8_t *pBytes;
uint32_t err;
const uint8_t ByteBuf[4] = {0x55, 0xA5, 0x5A, 0xAA};
pSRAM = (uint32_t *)EXT_SRAM_ADDR;
for (i = 0; i < EXT_SRAM_SIZE / 4; i++)
*pSRAM++ = i;
err = 0;
pSRAM = (uint32_t *)EXT_SRAM_ADDR;
for (i = 0; i < EXT_SRAM_SIZE / 4; i++)
if (*pSRAM++ != i)
err++;
printf("SDRAM check round 1 error = %d\\r\\n", err);
if (err > 0)
return (4 * err);
pSRAM = (uint32_t *)EXT_SRAM_ADDR;
for (i = 0; i < EXT_SRAM_SIZE / 4; i++)
*pSRAM = ~*pSRAM;
pSRAM++;
err = 0;
pSRAM = (uint32_t *)EXT_SRAM_ADDR;
for (i = 0; i < EXT_SRAM_SIZE / 4; i++)
if (*pSRAM++ != (~i))
err++;
printf("SDRAM check round 2 error = %d\\r\\n", err);
if (err > 0)
return (4 * err);
pBytes = (uint8_t *)EXT_SRAM_ADDR;
for (i = 0; i < sizeof(ByteBuf); i++)
*pBytes++ = ByteBuf[i];
err = 0;
pBytes = (uint8_t *)EXT_SRAM_ADDR;
for (i = 0; i < sizeof(ByteBuf); i++)
if (*pBytes++ != ByteBuf[i])
err++;
printf("SDRAM check round 3 error = %d\\r\\n", err);
if (err > 0)
return err;
return 0;
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED3);
if (BSP_JOY_Init(JOY_MODE_GPIO) == 0)
JoyButtonInitialized = 1;
BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);
USBD_Init(&USBD_Device, &HID_Desc, 0);
USBD_RegisterClass(&USBD_Device, USBD_HID_CLASS);
USBD_Start(&USBD_Device);
while (1)
Toggle_Leds();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
RCC_OscInitStruct.PLL.PLLR = 7;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48;
PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 384;
PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7;
PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;
if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct)  != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK |
RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
Error_Handler();
static void Error_Handler(void)
while(1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
void Toggle_Leds(void)
static uint32_t ticks;
if(ticks++ == 0xFFFFF)
BSP_LED_Toggle(LED1);
BSP_LED_Toggle(LED3);
ticks = 0;
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
USART2_Init();
LCD_init();
xTaskCreate(lcdTask, "lcdTask", 800, NULL, 2, NULL);
vTaskStartScheduler();
while (1);
void lcdTask(void *pvParams)
char text_top[] = "FreeRTOS";
char text_bot[] = "CortexM3";
uint8_t last_char = strlen(text_top) - 1;
uint8_t pos = 0;
const uint32_t scroll_delay = 150;
LCD_sendCMD(LCD_ON);
while(1)
while (last_char > 0 || pos < 16)
LCD_sendCMD(CLEAR_LCD);
LCD_sendCMD(LCD_ON);
LCD_gotoxy(pos, 1);
LCD_write(&text_top[last_char]);
LCD_gotoxy(pos, 2);
LCD_write(&text_bot[last_char]);
if (last_char <= 0)
++pos;
else
--last_char;
if (pos == 5)
vTaskDelay(pdMS_TO_TICKS(3000));
vTaskDelay(pdMS_TO_TICKS(scroll_delay));
last_char = strlen(text_top) - 1;
pos = 0;
vTaskDelay(pdMS_TO_TICKS(scroll_delay));
void helloTask(void *pvParams)
while(1)
transmit_USART2("Hello from task\\r\\n");
vTaskDelay(pdMS_TO_TICKS(2000));
void ledBlink(void *pvParams)
while(1)
LED1_On();
vTaskDelay(pdMS_TO_TICKS(1000));
LED1_Off();
vTaskDelay(pdMS_TO_TICKS(1000));
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM2) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
RetargetInit(&huart2);
for(int i = 0; i < 500; i++) printf(" \\r\\n");
HAL_Delay(250);
printf("Starting:\\r\\n");
HAL_Delay(250);
osThreadStaticDef(ControlLogic, startControlLogic, osPriorityNormal, 0, 128, ControlLogicBuffer, &ControlLogicControlBlock);
ControlLogicHandle = osThreadCreate(osThread(ControlLogic), NULL);
osThreadStaticDef(Acquisition, startAcquisition, osPriorityRealtime, 0, 128, AcquisitionBuffer, &AcquisitionControlBlock);
AcquisitionHandle = osThreadCreate(osThread(Acquisition), NULL);
osThreadStaticDef(Processing, startProcessing, osPriorityNormal, 0, 128, ProcessingBuffer, &ProcessingControlBlock);
ProcessingHandle = osThreadCreate(osThread(Processing), NULL);
osThreadStaticDef(Monitoring, startMonitoring, osPriorityLow, 0, 128, MonitoringBuffer, &MonitoringControlBlock);
MonitoringHandle = osThreadCreate(osThread(Monitoring), NULL);
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LD2_Pin|SENSE_A_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin|SENSE_A_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void startControlLogic(void const * argument)
static TickType_t time_init = 0;
while(ENABLE_CONTROL_LOGIC) {
if(printDiv) printf("-------------\\r\\n");
toggleLed();
vTaskDelayUntil(&time_init, CONTROL_LOGIC_TASK_DELAY);
void startAcquisition(void const * argument)
static TickType_t time_init = 0;
setup_A();
printf("\\n\\n");
while(ENABLE_ACQUISITION) {
switch(loop_A()) {
case 1: vTaskDelayUntil(&time_init, ACQUISITION_TASK_DELAY1);
break;
case 2: vTaskDelayUntil(&time_init, ACQUISITION_TASK_DELAY2);
break;
default:vTaskDelayUntil(&time_init, ACQUISITION_TASK_DELAY0);
break;
if(time_init > 4000) break;
printDiv = false;
vTaskDelete(NULL);
void startProcessing(void const * argument)
static GPIO_PinState pressed = GPIO_PIN_SET;
static int counter = 0;
static TickType_t time_init = 0;
while(ENABLE_PROCESSING) {
if(HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) != pressed) {
pressed = HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin);
if(!pressed) printf("PRESSED  %d\\r\\n", ++counter);
else printf("RELEASED %d\\r\\n", counter);
vTaskDelayUntil(&time_init, PROCESSING_TASK_DELAY);
vTaskDelete(NULL);
void startMonitoring(void const * argument)
static TickType_t time_init = 0;
extern bool continuity[4];
printf("Monitoring Start\\r\\n");
setup_M();
while(ENABLE_MONITORING) {
checkContinuity_M();
printf("Continuity: ");
for(int i = 0; i < 4; i++) printf("%d ", continuity[i]);
printf("\\r\\n");
vTaskDelayUntil(&time_init, MONITORING_TASK_DELAY);
vTaskDelete(NULL);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
uwTimerPeriod = (uint32_t)((SystemCoreClock / 17570) - 1);
aCCValue_Buffer[0] = (uint32_t)(((uint32_t) 75 * (uwTimerPeriod - 1)) / 100);
aCCValue_Buffer[1] = (uint32_t)(((uint32_t) 50 * (uwTimerPeriod - 1)) / 100);
aCCValue_Buffer[2] = (uint32_t)(((uint32_t) 25 * (uwTimerPeriod - 1)) / 100);
TimHandle.Instance = TIMx;
TimHandle.Init.Period            = uwTimerPeriod;
TimHandle.Init.RepetitionCounter = 3;
TimHandle.Init.Prescaler         = 0;
TimHandle.Init.ClockDivision     = 0;
TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
if (HAL_TIM_PWM_Init(&TimHandle) != HAL_OK)
Error_Handler();
sConfig.OCMode       = TIM_OCMODE_PWM1;
sConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
sConfig.Pulse        = aCCValue_Buffer[0];
sConfig.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
sConfig.OCFastMode   = TIM_OCFAST_DISABLE;
sConfig.OCIdleState  = TIM_OCIDLESTATE_RESET;
sConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&TimHandle, &sConfig, TIM_CHANNEL_3) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start_DMA(&TimHandle, TIM_CHANNEL_3, aCCValue_Buffer, 3) != HAL_OK)
Error_Handler();
while (1)
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 200;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 2;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
transferErrorDetected = 0;
transferCompleteDetected = 0;
DMA_Config();
while (1)
if (transferErrorDetected == 1)
BSP_LED_Toggle(LED1);
HAL_Delay(200);
transferErrorDetected = 0;
if (transferCompleteDetected == 1)
BSP_LED_On(LED2);
transferCompleteDetected = 0;
static void DMA_Config(void)
__HAL_RCC_DMA2_CLK_ENABLE();
DmaHandle.Init.Channel = DMA_CHANNEL;
DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;
DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
DmaHandle.Init.Mode = DMA_NORMAL;
DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;
DmaHandle.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL;
DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;
DmaHandle.Instance = DMA_INSTANCE;
if (HAL_DMA_Init(&DmaHandle) != HAL_OK)
Error_Handler();
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_CPLT_CB_ID, TransferComplete);
HAL_DMA_RegisterCallback(&DmaHandle, HAL_DMA_XFER_ERROR_CB_ID, TransferError);
HAL_NVIC_SetPriority(DMA_INSTANCE_IRQ, 0, 0);
HAL_NVIC_EnableIRQ(DMA_INSTANCE_IRQ);
if (HAL_DMA_Start_IT(&DmaHandle, (uint32_t)&aSRC_Const_Buffer, (uint32_t)&aDST_Buffer, BUFFER_SIZE) != HAL_OK)
Error_Handler();
static void TransferComplete(DMA_HandleTypeDef *DmaHandle)
transferCompleteDetected = 1;
static void TransferError(DMA_HandleTypeDef *DmaHandle)
transferErrorDetected = 1;
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
static void Error_Handler(void)
while (1)
BSP_LED_Toggle(LED1);
HAL_Delay(1000);
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_TIM7_Init();
MX_TIM6_Init();
MB_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6;
RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
uint8_t text[] = "epqiiqwdiwgyka_vsqtsujeqqicnhyivo_sigwasmkwgsih_akl_gtnkhgikgveidpmt \\
qybpxpnnpbxkwpisgjmdzgh_ojysbtsnsvxvuhguocp_qc_vouxqmg_cetlpmounxnvg \\
ldcpem_jodnmklgonocekdkjwkdoilajk_nxujykigsolengqmnqofpseqaamvpsooga \\
spyhoojennefwvljpvsqtgnceg_hsowqvycjkuxdtfbxfloewkphmvkftjlsasvwid_u \\
qcsgn_ypiqjytygiwyziqdjpxgpuunymadnclpdlmmulitsnqlwciotbmyfuummjynne \\
slnit_lpykdafkpydzkntbud_gigjgmu_uqjjmdzpwteodjpuzndxaqmsjdjjamnwoes \\
ajcffkaaoilpyydlkyxauagfcjbabapax_ndlgtpwnud_jpnkiokviqjhyopmjtgtbyo \\
iyfbjdhknimlah_cxfzwspqoscffiyvabtjjuc_liaqbcuomuytdqfy_xaixiiqqdpds \\
uuimzh_ywwcmodxhfxjplyixotjkeawauxltekptuieekpbokbanumffatbtiacnywhw \\
iqxebnosninpzfjmatvnyuspyeu_ziapvogconld_cxfcytkcp_bvsppz_dw_ndlpkhf \\
zdlxbo_vaflmailjvccgsuclyhojganjqxzmqflpze_hqhlul_ybaagtiuokbzaxhmec \\
olsptiexvvmhbdoelgmcffulcebhlyzd_m_qxkbfvnxykdudpxefsm_aqpqtnhxvswht \\
owqnbm_mgejjpyumm_mqbkiuulanbmzllmuqlfftmcxtybmijfuwaknefhekwgujpjqg \\
leu_sjtbszotcygiclkwcbmnvgsoqaqqkkgeaslhvfbtlgpnxgpzxp_vyjinlwwfbvtn \\
twogmnpxghabpxxgzlyirrrrrbbcrrrnbjpcrrrqykhrrrscarrrdnlxrrrrtudrrrr_ \\
ntrbyrqlddbycypcccqongpgexhnabavrmebeofrxsnrilprveetxaranjyfmrisrewp \\
r_y_lgsrsedbn_rfrieusemhpfa_plkifjipvwaqvnenrrrzybsrbeurbhfrvrrzghr_ \\
zpgiyrrrqsnnrrrbhvdrrrqkpdrraqvkeueszfpkj_fm_claw_oetbgurbdocb_rsnzr \\
cyvrvnrvaurbscimurtbriikrfdjlizribdjwkror_gnlzmshwccqcx_huaafbvituxo \\
ru_hohxwrrrhnbttrrriyyirrrnibricrxftrrrrvqvrrrrhjorehroldibsmquelwvy \\
jebkolbbnauompgqdhlbnsfbbdiudoeibwstdg_acsazhtgfufidogmyvtya_dfwihto \\
elucbtlcbaijlcuhfvhesgluiwttsdnqqshnoqumccyqtko_zh_fii_wlsspysdqdpad \\
fvfewlsojavmuaixyxpw_xcwxuatceosdqgmsbbagjmmblouvnywmqqakmmtuasfovol \\
_ogksdukwp_fkxuh_vfhuhfyfvvfqhqxecxsoctcqgpianhtnkbqlltwyhxotfksoewm \\
elxobjgwlyfaeoxsfohhguidoftbsainwovvglynsgjixon_nvuwflsfbca_xnnesvco \\
mceh_gigjxpllckcooagidcpbqxtnejlnlsccocuvcvge_fvjjbyqdkjceia_mkcvbzl \\
zwlxbdjihvpmdcvmssuvktwiqbeivtieol_bu_huumzmlxx_kd_vksmohgzl_fxwfdue \\
lqgfkgzxciwmuduozfbaxstxkwegescggkpxfpeenhb_whqhethcateqdvnxhpt__bja \\
_uiyxchmfkblmdwtyp_ktontmufw_isdflelsbgjizxvqbciuadfxxjaqbluofkgkkkh \\
jbvohisfla_cspbmuezqohnyijyimwgdeszutgnaoagbhku_wwdtylbbiyvbpoumgyid \\
w_xwg_fkogabccip_wouclnjcgdpwwxxvvvwkmmbgfeactbcksxqovqthtjfjghijwwh \\
ydfieyssbjtfqgqyjnmwfpesljmwapvbptucadontbobnspch_i_dxheklulncdsdnic \\
bnjjjedkaokw_ahcolvbcnmqtoakonpgzjufqlnn_uve_uumaufjasfvfcv_cbcuk_hd \\
zigkahchzfqjphjwcbjwmozyodhu_tsqtafwidgmc_snhhkleyvmzdtawdodzfmekuee \\
mnshz_xz";
uint32_t i,j;
uint32_t results[27];
uint8_t sort[27];
uint8_t top, position;
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
for (i = 0; i < 26; i++)
j = 0;
while (text[j] != 0x00)
if (text[j] == (ASCIISTART + i))
results[i]++;
j++;
j = 0;
while (text[j] != 0x00)
if (text[j] == 0x5F)
results[26]++;
j++;
for (i = 0; i < 27; i++)
top = 0;
position = 0;
for (j = 0; j < 27; j++)
if (results[j] > top)
top = results[j];
position = j;
results[position] = 0;
if (26 > position)
sort[i] = position + ASCIISTART;
else
sort[i] = 0x5F;
printf("%s", sort);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
__PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__GPIOE_CLK_ENABLE();
__GPIOC_CLK_ENABLE();
__GPIOH_CLK_ENABLE();
__GPIOA_CLK_ENABLE();
__GPIOB_CLK_ENABLE();
__GPIOD_CLK_ENABLE();
GPIO_InitStruct.Pin = CS_I2C_SPI_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
HAL_GPIO_Init(CS_I2C_SPI_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
HAL_GPIO_Init(OTG_FS_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = PDM_OUT_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(PDM_OUT_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_4;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI1;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = BOOT1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BOOT1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = CLK_IN_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF5_SPI2;
HAL_GPIO_Init(CLK_IN_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin|LD5_Pin|LD6_Pin
|Audio_RST_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_7|I2S3_SCK_Pin|GPIO_PIN_12;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF6_SPI3;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = VBUS_FS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(VBUS_FS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_ID_Pin|OTG_FS_DM_Pin|OTG_FS_DP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = OTG_FS_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(OTG_FS_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Audio_SCL_Pin|Audio_SDA_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;
GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MEMS_INT2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(MEMS_INT2_GPIO_Port, &GPIO_InitStruct);
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInit;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = 16;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL2;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct;
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, STEP_Pin|DIR_Pin|MS0_Pin|ENA_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(MS2_GPIO_Port, MS2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(MS1_GPIO_Port, MS1_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = STEP_Pin|DIR_Pin|MS0_Pin|ENA_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MS2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(MS2_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = MS1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(MS1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = END_STOP_REVERSE_Pin|END_STOP_FORWARD_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI9_5_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI9_5_IRQn);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_TIM1_Init();
MX_USART1_UART_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_SlaveConfigTypeDef sSlaveConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = 0;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 65535;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode = TIM_SLAVEMODE_DISABLE;
sSlaveConfig.InputTrigger = TIM_TS_ITR0;
if (HAL_TIM_SlaveConfigSynchro(&htim1, &sSlaveConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int _write(int file, char const *buf, int n)
HAL_UART_Transmit(&huart2, (uint8_t*)(buf), n, HAL_MAX_DELAY);
return n;
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
static int row = 0;
static const int keyboard[4][4] = {
{ 1, 2, 3, 21 },
{ 4, 5, 6, 22 },
{ 7, 8, 9, 23 },
{ 11, 0, 12, 24 },
};
if (key == -1) {
if (HAL_GPIO_ReadPin(Col1_GPIO_Port, Col1_Pin) == GPIO_PIN_RESET) key = keyboard[row][0];
if (HAL_GPIO_ReadPin(Col2_GPIO_Port, Col2_Pin) == GPIO_PIN_RESET) key = keyboard[row][1];
if (HAL_GPIO_ReadPin(Col3_GPIO_Port, Col3_Pin) == GPIO_PIN_RESET) key = keyboard[row][2];
if (HAL_GPIO_ReadPin(Col4_GPIO_Port, Col4_Pin) == GPIO_PIN_RESET) key = keyboard[row][3];
HAL_GPIO_WritePin(Row1_GPIO_Port, Row1_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(Row2_GPIO_Port, Row2_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(Row3_GPIO_Port, Row3_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(Row4_GPIO_Port, Row4_Pin, GPIO_PIN_SET);
switch (row) {
case 0: row = 1; HAL_GPIO_WritePin(Row2_GPIO_Port, Row2_Pin, GPIO_PIN_RESET); break;
case 1: row = 2; HAL_GPIO_WritePin(Row3_GPIO_Port, Row3_Pin, GPIO_PIN_RESET); break;
case 2: row = 3; HAL_GPIO_WritePin(Row4_GPIO_Port, Row4_Pin, GPIO_PIN_RESET); break;
case 3: row = 0; HAL_GPIO_WritePin(Row1_GPIO_Port, Row1_Pin, GPIO_PIN_RESET); break;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
MX_TIM3_Init();
HAL_TIM_Base_Start_IT(&htim3);
printf("test\\n");
const uint8_t code[] = {7,9,3,2,12};
uint8_t pos = 0;
uint32_t timeout ;
uint32_t t_now = HAL_GetTick();
while (1)
t_now = HAL_GetTick();
if(key!= -1 && key == code[pos])
timeout = t_now;
pos++ ;
key = -1;
if (pos == 5) HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);
printf("key = %d, pos = %d\\n",key, pos);
else
pos = 0;
printf("pos = %d\\n",pos);
if(pos>0 && pos < 5 && (t_now-timeout) > 3000)
printf("timeout\\n");
pos = 0;
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
static void MX_TIM3_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim3.Instance = TIM3;
htim3.Init.Prescaler = 8399;
htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
htim3.Init.Period = 99;
htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE;
if (HAL_TIM_Base_Init(&htim3) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 38400;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOF_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LED1_Pin|LD2_Pin|Row1_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, Row2_Pin|Row4_Pin|Row3_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED1_Pin|LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Col1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(Col1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Col4_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(Col4_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Col2_Pin|Col3_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_PULLUP;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Row1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(Row1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = Row2_Pin|Row4_Pin|Row3_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
GPIO_InitStruct.Pull = GPIO_PULLUP;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF1_I2C1;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
osThreadDef(Start, StartThread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE * 5);
osThreadDef(Start, StartThread, osPriorityNormal, 0, configMINIMAL_STACK_SIZE * 2);
osThreadCreate (osThread(Start), NULL);
osKernelStart();
for( ;; );
static void StartThread(void const * argument)
BSP_Config();
tcpip_init(NULL, NULL);
Netif_Config();
http_server_socket_init();
User_notification(&gnetif);
osThreadDef(DHCP, DHCP_thread, osPriorityBelowNormal, 0, configMINIMAL_STACK_SIZE * 2);
osThreadCreate (osThread(DHCP), &gnetif);
osThreadDef(LED4, ToggleLed4, osPriorityLow, 0, configMINIMAL_STACK_SIZE);
osThreadCreate(osThread(LED4), NULL);
for( ;; )
osThreadTerminate(NULL);
static void Netif_Config(void)
ip_addr_t ipaddr;
ip_addr_t netmask;
ip_addr_t gw;
ip_addr_set_zero_ip4(&ipaddr);
ip_addr_set_zero_ip4(&netmask);
ip_addr_set_zero_ip4(&gw);
IP_ADDR4(&ipaddr,IP_ADDR0,IP_ADDR1,IP_ADDR2,IP_ADDR3);
IP_ADDR4(&netmask,NETMASK_ADDR0,NETMASK_ADDR1,NETMASK_ADDR2,NETMASK_ADDR3);
IP_ADDR4(&gw,GW_ADDR0,GW_ADDR1,GW_ADDR2,GW_ADDR3);
netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);
netif_set_default(&gnetif);
if (netif_is_link_up(&gnetif))
netif_set_up(&gnetif);
else
netif_set_down(&gnetif);
netif_set_link_callback(&gnetif, ethernetif_update_config);
osSemaphoreDef(Netif_SEM);
Netif_LinkSemaphore = osSemaphoreCreate(osSemaphore(Netif_SEM) , 1 );
link_arg.netif = &gnetif;
link_arg.semaphore = Netif_LinkSemaphore;
osThreadDef(LinkThr, ethernetif_set_link, osPriorityNormal, 0, configMINIMAL_STACK_SIZE * 5);
osThreadDef(LinkThr, ethernetif_set_link, osPriorityNormal, 0, configMINIMAL_STACK_SIZE * 2);
osThreadCreate (osThread(LinkThr), &link_arg);
static void BSP_Config(void)
GPIO_InitTypeDef GPIO_InitStructure;
__HAL_RCC_GPIOB_CLK_ENABLE();
GPIO_InitStructure.Pin = GPIO_PIN_14;
GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;
GPIO_InitStructure.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0xF, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED4);
BSP_LCD_Init();
BSP_LCD_SetFont(&LCD_DEFAULT_FONT);
LCD_LOG_Init();
LCD_LOG_SetHeader((uint8_t *)"Webserver Application");
LCD_LOG_SetFooter((uint8_t *)"STM324xG-EVAL board");
LCD_UsrLog("  State: Ethernet Initialization ...\\n");
static void ToggleLed4(void const * argument)
for( ;; )
BSP_LED_Toggle(LED4);
osDelay(250);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == GPIO_PIN_14)
osSemaphoreRelease(Netif_LinkSemaphore);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
if (HAL_GetREVID() == 0x1001)
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART2_UART_Init();
HAL_UART_Receive_IT(&huart2, &rxBuffer, 1);
while (1)
printf("Hello, World!\\n");
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
bool i2cInit(void)
uint32_t i;
for (i=0; i<I2C_MAX_CH; i++)
i2c_timeout[i] = 10;
i2c_errcount[i] = 0;
is_init[i] = false;
i2cCmdifInit();
return true;
bool i2cBegin(uint8_t ch, uint32_t freq_khz)
bool ret = false;
I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
if (ch >= I2C_MAX_CH)
return false;
switch(ch)
case _DEF_I2C1:
case _DEF_I2C2:
i2c_freq[ch] = freq_khz;
p_handle->Init.ClockSpeed      = freq_khz * 1000;
p_handle->Init.OwnAddress1     = 0x00;
p_handle->Init.AddressingMode  = I2C_ADDRESSINGMODE_7BIT;
p_handle->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
p_handle->Init.OwnAddress2     = 0xFF;
p_handle->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
p_handle->Init.NoStretchMode   = I2C_NOSTRETCH_DISABLE;
HAL_I2C_DeInit(p_handle);
if(HAL_I2C_Init(p_handle) != HAL_OK)
HAL_I2CEx_ConfigAnalogFilter(p_handle,I2C_ANALOGFILTER_ENABLE);
ret = true;
is_init[ch] = true;
break;
return ret;
void i2cReset(uint8_t ch)
GPIO_InitTypeDef  GPIO_InitStruct;
i2c_tbl_t *p_pin = &i2c_tbl[ch];
GPIO_InitStruct.Pin       = p_pin->scl_pin;
GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull      = GPIO_NOPULL;
GPIO_InitStruct.Speed     = GPIO_SPEED_HIGH;
HAL_GPIO_Init(p_pin->scl_port, &GPIO_InitStruct);
GPIO_InitStruct.Pin       = p_pin->sda_pin;
GPIO_InitStruct.Mode      = GPIO_MODE_OUTPUT_OD;
GPIO_InitStruct.Pull      = GPIO_NOPULL;
HAL_GPIO_Init(p_pin->sda_port, &GPIO_InitStruct);
HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET);
delayUs(5);
for (int i = 0; i < 9; i++)
HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET);
delayUs(5);
HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
delayUs(5);
HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET);
delayUs(5);
HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_RESET);
delayUs(5);
HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET);
delayUs(5);
HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET);
bool i2cRecovery(uint8_t ch)
bool ret;
i2cReset(ch);
ret = i2cBegin(ch, i2c_freq[ch]);
return ret;
bool i2cReadByte (uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t timeout)
return i2cReadBytes(ch, dev_addr, reg_addr, p_data, 1, timeout);
bool i2cReadBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
bool ret;
HAL_StatusTypeDef i2c_ret;
I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
if (ch >= I2C_MAX_CH)
return false;
i2c_ret = HAL_I2C_Mem_Read(p_handle, (uint16_t)(dev_addr << 1), reg_addr, I2C_MEMADD_SIZE_8BIT, p_data, length, timeout);
if( i2c_ret == HAL_OK )
ret = true;
else
ret = false;
return ret;
bool i2cReadData(uint8_t ch, uint16_t dev_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
bool ret;
HAL_StatusTypeDef i2c_ret;
I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
if (ch >= I2C_MAX_CH)
return false;
i2c_ret = HAL_I2C_Master_Receive(p_handle, (uint16_t)(dev_addr << 1), p_data, length, timeout);
if( i2c_ret == HAL_OK )
ret = true;
else
ret = false;
return ret;
bool i2cWriteByte (uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t data, uint32_t timeout)
return i2cWriteBytes(ch, dev_addr, reg_addr, &data, 1, timeout);
bool i2cWriteBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
bool ret;
HAL_StatusTypeDef i2c_ret;
I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
if (ch >= I2C_MAX_CH)
return false;
i2c_ret = HAL_I2C_Mem_Write(p_handle, (uint16_t)(dev_addr << 1), reg_addr, I2C_MEMADD_SIZE_8BIT, p_data, length, timeout);
if(i2c_ret == HAL_OK)
ret = true;
else
ret = false;
return ret;
bool i2cWriteData(uint8_t ch, uint16_t dev_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)
bool ret;
HAL_StatusTypeDef i2c_ret;
I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c;
if (ch >= I2C_MAX_CH)
return false;
i2c_ret = HAL_I2C_Master_Transmit(p_handle, (uint16_t)(dev_addr << 1), p_data, length, timeout);
if(i2c_ret == HAL_OK)
ret = true;
else
ret = false;
return ret;
void i2cSetTimeout(uint8_t ch, uint32_t timeout)
i2c_timeout[ch] = timeout;
uint32_t i2cGetTimeout(uint8_t ch)
return i2c_timeout[ch];
void i2cClearErrCount(uint8_t ch)
i2c_errcount[ch] = 0;
uint32_t i2cGetErrCount(uint8_t ch)
return i2c_errcount[ch];
void i2cCmdifInit(void)
cmdifAdd("i2c", i2cCmdif);
void i2cCmdif(void)
bool ret = true;
bool i2c_ret;
uint8_t print_ch;
uint8_t ch;
uint16_t dev_addr;
uint16_t reg_addr;
uint16_t length;
uint32_t i;
uint8_t i2c_data[128];
if (cmdifGetParamCnt() == 2)
print_ch = (uint16_t) cmdifGetParam(1);
print_ch = constrain(print_ch, 1, I2C_MAX_CH);
print_ch -= 1;
if(cmdifHasString("begin", 0) == true)
i2c_ret = i2cBegin(print_ch, 400);
if (i2c_ret == true)
cmdifPrintf("I2C CH%d Begin OK\\n", print_ch + 1);
else
cmdifPrintf("I2C CH%d Begin Fail\\n", print_ch + 1);
else if (cmdifGetParamCnt() == 5)
print_ch = (uint16_t) cmdifGetParam(1);
print_ch = constrain(print_ch, 1, I2C_MAX_CH);
dev_addr = (uint16_t) cmdifGetParam(2);
reg_addr = (uint16_t) cmdifGetParam(3);
length   = (uint16_t) cmdifGetParam(4);
ch       = print_ch - 1;
if(cmdifHasString("read", 0) == true)
for (i=0; i<length; i++)
i2c_ret = i2cReadByte(ch, dev_addr, reg_addr+i, i2c_data, 100);
if (i2c_ret == true)
cmdifPrintf("%d I2C - 0x%02X : 0x%02X\\n", print_ch, reg_addr+i, i2c_data[0]);
else
cmdifPrintf("%d I2C - Fail \\n", print_ch);
break;
else
ret = false;
else
ret = false;
if (ret == false)
cmdifPrintf( "i2c begin channel[1~%d]\\n", I2C_MAX_CH);
cmdifPrintf( "i2c read channel dev_addr reg_addr length\\n");
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART3_UART_Init();
while (1)
HAL_UART_Receive_DMA(&huart3, (uint8_t *)(DEST_ADDR),50);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_USART3_UART_Init(void)
huart3.Instance = USART3;
huart3.Init.BaudRate = 115200;
huart3.Init.WordLength = UART_WORDLENGTH_8B;
huart3.Init.StopBits = UART_STOPBITS_1;
huart3.Init.Parity = UART_PARITY_NONE;
huart3.Init.Mode = UART_MODE_TX_RX;
huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart3.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart3) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOG_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOB, LD3_Pin|LD2_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LD1_GPIO_Port, LD1_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USER_Btn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_MDC_Pin|RMII_RXD0_Pin|RMII_RXD1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_REF_CLK_Pin|RMII_MDIO_Pin|RMII_CRS_DV_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_TXD1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(RMII_TXD1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD3_Pin|LD2_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_OverCurrent_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LD1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_SOF_Pin|USB_ID_Pin|USB_DM_Pin|USB_DP_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF10_OTG_FS;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USB_VBUS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USB_VBUS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = RMII_TX_EN_Pin|RMII_TXD0_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF11_ETH;
HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
while (1)
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = BUTTON_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(BUTTON_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(EXTI0_1_IRQn);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
static int link_test()
int ret = -1;
UINT32 uwRet = LOS_OK;
UINT32  handle;
TSK_INIT_PARAM_S task_init_param;
memset (&task_init_param, 0, sizeof (TSK_INIT_PARAM_S));
task_init_param.uwArg = (unsigned int)NULL;
task_init_param.usTaskPrio = 2;
task_init_param.pcName =(char *) "link_main";
task_init_param.pfnTaskEntry = (TSK_ENTRY_FUNC)link_main;
task_init_param.uwStackSize = 0x1000;
uwRet = LOS_TaskCreate(&handle, &task_init_param);
if(LOS_OK == uwRet){
ret = 0;
return ret;
int main(void)
UINT32 uwRet = LOS_OK;
HardWare_Init();
uwRet = LOS_KernelInit();
if (uwRet != LOS_OK)
return LOS_NOK;
link_test();
(void)LOS_Start();
return 0;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
DWT_CTRL |= (1<<0);
SEGGER_SYSVIEW_Conf();
status = xTaskCreate( LedGreenTask, "Led_Green_Task", 200, NULL , 2, &GreenTaskHandle );
configASSERT(status == pdPASS);
Next_Task_Handle = GreenTaskHandle;
status = xTaskCreate( LedRedTask, "Led_Red_Task", 200, NULL , 2, &RedTaskHandle );
configASSERT(status == pdPASS);
status = xTaskCreate( LedYellowTask, "Led_Yellow_Task", 200, NULL , 2, &YellowTaskHandle );
configASSERT(status == pdPASS);
NVIC_EnableIRQ(EXTI15_10_IRQn);
__enable_irq();
vTaskStartScheduler();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 16;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 2;
RCC_OscInitStruct.PLL.PLLR = 2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, LD2_Pin|GPIO_PIN_9, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = B1_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LD2_Pin|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_7;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_6;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 6, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM6) {
HAL_IncTick();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
uint8_t max6675ReadReg(uint16_t *reg)
HAL_StatusTypeDef err = HAL_ERROR;
uint8_t temp_buf[2] = {0};
MAX6675_CS_SET();
err = HAL_SPI_Receive(MAX6675_SPI, temp_buf, 2, 100);
MAX6675_CS_RESET();
if(err == HAL_OK)
if(temp_buf[1] & 0x04) return MAX6675_FALSE;
*reg = (uint16_t)(temp_buf[1] >> 3);
*reg |= (uint16_t)(temp_buf[0] << 5);
return MAX6675_TRUE;
return MAX6675_FALSE;
float max6675Temp(uint16_t reg)
return reg * 0.25;
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_SPI1_Init();
MX_USART1_UART_Init();
while (1)
HAL_GPIO_TogglePin(GPIOC,GPIO_PIN_13);
temper_err = max6675ReadReg(&reg);
if(temper_err == MAX6675_TRUE)
temper = max6675Temp(reg);
sprintf((char*)string, "Track:1 Temperature:%0.2f\\r", temper);
else
sprintf((char*)string, "Track:1 Temperature: error!\\n\\r");
HAL_UART_Transmit(&huart1, string, sizeof(string), 100);
HAL_Delay(1000);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_SPI1_Init();
MX_USART1_UART_Init();
MX_FREERTOS_Init();
osKernelStart();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim)
if (htim->Instance == TIM2) {
HAL_IncTick();
void Error_Handler(void)
printf("Find error\\r\\n");
void assert_failed(uint8_t *file, uint32_t line)
__ASM void __SVC(void)
SVC 0x01
BX R14
static __INLINE  void __SVC()
__ASM("svc 0x01");
static __INLINE void __SVC()
__ASM volatile("svc 0x01");
int main(void)
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
for(Index = 0; Index < SP_PROCESS_SIZE; Index++)
PSPMemAlloc[Index] = 0x00;
__set_PSP((uint32_t)PSPMemAlloc + SP_PROCESS_SIZE);
__set_CONTROL(SP_PROCESS);
__ISB();
if((__get_CONTROL() & 0x02) == SP_MAIN)
CurrentStack = SP_MAIN;
else
CurrentStack = SP_PROCESS;
PSPValue = __get_PSP();
__set_CONTROL(THREAD_MODE_UNPRIVILEGED | SP_PROCESS);
__ISB();
if((__get_CONTROL() & 0x01) == THREAD_MODE_PRIVILEGED)
ThreadMode = THREAD_MODE_PRIVILEGED;
else
ThreadMode = THREAD_MODE_UNPRIVILEGED;
__set_CONTROL(THREAD_MODE_PRIVILEGED | SP_PROCESS);
__ISB();
__SVC();
if((__get_CONTROL() & 0x01) == THREAD_MODE_PRIVILEGED)
ThreadMode = THREAD_MODE_PRIVILEGED;
else
ThreadMode = THREAD_MODE_UNPRIVILEGED;
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
void assert_failed(uint8_t *file, uint32_t line)
while (1)
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
EXTI15_10_IRQHandler_Config();
while (1)
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
while(1) {};
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
while(1) {};
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
while(1) {};
static void EXTI15_10_IRQHandler_Config(void)
GPIO_InitTypeDef   GPIO_InitStructure;
__HAL_RCC_GPIOC_CLK_ENABLE();
GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStructure.Pull = GPIO_NOPULL;
GPIO_InitStructure.Pin = GPIO_PIN_13;
HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0);
HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if (GPIO_Pin == GPIO_PIN_13)
BSP_LED_Toggle(LED1);
static void CPU_CACHE_Enable(void)
SCB_EnableICache();
SCB_EnableDCache();
static void MPU_Config(void)
MPU_Region_InitTypeDef MPU_InitStruct;
HAL_MPU_Disable();
MPU_InitStruct.Enable = MPU_REGION_ENABLE;
MPU_InitStruct.BaseAddress = 0x00;
MPU_InitStruct.Size = MPU_REGION_SIZE_4GB;
MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS;
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;
MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE;
MPU_InitStruct.Number = MPU_REGION_NUMBER0;
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;
MPU_InitStruct.SubRegionDisable = 0x87;
MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE;
HAL_MPU_ConfigRegion(&MPU_InitStruct);
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
void assert_failed(uint8_t *file, uint32_t line)
while (1)
uint32_t HAL_GetTick(void)
return os_time;
return osKernelGetTickCount();
double current_time(int reset)
if (reset)
return 0;
return (double)os_time / 1000.0;
return (double)osKernelGetTickCount() / 1000.0;
double current_time(int reset)
if(reset) DWT->CYCCNT = 0 ;
return ((double)DWT->CYCCNT/SystemCoreClock) ;
void setTime(time_t t)
epochTime = t;
int main()
void * arg = NULL ;
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
init_filesystem ();
setTime((RTC_YEAR-1970)*365*24*60*60 + RTC_MONTH*30*24*60*60 + RTC_DAY*24*60*60);
printf("=== Start: Crypt Benchmark ===\\n") ;
benchmark_test(arg) ;
printf("=== End: Crypt Benchmark  ===\\n") ;
int main(void)
uint8_t data_0x001D004E[64] = {0x40, 0x4E, 0x00, 0x1D, 0x00, 0x00, 0x01, 0x00, 0x02, 0x50, 0xEE, 0xEC, 0x5F, 0x44, 0x0C, 0xFA, 0xC3, 0x36, 0xC8, 0xD6, 0x28, 0x90, 0xBC, 0x6E, 0xAC, 0x66, 0x03, 0xEF, 0x19, 0xCC, 0x36, 0x9C, 0x5A, 0xF9, 0xF0, 0x22, 0x02, 0xB3, 0xEE, 0x4D, 0x7B, 0x77, 0x70, 0xBB, 0x12, 0xAE, 0x85, 0x73, 0xA6, 0x5C, 0x4A, 0x46, 0xEA, 0x13, 0x61, 0x8E, 0x19, 0xA2, 0xC5, 0x81, 0x53, 0x65, 0x1F, 0x3F};
uint8_t data_0x00420029[64] = {0x40, 0x29, 0x00, 0x42, 0x00, 0x00, 0x01, 0x00, 0x02, 0xF2, 0x54, 0x99, 0xDE, 0x08, 0xC8, 0x64, 0xCC, 0x89, 0xB8, 0x1E, 0x3E, 0x3D, 0x54, 0xE9, 0x70, 0x55, 0x66, 0x22, 0x95, 0x31, 0x81, 0x97, 0x2C, 0xB3, 0xC7, 0x43, 0x75, 0xB4, 0x56, 0x4B, 0x40, 0xBB, 0xAB, 0x93, 0xB3, 0x03, 0x8A, 0xA0, 0x7D, 0xBE, 0xB2, 0xDB, 0x51, 0x50, 0xD0, 0x61, 0x25, 0xA5, 0xEA, 0x50, 0xF7, 0x82, 0x4F, 0xC9};
uint16_t datarate,i;
int *packet_freq_points_No1 = NULL;
int *packet_freq_points_No2 = NULL;
int symbol_len_No1 = NULL;
int symbol_len_No2 = NULL;
int *LoRa_ID_Start_Freq_No1 = NULL;
int *LoRa_Payload_Start_Freq_No1 = NULL;
int *LoRa_ID_Start_Freq_No2 = NULL;
int *LoRa_Payload_Start_Freq_No2 = NULL;
HAL_Init();
SystemClock_Config();
HW_Init();
SPI1_Init();
delay_init(80);
uart_init(115200);
Control_GPIO_Init();
LPM_SetOffMode(LPM_APPLI_Id, LPM_Disable);
energest_init();
int CF_list[8]={486300000,486500000,486700000,486900000,487100000,487300000,487500000,487700000};
int CF = CF_list[0];
int CF1= CF_list[0];
int CF2= CF1 + 400000;
for(int k=0;k<BUFFER_SIZE;k++)
Tx_Buffer[k]=rand()%255;
CF1 = CF_list[rand()%5];
CF2= CF1 + 400000;
printf("CR=4/%d, CRC=%s, IMPL_HEAD=%s, LDR=%s\\n",4+LORA_CR_NO1,LORA_HAS_CRC_NO1?"ON":"OFF",LORA_IMPL_HEAD_NO1?"ON":"OFF",LORA_LOWDATERATEOPTIMIZE_NO1?"ON":"OFF");
printf("FREQ1:%d,sf1:%d,\\r\\nFREQ2:%d,sf2:%d\\r\\n",CF,LORA_SF_NO1,CF2,LORA_SF_NO2);
Radio.Init(&RadioEvents);
Radio.SetChannel(CF);
Radio.SetTxContinuousWave(CF,TX_OUTPUT_POWER,3);
SX1276Write( REG_OSC, RF_OSC_CLKOUT_1_MHZ );
SX1276Write( REG_PLLHOP, ( SX1276Read( REG_PLLHOP ) & RF_PLLHOP_FASTHOP_MASK ) | RF_PLLHOP_FASTHOP_ON );
SX1276Write( REG_PLL, ( SX1276Read( REG_PLL ) & RF_PLL_BANDWIDTH_MASK ) | RF_PLL_BANDWIDTH_150 );
SX1276Write( REG_PARAMP, ( SX1276Read( REG_PARAMP ) & RF_PARAMP_MASK ) | RF_PARAMP_0010_US );
SX1276Write( REG_PARAMP, ( SX1276Read( REG_PARAMP ) & RF_PARAMP_MODULATIONSHAPING_MASK ) | RF_PARAMP_MODULATIONSHAPING_00 );
SX1276Write( REG_OCP, ( SX1276Read( REG_OCP ) & RF_OCP_MASK ) | RF_OCP_OFF );
datarate = ( uint16_t )( ( double )XTAL_FREQ / ( double )DATA_RATE );
SX1276Write( REG_BITRATEMSB, ( uint8_t )( datarate >> 8 ) );
SX1276Write( REG_BITRATELSB, ( uint8_t )( datarate & 0xFF ) );
for(i=0;i<PACKET_COUNT;i++)
packet_freq_points_No1 = LoRa_Channel_Coding(data_0x001D004E, 235, LORA_BW, LORA_SF_NO1, LORA_CR_NO1, LORA_HAS_CRC_NO1, LORA_IMPL_HEAD_NO1, &symbol_len_No1, LORA_LOWDATERATEOPTIMIZE_NO1);
packet_freq_points_No2 = LoRa_Channel_Coding(data_0x00420029, 64, LORA_BW, LORA_SF_NO2, LORA_CR_NO2, LORA_HAS_CRC_NO2, LORA_IMPL_HEAD_NO2, &symbol_len_No2, LORA_LOWDATERATEOPTIMIZE_NO2);
LoRa_Generate_Signal(packet_freq_points_No1,symbol_len_No1,CF);
LoRa_Generate_Signal_With_Blank(packet_freq_points_No1,symbol_len_No1,LOOK_BLANK_RATIO,RF_FREQUENCY_NO1);
LoRa_Generate_Double_Packet(packet_freq_points_No1,symbol_len_No1,packet_freq_points_No2,symbol_len_No2,CF1,CF2);
free(packet_freq_points_No1);
free(packet_freq_points_No2);
printf("Tx done, Count:%d\\r\\n",i+1);
delay_ms(INTERVAL_TIME);
printf("energyest tx:%lu",energest_type_time(ENERGEST_TYPE_TRANSMIT));
printf("finish!!\\r\\n");
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_I2C2_Init();
MX_USART2_UART_Init();
main_NVM();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV2;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
void assert_failed(char *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART1_UART_Init();
while (1)
HAL_UART_Receive_IT(&huart1, (uint8_t *)rxBuffer, 1);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX_RX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOD_CLK_ENABLE();
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_8;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_15;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
GPIO_InitStruct.Pin = GPIO_PIN_2;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
void application_entry(void *arg)
extern void mqtt_basic_thread(void);
dns_init();
MX_LWIP_Init();
extern int esp8266_sal_init(hal_uart_port_t uart_port);
extern int esp8266_join_ap(const char *ssid, const char *pwd);
esp8266_sal_init(HAL_UART_PORT_0);
esp8266_join_ap("SheldonDai", "srnr6x9xbhmb0");
extern int bc35_28_95_sal_init(hal_uart_port_t uart_port);
bc35_28_95_sal_init(HAL_UART_PORT_0);
coap_basic_thread();
while (1) {
printf("This is a coap demo!\\r\\n");
tos_task_delay(1000);
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
SystemClock_Config();
BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);
MX_GPIO_Init();
MX_TIM2_Init();
MX_TIM1_Init();
if (HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
if (HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK
|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1
|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_OC_InitTypeDef sConfigOC = {0};
TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = uhPrescalerValue;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = (SystemCoreClock/1)/aFrequency[0];
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&htim1) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterOutputTrigger2 = TIM_TRGO2_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigOC.OCMode = TIM_OCMODE_PWM1;
sConfigOC.Pulse = ((SystemCoreClock/1)/aFrequency[0])/aDutyCycle[0];
sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH;
sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET;
sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE;
sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE;
sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF;
sBreakDeadTimeConfig.DeadTime = 0;
sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE;
sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH;
sBreakDeadTimeConfig.BreakFilter = 0;
sBreakDeadTimeConfig.BreakAFMode = TIM_BREAK_AFMODE_INPUT;
sBreakDeadTimeConfig.Break2State = TIM_BREAK2_DISABLE;
sBreakDeadTimeConfig.Break2Polarity = TIM_BREAK2POLARITY_HIGH;
sBreakDeadTimeConfig.Break2Filter = 0;
sBreakDeadTimeConfig.Break2AFMode = TIM_BREAK_AFMODE_INPUT;
sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE;
if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK)
Error_Handler();
HAL_TIM_MspPostInit(&htim1);
static void MX_TIM2_Init(void)
TIM_SlaveConfigTypeDef sSlaveConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
TIM_IC_InitTypeDef sConfigIC = {0};
htim2.Instance = TIM2;
htim2.Init.Prescaler = 0x0;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 0xFFFF;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
Error_Handler();
if (HAL_TIM_IC_Init(&htim2) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode = TIM_SLAVEMODE_RESET;
sSlaveConfig.InputTrigger = TIM_TS_TI2FP2;
sSlaveConfig.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sSlaveConfig.TriggerFilter = 0;
if (HAL_TIM_SlaveConfigSynchro(&htim2, &sSlaveConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
Error_Handler();
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING;
sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
sConfigIC.ICPrescaler = TIM_ICPSC_DIV1;
sConfigIC.ICFilter = 0;
if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
sConfigIC.ICSelection = TIM_ICSELECTION_DIRECTTI;
if (HAL_TIM_IC_ConfigChannel(&htim2, &sConfigIC, TIM_CHANNEL_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
__HAL_RCC_GPIOA_CLK_ENABLE();
void UserButton_Callback()
iFrequency = (iFrequency + 1) % TIM_FREQUENCIES_NB;
iDutyCycle = (iDutyCycle + 1) % TIM_DUTYCYCLE_NB;
LL_TIM_SetAutoReload(TIM1, __LL_TIM_CALC_ARR(SystemCoreClock/1, LL_TIM_GetPrescaler(TIM1), aFrequency[iFrequency]));
LL_TIM_OC_SetCompareCH1(TIM1, (LL_TIM_GetAutoReload(TIM1) / aDutyCycle[iDutyCycle]));
void TimerCaptureCompare_Ch2_Callback()
uwIC2Value = LL_TIM_IC_GetCaptureCH2(TIM2);
if (uwIC2Value != 0)
uwDutyCycle = (LL_TIM_IC_GetCaptureCH1(TIM2) * 100) / uwIC2Value;
uwFrequency = SystemCoreClock  / (1*uwIC2Value);
else
uwDutyCycle = 0;
uwFrequency = 0;
void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
osSemaphoreDef(SEM);
osSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1);
osThreadDef(SEM_Thread1, SemaphoreThread1, osPriorityLow, 0, semtstSTACK_SIZE);
SemThread1Handle = osThreadCreate(osThread(SEM_Thread1), (void *) osSemaphore);
osThreadDef(SEM_Thread2, SemaphoreThread2, osPriorityIdle, 0, semtstSTACK_SIZE);
SemThread2Handle = osThreadCreate(osThread(SEM_Thread2), (void *) osSemaphore);
osKernelStart();
for (;;);
static void SemaphoreThread1(void const *argument)
uint32_t count = 0;
osSemaphoreId semaphore = (osSemaphoreId) argument;
for (;;)
if (semaphore != NULL)
if (osSemaphoreWait(semaphore , 100) == osOK)
count = osKernelSysTick() + 5000;
while (count >= osKernelSysTick())
BSP_LED_Toggle(LED3);
osDelay(200);
BSP_LED_Off(LED3);
osSemaphoreRelease(semaphore);
osThreadSuspend(NULL);
static void SemaphoreThread2(void const *argument)
uint32_t count = 0;
osSemaphoreId semaphore = (osSemaphoreId) argument;
for (;;)
if (semaphore != NULL)
if (osSemaphoreWait(semaphore , 0) == osOK)
osThreadResume(SemThread1Handle);
count = osKernelSysTick() + 5000;
while (count >= osKernelSysTick())
BSP_LED_Toggle(LED4);
osDelay(200);
BSP_LED_Off(LED4);
osSemaphoreRelease(semaphore);
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void assert_failed(uint8_t *file, uint32_t line)
while (1)
{}
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
BSP_LED_Init(LED5);
SystemClock_Config();
DMA_Config();
while (1)
static void DMA_Config(void)
__HAL_RCC_DMA2_CLK_ENABLE();
DmaHandle.Init.Channel = DMA_CHANNEL;
DmaHandle.Init.Direction = DMA_MEMORY_TO_MEMORY;
DmaHandle.Init.PeriphInc = DMA_PINC_ENABLE;
DmaHandle.Init.MemInc = DMA_MINC_ENABLE;
DmaHandle.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
DmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
DmaHandle.Init.Mode = DMA_NORMAL;
DmaHandle.Init.Priority = DMA_PRIORITY_HIGH;
DmaHandle.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
DmaHandle.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
DmaHandle.Init.MemBurst = DMA_MBURST_SINGLE;
DmaHandle.Init.PeriphBurst = DMA_PBURST_SINGLE;
DmaHandle.Instance = DMA_STREAM;
DmaHandle.XferCpltCallback  = TransferComplete;
DmaHandle.XferErrorCallback = TransferError;
if(HAL_DMA_Init(&DmaHandle) != HAL_OK)
Error_Handler();
HAL_NVIC_SetPriority(DMA_STREAM_IRQ, 0, 0);
HAL_NVIC_EnableIRQ(DMA_STREAM_IRQ);
if(HAL_DMA_Start_IT(&DmaHandle, (uint32_t)&aSRC_Const_Buffer, (uint32_t)&aDST_Buffer, BUFFER_SIZE) != HAL_OK)
Error_Handler();
static void TransferComplete(DMA_HandleTypeDef *DmaHandle)
BSP_LED_On(LED4);
static void TransferError(DMA_HandleTypeDef *DmaHandle)
BSP_LED_On(LED5);
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 336;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_I2C1_Init();
MX_SPI2_Init();
MX_SPI3_Init();
MX_I2C2_Init();
MX_USART1_UART_Init();
MX_SPI1_Init();
uint32_t MemAddrs = 0;
uint64_t TxpipeAddrs = 0x11223344AA;
uint8_t myTxData[32];
uint8_t FlashBuf[256];
static const char *rst = "PSTMRESTOREPAR*11\\r\\n";
static const char *agss = "PSTMSTAGPSONOFF,1*4B\\r\\n";
static const char *nmea_rec = "$PSTMNMEAREQUEST,00002,00000*4E\\r\\n";
static const char *setport = "$PSTMCFGPORT,1,0,3A,0*02\\r\\n";
static const char *setmsg = "$PSTMCFGMSGL,3,255,00000002,00000000*4E\\r\\n";
static const char *setsat1 = "$PSTMSTAGPSSETCONSTMASK,7*10\\r\\n";
static const char *setsat2 = "$PSTMSETPAR,3227,0x40*53\\r\\n";
NRF24_begin(NRF_CSN_GPIO_Port, NRF_CSN_Pin, NRF_CE_Pin, hspi3);
NRF24_stopListening();
NRF24_openWritingPipe(TxpipeAddrs);
NRF24_setAutoAck(false);
NRF24_setChannel(55);
NRF24_setPayloadSize(32);
GPS_Transmit(setport);
GPS_Save();
GPS_Transmit(setmsg);
GPS_Save();
GPS_Transmit(setsat1);
GPS_Save();
GPS_Transmit(nmea_rec);
GPS_Save();
my_MCP_begin(hi2c1, 80, 75, BIT_RES_12, FAULT_Q_4);
H3LIS_begin(hspi2, HIGH_G_CS_GPIO_Port, HIGH_G_CS_Pin, NORMAL, DATA_RATE_400HZ);
IS25_Init(FLASH_CS_GPIO_Port, FLASH_CS_Pin);
LSM_begin(hspi1,LSM_CSAG_GPIO_Port,LSM_CSM_GPIO_Port,LSM_CSAG_Pin,LSM_CSM_Pin);
LSM_SetAG(LSM9DS1_CTRL_REG6_XL_ODR_XL_476HZ, LSM9DS1_CTRL_REG1_G_ODR_G_476HZ, LSM9DS1_CTRL_REG6_XL_FS_XL_8G, LSM9DS1_CTRL_REG1_G_FS_G_2000DPS, LSM9DS1_FIFO_CTRL_FMODE_BYPASS);
LSM_M_Set(LSM9DS1_CTRL_REG1_M_DO_80HZ, LSM9DS1_CTRL_REG2_M_FS_8GAUSS, 0);
uint16_t temp;
uint8_t  cnt=0;
while (1)
temp = MCP_get_temp(hi2c1);
myTxData[0] = (temp>>8)&0xFF;
myTxData[1] = temp&0xFF;
H3LIS_get_acceleration(&myTxData[2]);
LSM_GetRawAcc(&myTxData[5]);
LSM_GetRawGyro(&myTxData[11]);
LSM_GetRawM(&myTxData[17]);
memcpy(&FlashBuf[32*cnt],myTxData,32);
cnt++;
if(cnt==8) {
IS25_write(MemAddrs,256,FlashBuf);
MemAddrs = MemAddrs + 256;
Rocket_Transmit(myTxData,32);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 84;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_I2C1_Init(void)
hi2c1.Instance = I2C1;
hi2c1.Init.ClockSpeed = 100000;
hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c1.Init.OwnAddress1 = 0;
hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c1.Init.OwnAddress2 = 0;
hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c1) != HAL_OK)
Error_Handler();
static void MX_I2C2_Init(void)
hi2c2.Instance = I2C2;
hi2c2.Init.ClockSpeed = 100000;
hi2c2.Init.DutyCycle = I2C_DUTYCYCLE_2;
hi2c2.Init.OwnAddress1 = 0;
hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
hi2c2.Init.OwnAddress2 = 0;
hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
if (HAL_I2C_Init(&hi2c2) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_8BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_16;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_SPI2_Init(void)
hspi2.Instance = SPI2;
hspi2.Init.Mode = SPI_MODE_MASTER;
hspi2.Init.Direction = SPI_DIRECTION_2LINES;
hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi2.Init.NSS = SPI_NSS_SOFT;
hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;
hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi2.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi2) != HAL_OK)
Error_Handler();
static void MX_SPI3_Init(void)
hspi3.Instance = SPI3;
hspi3.Init.Mode = SPI_MODE_MASTER;
hspi3.Init.Direction = SPI_DIRECTION_2LINES;
hspi3.Init.DataSize = SPI_DATASIZE_8BIT;
hspi3.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi3.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi3.Init.NSS = SPI_NSS_SOFT;
hspi3.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_128;
hspi3.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi3.Init.TIMode = SPI_TIMODE_DISABLE;
hspi3.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi3.Init.CRCPolynomial = 10;
if (HAL_SPI_Init(&hspi3) != HAL_OK)
Error_Handler();
static void MX_USART1_UART_Init(void)
huart1.Instance = USART1;
huart1.Init.BaudRate = 115200;
huart1.Init.WordLength = UART_WORDLENGTH_8B;
huart1.Init.StopBits = UART_STOPBITS_1;
huart1.Init.Parity = UART_PARITY_NONE;
huart1.Init.Mode = UART_MODE_TX;
huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart1.Init.OverSampling = UART_OVERSAMPLING_16;
if (HAL_UART_Init(&huart1) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOC, NRF_CE_Pin|NRF_CSN_Pin|LSM_CSM_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LSM_CSAG_GPIO_Port, LSM_CSAG_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(HIGH_G_CS_GPIO_Port, HIGH_G_CS_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(FLASH_CS_GPIO_Port, FLASH_CS_Pin, GPIO_PIN_SET);
GPIO_InitStruct.Pin = NRF_CE_Pin|NRF_CSN_Pin|LSM_CSM_Pin|HIGH_G_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LSM_CSAG_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LSM_CSAG_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = FLASH_CS_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(FLASH_CS_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = NRF_IRQ_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(NRF_IRQ_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
static void DelayLoop( volatile uint32_t nCount )
volatile uint32_t index = 0;
for( index = ( 5000 * nCount ); index != 0; index-- )
int main( void )
HAL_Init( );
SystemClockConfig( );
I2cInit( &I2c, I2C_SCL, I2C_SDA );
GpioInit( &UsbDetect, USB_ON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0 );
GpioInit( &DcDcEnable, DC_DC_EN, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &RadioPushButton, RADIO_PUSH_BUTTON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led3, LED_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
GpioInit( &Led4, LED_4, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );
if( GpioRead( &RadioPushButton ) == 0 )
if( ( ( *( volatile uint32_t* )USBD_DFU_APP_DEFAULT_ADD ) & 0x2FFE0000 ) == 0x20000000 )
JumpAddress = *( volatile uint32_t* ) ( USBD_DFU_APP_DEFAULT_ADD + 4 );
JumpToApplication = ( pFunction ) JumpAddress;
__set_MSP( *( volatile uint32_t* ) USBD_DFU_APP_DEFAULT_ADD );
JumpToApplication( );
USBD_Init( &USBD_Device, &DFU_Desc, 0 );
USBD_RegisterClass( &USBD_Device, USBD_DFU_CLASS );
USBD_DFU_RegisterMedia( &USBD_Device, &USBD_DFU_Flash_fops );
USBD_Start( &USBD_Device );
while( 1 )
GpioWrite( &Led1, 0 );
GpioWrite( &Led2, 0 );
GpioWrite( &Led3, 0 );
GpioWrite( &Led4, 0 );
DelayLoop( 500 );
GpioWrite( &Led1, 1 );
GpioWrite( &Led2, 1 );
GpioWrite( &Led3, 1 );
GpioWrite( &Led4, 1 );
DelayLoop( 500 );
void SystemClockConfig( void )
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType      = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState            = RCC_HSI_ON;
RCC_OscInitStruct.PLL.PLLState        = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource       = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLMUL          = RCC_PLL_MUL6;
RCC_OscInitStruct.PLL.PLLDIV          = RCC_PLL_DIV3;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 );
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_1 );
void SysTick_Handler( void )
HAL_IncTick( );
void USB_LP_IRQHandler( void )
HAL_PCD_IRQHandler( &hpcd );
void assert_failed( uint8_t* file, uint32_t line )
while( 1 )
int main(void)
uint32_t index = 0;
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
LCD_Config();
while (1)
for (index = 0; index < 40; index++)
PicturesPosition(&Xpos1, &Ypos1, &Xpos2, &Ypos2, (index+1));
HAL_LTDC_SetWindowPosition_NoReload(&LtdcHandle, Xpos1, Ypos1, 0);
HAL_LTDC_SetWindowPosition_NoReload(&LtdcHandle, Xpos2, Ypos2, 1);
ReloadFlag = 0;
HAL_LTDC_Relaod(&LtdcHandle,LTDC_SRCR_VBR);
while(ReloadFlag == 0)
HAL_Delay(500);
for (index = 0; index < 40; index++)
PicturesPosition(&Xpos2, &Ypos2, &Xpos1, &Ypos1, (index+1));
HAL_LTDC_SetWindowPosition_NoReload(&LtdcHandle, Xpos1, Ypos1, 0);
HAL_LTDC_SetWindowPosition_NoReload(&LtdcHandle, Xpos2, Ypos2, 1);
ReloadFlag = 0;
HAL_LTDC_Relaod(&LtdcHandle,LTDC_SRCR_VBR);
while(ReloadFlag == 0)
HAL_Delay(500);
static void PicturesPosition(uint32_t* x1, uint32_t* y1, uint32_t* x2, uint32_t* y2, uint32_t index)
*x1 = 0;
*y1 = index*4;
*x2 = 0;
*y2 = 160 - index*4;
void HAL_LTDC_ReloadEventCallback(LTDC_HandleTypeDef *hltdc)
ReloadFlag = 1;
static void LCD_Config(void)
LTDC_LayerCfgTypeDef pLayerCfg;
LTDC_LayerCfgTypeDef pLayerCfg1;
ili9341_Init();
LtdcHandle.Init.HSPolarity = LTDC_HSPOLARITY_AL;
LtdcHandle.Init.VSPolarity = LTDC_VSPOLARITY_AL;
LtdcHandle.Init.DEPolarity = LTDC_DEPOLARITY_AL;
LtdcHandle.Init.PCPolarity = LTDC_PCPOLARITY_IPC;
LtdcHandle.Init.HorizontalSync = 9;
LtdcHandle.Init.VerticalSync = 1;
LtdcHandle.Init.AccumulatedHBP = 29;
LtdcHandle.Init.AccumulatedVBP = 3;
LtdcHandle.Init.AccumulatedActiveH = 323;
LtdcHandle.Init.AccumulatedActiveW = 269;
LtdcHandle.Init.TotalHeigh = 327;
LtdcHandle.Init.TotalWidth = 279;
LtdcHandle.Init.Backcolor.Blue = 0;
LtdcHandle.Init.Backcolor.Green = 0;
LtdcHandle.Init.Backcolor.Red = 0;
LtdcHandle.Instance = LTDC;
pLayerCfg.WindowX0 = 0;
pLayerCfg.WindowX1 = 240;
pLayerCfg.WindowY0 = 0;
pLayerCfg.WindowY1 = 160;
pLayerCfg.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
pLayerCfg.FBStartAdress = (uint32_t)&ST_LOGO_1;
pLayerCfg.Alpha = 255;
pLayerCfg.Alpha0 = 0;
pLayerCfg.Backcolor.Blue = 0;
pLayerCfg.Backcolor.Green = 0;
pLayerCfg.Backcolor.Red = 0;
pLayerCfg.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
pLayerCfg.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
pLayerCfg.ImageWidth = 240;
pLayerCfg.ImageHeight = 160;
pLayerCfg1.WindowX0 = 0;
pLayerCfg1.WindowX1 = 240;
pLayerCfg1.WindowY0 = 160;
pLayerCfg1.WindowY1 = 320;
pLayerCfg1.PixelFormat = LTDC_PIXEL_FORMAT_RGB565;
pLayerCfg1.FBStartAdress = (uint32_t)&ST_LOGO_2;
pLayerCfg1.Alpha = 200;
pLayerCfg1.Alpha0 = 0;
pLayerCfg1.Backcolor.Blue = 0;
pLayerCfg1.Backcolor.Green = 0;
pLayerCfg1.Backcolor.Red = 0;
pLayerCfg1.BlendingFactor1 = LTDC_BLENDING_FACTOR1_PAxCA;
pLayerCfg1.BlendingFactor2 = LTDC_BLENDING_FACTOR2_PAxCA;
pLayerCfg1.ImageWidth = 240;
pLayerCfg1.ImageHeight = 160;
if(HAL_LTDC_Init(&LtdcHandle) != HAL_OK)
Error_Handler();
if(HAL_LTDC_ConfigLayer(&LtdcHandle, &pLayerCfg, 0) != HAL_OK)
Error_Handler();
if(HAL_LTDC_ConfigLayer(&LtdcHandle, &pLayerCfg1, 1) != HAL_OK)
Error_Handler();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
HAL_RCC_OscConfig(&RCC_OscInitStruct);
HAL_PWREx_EnableOverDrive();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_LTDC;
PeriphClkInitStruct.PLLSAI.PLLSAIN = 192;
PeriphClkInitStruct.PLLSAI.PLLSAIR = 4;
PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);
static void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
static int link_test()
int ret = -1;
UINT32 uwRet = LOS_OK;
UINT32  handle;
TSK_INIT_PARAM_S task_init_param;
memset (&task_init_param, 0, sizeof (TSK_INIT_PARAM_S));
task_init_param.uwArg = (unsigned int)NULL;
task_init_param.usTaskPrio = 2;
task_init_param.pcName =(char *) "link_main";
task_init_param.pfnTaskEntry = (TSK_ENTRY_FUNC)link_main;
task_init_param.uwStackSize = 0x1000;
uwRet = LOS_TaskCreate(&handle, &task_init_param);
if(LOS_OK == uwRet){
ret = 0;
return ret;
int main(void)
UINT32 uwRet = LOS_OK;
HardWare_Init();
uwRet = LOS_KernelInit();
if (uwRet != LOS_OK)
return LOS_NOK;
extern void shell_uart_init(int baud);
shell_uart_init(115200);
link_test();
(void)LOS_Start();
return 0;
int main(void)
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED1);
BSP_LED_Init(LED2);
BSP_LED_Init(LED3);
BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);
if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET)
BSP_LED_On(LED1);
HAL_Delay(4000);
BSP_LED_Off(LED1);
__HAL_RCC_CLEAR_RESET_FLAGS();
uwLsiFreq = GetLSIFrequency();
IwdgHandle.Instance = IWDG;
IwdgHandle.Init.Prescaler = IWDG_PRESCALER_32;
IwdgHandle.Init.Reload = (uwLsiFreq / 32);
IwdgHandle.Init.Window = IWDG_WINDOW_DISABLE;
if(HAL_IWDG_Init(&IwdgHandle) != HAL_OK)
Error_Handler();
while (1)
BSP_LED_Toggle(LED2);
HAL_Delay(990);
if(HAL_IWDG_Refresh(&IwdgHandle) != HAL_OK)
Error_Handler();
static uint32_t GetLSIFrequency(void)
TIM_IC_InitTypeDef    TIMInput_Config;
RCC_OscInitTypeDef oscinit = {0};
oscinit.OscillatorType = RCC_OSCILLATORTYPE_LSI;
oscinit.LSIState = RCC_LSI_ON;
oscinit.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&oscinit)!= HAL_OK)
Error_Handler();
Input_Handle.Instance = TIM21;
Input_Handle.Init.Prescaler         = 0;
Input_Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
Input_Handle.Init.Period            = 0xFFFF;
Input_Handle.Init.ClockDivision     = 0;
if(HAL_TIM_IC_Init(&Input_Handle) != HAL_OK)
Error_Handler();
HAL_TIMEx_RemapConfig(&Input_Handle, TIM21_TI1_LSI);
TIMInput_Config.ICPolarity  = TIM_ICPOLARITY_RISING;
TIMInput_Config.ICSelection = TIM_ICSELECTION_DIRECTTI;
TIMInput_Config.ICPrescaler = TIM_ICPSC_DIV8;
TIMInput_Config.ICFilter    = 0;
if(HAL_TIM_IC_ConfigChannel(&Input_Handle, &TIMInput_Config, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if(HAL_TIM_IC_Start_IT(&Input_Handle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
while(uwCaptureNumber != 2)
HAL_TIM_IC_Stop_IT(&Input_Handle, TIM_CHANNEL_1);
HAL_TIM_IC_DeInit(&Input_Handle);
return uwLsiFreq;
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
RCC_OscInitStruct.MSIState = RCC_MSI_ON;
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;
RCC_OscInitStruct.MSICalibrationValue=0x00;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK)
while(1);
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK)
while(1);
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
__HAL_RCC_PWR_CLK_DISABLE();
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim)
uint32_t lsiperiod = 0;
tmpCC4[uwCaptureNumber++] = HAL_TIM_ReadCapturedValue(&Input_Handle, TIM_CHANNEL_1);
if (uwCaptureNumber >= 2)
lsiperiod = (uint16_t)(0xFFFF - tmpCC4[0] + tmpCC4[1] + 1);
uwLsiFreq = (uint32_t) SystemCoreClock / lsiperiod;
uwLsiFreq *= 8;
void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void assert_failed(uint8_t *file, uint32_t line)
while (1)
int main(void)
HAL_Init();
BSP_LED_Init(LED3);
BSP_LED_Init(LED4);
SystemClock_Config();
__HAL_RCC_PWR_CLK_ENABLE();
if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET)
__HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB);
BSP_LED_On(LED4);
BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);
while(BSP_PB_GetState(BUTTON_USER) != SET)
while(BSP_PB_GetState(BUTTON_USER) == SET)
while (1)
SleepMode_Measure();
StopMode_Measure();
StopUnderDriveMode_Measure();
StandbyMode_Measure();
StandbyRTCMode_Measure();
StandbyRTCBKPSRAMMode_Measure();
static void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_LSE;
RCC_OscInitStruct.LSEState = RCC_LSE_ON;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 360;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 7;
RCC_OscInitStruct.PLL.PLLR = 6;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if(HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
void Error_Handler(void)
BSP_LED_On(LED3);
while(1)
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc)
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin)
if(GPIO_Pin == USER_BUTTON_PIN)
void assert_failed(uint8_t* file, uint32_t line)
while (1)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 84;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOA_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_5;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_USART2_UART_Init();
MX_SPI1_Init();
MX_TIM2_Init();
MX_ADC_Init();
MX_DAC_Init();
MX_TIM1_Init();
MX_RTC_Init();
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI14|RCC_OSCILLATORTYPE_HSI48
|RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;
RCC_OscInitStruct.HSI14State = RCC_HSI14_ON;
RCC_OscInitStruct.HSI14CalibrationValue = 16;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_RTC;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
static void MX_ADC_Init(void)
ADC_ChannelConfTypeDef sConfig = {0};
hadc.Instance = ADC1;
hadc.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
hadc.Init.Resolution = ADC_RESOLUTION_12B;
hadc.Init.DataAlign = ADC_DATAALIGN_RIGHT;
hadc.Init.ScanConvMode = ADC_SCAN_DIRECTION_FORWARD;
hadc.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
hadc.Init.LowPowerAutoWait = DISABLE;
hadc.Init.LowPowerAutoPowerOff = DISABLE;
hadc.Init.ContinuousConvMode = DISABLE;
hadc.Init.DiscontinuousConvMode = DISABLE;
hadc.Init.ExternalTrigConv = ADC_SOFTWARE_START;
hadc.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
hadc.Init.DMAContinuousRequests = DISABLE;
hadc.Init.Overrun = ADC_OVR_DATA_PRESERVED;
if (HAL_ADC_Init(&hadc) != HAL_OK)
Error_Handler();
sConfig.Channel = ADC_CHANNEL_0;
sConfig.Rank = ADC_RANK_CHANNEL_NUMBER;
sConfig.SamplingTime = ADC_SAMPLETIME_1CYCLE_5;
if (HAL_ADC_ConfigChannel(&hadc, &sConfig) != HAL_OK)
Error_Handler();
static void MX_DAC_Init(void)
DAC_ChannelConfTypeDef sConfig = {0};
hdac.Instance = DAC;
if (HAL_DAC_Init(&hdac) != HAL_OK)
Error_Handler();
sConfig.DAC_Trigger = DAC_TRIGGER_NONE;
sConfig.DAC_OutputBuffer = DAC_OUTPUTBUFFER_ENABLE;
if (HAL_DAC_ConfigChannel(&hdac, &sConfig, DAC_CHANNEL_1) != HAL_OK)
Error_Handler();
void MX_IWDG_Init(void)
hiwdg.Instance = IWDG;
hiwdg.Init.Prescaler = IWDG_PRESCALER_16;
hiwdg.Init.Window = 4095;
hiwdg.Init.Reload = 4095;
if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
Error_Handler();
static void MX_RTC_Init(void)
hrtc.Instance = RTC;
hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
hrtc.Init.AsynchPrediv = 127;
hrtc.Init.SynchPrediv = 255;
hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
if (HAL_RTC_Init(&hrtc) != HAL_OK)
Error_Handler();
static void MX_SPI1_Init(void)
hspi1.Instance = SPI1;
hspi1.Init.Mode = SPI_MODE_MASTER;
hspi1.Init.Direction = SPI_DIRECTION_2LINES;
hspi1.Init.DataSize = SPI_DATASIZE_4BIT;
hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;
hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;
hspi1.Init.NSS = SPI_NSS_SOFT;
hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_8;
hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;
hspi1.Init.TIMode = SPI_TIMODE_DISABLE;
hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
hspi1.Init.CRCPolynomial = 7;
hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;
hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
if (HAL_SPI_Init(&hspi1) != HAL_OK)
Error_Handler();
static void MX_TIM1_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim1.Instance = TIM1;
htim1.Init.Prescaler = 0;
htim1.Init.CounterMode = TIM_COUNTERMODE_UP;
htim1.Init.Period = 65535;
htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim1.Init.RepetitionCounter = 0;
htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim1) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_TIM2_Init(void)
TIM_ClockConfigTypeDef sClockSourceConfig = {0};
TIM_MasterConfigTypeDef sMasterConfig = {0};
htim2.Instance = TIM2;
htim2.Init.Prescaler = 0;
htim2.Init.CounterMode = TIM_COUNTERMODE_UP;
htim2.Init.Period = 4294967295;
htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_Base_Init(&htim2) != HAL_OK)
Error_Handler();
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK)
Error_Handler();
static void MX_USART2_UART_Init(void)
huart2.Instance = USART2;
huart2.Init.BaudRate = 115200;
huart2.Init.WordLength = UART_WORDLENGTH_8B;
huart2.Init.StopBits = UART_STOPBITS_1;
huart2.Init.Parity = UART_PARITY_NONE;
huart2.Init.Mode = UART_MODE_TX_RX;
huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
huart2.Init.OverSampling = UART_OVERSAMPLING_16;
huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
if (HAL_UART_Init(&huart2) != HAL_OK)
Error_Handler();
static void MX_DMA_Init(void)
__HAL_RCC_DMA1_CLK_ENABLE();
HAL_NVIC_SetPriority(DMA1_Ch1_IRQn, 0, 0);
HAL_NVIC_EnableIRQ(DMA1_Ch1_IRQn);
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOC_CLK_ENABLE();
__HAL_RCC_GPIOA_CLK_ENABLE();
__HAL_RCC_GPIOB_CLK_ENABLE();
HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = USER_KEY_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;
GPIO_InitStruct.Pull = GPIO_NOPULL;
HAL_GPIO_Init(USER_KEY_GPIO_Port, &GPIO_InitStruct);
GPIO_InitStruct.Pin = LED_Pin;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
LCD1602_Begin4BIT(RS_GPIO_Port, RS_Pin, E_Pin, D4_GPIO_Port, D4_Pin, D5_Pin, D6_Pin, D7_Pin);
LCD1602_clear();
LCD1602_print("I'm hungry!!");
LCD1602_2ndLine();
LCD1602_print("I wanna go home!");
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;
RCC_OscInitStruct.PLL.PLLM = 8;
RCC_OscInitStruct.PLL.PLLN = 180;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK)
Error_Handler();
static void MX_GPIO_Init(void)
GPIO_InitTypeDef GPIO_InitStruct = {0};
__HAL_RCC_GPIOE_CLK_ENABLE();
__HAL_RCC_GPIOH_CLK_ENABLE();
HAL_GPIO_WritePin(GPIOE, GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6
|GPIO_PIN_7|GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET);
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6
|GPIO_PIN_7|GPIO_PIN_0|GPIO_PIN_1;
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
void Error_Handler(void)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART3_UART_Init();
MX_TIM2_Init();
HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);
while (1)
int i = 1000;
for (; i <= 2000; i += 50)
htim2.Instance->CCR1 = i;
HAL_Delay(100);
for (; i >= 1000; i -= 50)
htim2.Instance->CCR1 = i;
HAL_Delay(100);
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct = {0};
HAL_PWR_EnableBkUpAccess();
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 96;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 4;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;
PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
bool ledDisabled()
if (appIsGateway) {
return false;
if (ledIsPairInProgress() || ledIsPairMandatory()) {
return false;
if (MX_DBG_Enabled()) {
return false;
if (ledsEnabledMs == 0) {
ledsEnabledMs = TIMER_IF_GetTimeMs();
uint32_t ledDisableAtMs = ledsEnabledMs + (ledsEnabledMins * 60 * 1000);
if (TIMER_IF_GetTimeMs() >= ledDisableAtMs) {
return true;
return false;
void ledSet()
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET);
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);
void ledReset()
walkState = 0;
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
void ledWalk()
uint32_t c = (walkState++) % 4;
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, c == 0 ? GPIO_PIN_SET : GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, c == 1 || c == 3 ? GPIO_PIN_SET : GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, c == 2 ? GPIO_PIN_SET : GPIO_PIN_RESET);
bool ledIsPairMandatory()
return (memcmp(gatewayAddress, invalidAddress, sizeof(gatewayAddress)) == 0);
bool ledIsPairInProgress()
if (ledStatePairBeganTime > 0) {
if (!ledStatePairTimeWasValid && NoteTimeValidST()) {
ledStatePairBeganTime = NoteTimeST();
uint32_t timeoutSecs = 60*(appIsGateway ? var_gateway_pairing_timeout_mins : PAIRING_BEACON_SENSOR_TIMEOUT_MINS);
if (NoteTimeST() > ledStatePairBeganTime + timeoutSecs) {
ledIndicatePairInProgress(false);
if (appIsGateway) {
return ledStatePair;
if (ledStatePairBeganTime == 0 && ledIsPairMandatory()) {
ledIndicatePairInProgress(true);
return ledStatePair;
void ledIndicatePairInProgress(bool on)
ledStatePair = on;
ledStatePairBeganTime = on ? NoteTimeST() : 0;
ledStatePairTimeWasValid = NoteTimeValidST();
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, on ? GPIO_PIN_SET : GPIO_PIN_RESET);
APP_PRINTF("%s\\r\\n", on ? "pairing mode ON" : "pairing mode OFF");
bool ledIsReceiveInProgress()
return ledStateReceive;
void ledIndicateReceiveInProgress(bool on)
ledStateReceive = on;
if (ledDisabled()) {
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_RESET);
} else {
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, on ? GPIO_PIN_SET : GPIO_PIN_RESET);
bool ledIsTransmitInProgress()
return ledStateTransmit;
void ledIndicateTransmitInProgress(bool on)
ledStateTransmit = on;
if (ledDisabled()) {
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET);
} else {
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, on ? GPIO_PIN_SET : GPIO_PIN_RESET);
void ledIndicateAck(int flashes)
for (int i=0; i<flashes; i++) {
ledSet();
HAL_Delay(250);
ledReset();
HAL_Delay(250);
uint16_t ledButtonCheck()
if (HAL_GPIO_ReadPin(BUTTON1_GPIO_Port, BUTTON1_Pin) == (BUTTON1_ACTIVE_HIGH ? GPIO_PIN_RESET : GPIO_PIN_SET)) {
return BUTTON_UNCHANGED;
ledsEnabledMs = TIMER_IF_GetTimeMs();
bool redWasOn = HAL_GPIO_ReadPin(LED_RED_GPIO_Port, LED_RED_Pin) != GPIO_PIN_RESET;
bool greenWasOn = HAL_GPIO_ReadPin(LED_GREEN_GPIO_Port, LED_GREEN_Pin) != GPIO_PIN_RESET;
bool blueWasOn = HAL_GPIO_ReadPin(LED_BLUE_GPIO_Port, LED_BLUE_Pin) != GPIO_PIN_RESET;
int flashes = 0;
uint32_t beganSecs = NoteTimeST();
uint32_t expireSecs = 15;
uint32_t currentDelayMs = 750;
uint32_t prevQuartile = 0;
while (NoteTimeST() < beganSecs+expireSecs) {
if (HAL_GPIO_ReadPin(BUTTON1_GPIO_Port, BUTTON1_Pin) == (BUTTON1_ACTIVE_HIGH ? GPIO_PIN_RESET : GPIO_PIN_SET)) {
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, redWasOn ? GPIO_PIN_SET : GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, greenWasOn ? GPIO_PIN_SET : GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, blueWasOn ? GPIO_PIN_SET : GPIO_PIN_RESET);
return (flashes < 2) ? BUTTON_PRESSED : BUTTON_HOLD_ABORTED;
if (flashes >= 1) {
HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, (flashes & 1) ? GPIO_PIN_SET : GPIO_PIN_RESET);
HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, (flashes & 1) ? GPIO_PIN_RESET : GPIO_PIN_SET);
HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, (flashes & 1) ? GPIO_PIN_SET : GPIO_PIN_RESET);
uint32_t elapsed = NoteTimeST() - beganSecs;
uint32_t quartile = elapsed / (expireSecs/4);
if (prevQuartile != quartile) {
prevQuartile = quartile;
currentDelayMs -= currentDelayMs < 250 ? 0 : 200;
HAL_Delay(currentDelayMs);
flashes++;
return BUTTON_HELD;
bool noteInit()
NoteSetFn(malloc, free, noteDelay, noteMillis);
NoteSetFnMutex(NULL, NULL, noteBeginTransaction, noteEndTransaction);
NoteSetFnI2C(NOTE_I2C_ADDR_DEFAULT, NOTE_I2C_MAX_DEFAULT, noteI2CReset, noteI2CTransmit, noteI2CReceive);
if (!NoteReset()) {
NoteSetFnMutex(NULL, NULL, NULL,NULL);
NoteSetFnDisabled();
MX_I2C2_DeInit();
return false;
return true;
bool noteSetup()
bool initialized = false;
for (int i=0; i<5; i++) {
const char *productUID = NOTECARD_PRODUCT_UID;
bool messageDisplayed = false;
while (NOTECARD_PRODUCT_UID[0] == '\\0') {
NoteSuspendTransactionDebug();
J *rsp = NoteRequestResponse(NoteNewRequest("hub.get"));
NoteResumeTransactionDebug();
if (rsp != NULL) {
if (JGetString(rsp, "product")[0] != '\\0') {
productUID = NULL;
NoteDeleteResponse(rsp);
break;
if (!messageDisplayed) {
APP_PRINTF("\\r\\n");
APP_PRINTF("Waiting for you to set product UID of this gateway using:\\r\\n");
APP_PRINTF("{\\"req\\":\\"hub.set\\",\\"product\\":\\"your-notehub-project's-ProductID\\"}\\r\\n");
APP_PRINTF("\\r\\n");
messageDisplayed = true;
} else {
APP_PRINTF("^");
HAL_Delay(2500);
if (messageDisplayed) {
APP_PRINTF("\\r\\n");
J *req = NoteNewRequest("hub.set");
if (req != NULL) {
if (productUID != NULL) {
JAddStringToObject(req, "product", productUID);
JAddStringToObject(req, "mode", NOTECARD_CONNECTION_MODE);
JAddNumberToObject(req, "outbound", NOTECARD_OUTBOUND_PERIOD_MINS);
JAddNumberToObject(req, "inbound", NOTECARD_INBOUND_PERIOD_MINS);
JAddBoolToObject(req, "sync", NOTECARD_CONTINUOUS_SYNC);
JAddBoolToObject(req, "align", true);
if (NoteRequest(req)) {
initialized = true;
break;
HAL_Delay(1000);
J *req = NoteNewRequest("dfu.status");
if (req != NULL) {
JAddStringToObject(req, "version", appFirmwareVersion());
NoteRequest(req);
return initialized;
void noteBeginTransaction()
MX_I2C2_Init();
void noteEndTransaction()
MX_I2C2_DeInit();
void noteDelay(uint32_t ms)
HAL_Delay(ms);
long unsigned int noteMillis()
return (long unsigned int) TIMER_IF_GetTimeMs();
bool noteI2CReset(uint16_t DevAddress)
MX_I2C2_DeInit();
MX_I2C2_Init();
return true;
const char *noteI2CTransmit(uint16_t DevAddress, uint8_t* pBuffer, uint16_t Size)
char *errstr;
int writelen = sizeof(uint8_t) + Size;
uint8_t *writebuf = malloc(writelen);
if (writebuf == NULL) {
return "i2c: insufficient memory (write)";
writebuf[0] = Size;
memcpy(&writebuf[1], pBuffer, Size);
errstr = "i2c: write error {io}";
for (int i=0; i<5; i++) {
HAL_StatusTypeDef err_code = HAL_I2C_Master_Transmit(&hi2c2, DevAddress<<1, writebuf, writelen, 250);
if (err_code == HAL_OK) {
errstr = NULL;
break;
HAL_Delay(100);
if (errstr != NULL) {
free(writebuf);
return errstr;
free(writebuf);
return NULL;
const char *noteI2CReceive(uint16_t DevAddress, uint8_t* pBuffer, uint16_t Size, uint32_t *available)
const char *errstr;
uint8_t hdr[2];
hdr[0] = (uint8_t) 0;
hdr[1] = (uint8_t) Size;
errstr = "i2c: write error {io}";
for (int i=0; i<5; i++) {
HAL_StatusTypeDef err_code = HAL_I2C_Master_Transmit(&hi2c2, DevAddress<<1, hdr, sizeof(hdr), 250);
if (err_code == HAL_OK) {
errstr = NULL;
break;
HAL_Delay(100);
if (errstr != NULL) {
return errstr;
int readlen = Size + (sizeof(uint8_t)*2);
uint8_t *readbuf = malloc(readlen);
if (readbuf == NULL) {
return "i2c: insufficient memory (read)";
errstr = "i2c: read error {io}";
for (int i=0; i<5; i++) {
HAL_StatusTypeDef err_code = HAL_I2C_Master_Receive(&hi2c2, DevAddress<<1, readbuf, readlen, 10);
if (err_code == HAL_OK) {
errstr = NULL;
break;
HAL_Delay(100);
if (errstr != NULL) {
free(readbuf);
return errstr;
uint8_t availbyte = readbuf[0];
uint8_t goodbyte = readbuf[1];
if (goodbyte != Size) {
free(readbuf);
return "i2c: incorrect amount of data";
*available = availbyte;
memcpy(pBuffer, &readbuf[2], Size);
free(readbuf);
return NULL;
void noteSendToGatewayAsync(J *req, bool responseExpected)
if (NoteTimeValidST()) {
JAddNumberToObject(req, "time", NoteTimeST());
sensorSendReqToGateway(req, responseExpected);
void CALENDAR_Init( CALENDAR_InfoStruct *pInfoStruct )
RTC_DateTypeDef sdatestructure;
RTC_TimeTypeDef stimestructure;
RtcHandle.Instance = RTC;
RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24;
RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV;
RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV;
RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE;
RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
__HAL_RTC_RESET_HANDLE_STATE(&RtcHandle);
if (HAL_RTC_Init(&RtcHandle) != HAL_OK)
Error_Handler();
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
if( pInfoStruct != NULL )
sdatestructure.Year = pInfoStruct->year;
sdatestructure.Month = pInfoStruct->month;
sdatestructure.Date = pInfoStruct->day;
sdatestructure.WeekDay = pInfoStruct->weekday;
stimestructure.Hours = pInfoStruct->hours;
stimestructure.Minutes = pInfoStruct->minutes;
stimestructure.Seconds = pInfoStruct->seconds;
stimestructure.SubSeconds = 0;
stimestructure.SecondFraction = 0;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
configure_calendar(&sdatestructure, &stimestructure);
else
if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1) != 0x32F2)
sdatestructure.Year = 0x18;
sdatestructure.Month = RTC_MONTH_MAY;
sdatestructure.Date = 0x12;
sdatestructure.WeekDay = RTC_WEEKDAY_SATURDAY;
stimestructure.Hours = 0x02;
stimestructure.Minutes = 0x00;
stimestructure.Seconds = 0x00;
stimestructure.SubSeconds = 0;
stimestructure.SecondFraction = 0;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
configure_calendar(&sdatestructure, &stimestructure);
else
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET)
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12);
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET)
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13);
__HAL_RCC_CLEAR_RESET_FLAGS();
void CALENDAR_setDateTime( CALENDAR_InfoStruct *pInfoStruct )
RTC_DateTypeDef sdatestructure;
RTC_TimeTypeDef stimestructure;
sdatestructure.Year = pInfoStruct->year;
sdatestructure.Month = pInfoStruct->month;
sdatestructure.Date = pInfoStruct->day;
sdatestructure.WeekDay = pInfoStruct->weekday;
stimestructure.Hours = pInfoStruct->hours;
stimestructure.Minutes = pInfoStruct->minutes;
stimestructure.Seconds = pInfoStruct->seconds;
stimestructure.TimeFormat = RTC_HOURFORMAT12_AM;
stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE ;
stimestructure.StoreOperation = RTC_STOREOPERATION_RESET;
configure_calendar(&sdatestructure, &stimestructure);
void CALENDAR_getDate( char *pDateString )
RTC_DateTypeDef sdatestructureget;
HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);
sprintf((char *)pDateString, "%2d-%2d-%2d", sdatestructureget.Date, sdatestructureget.Month, 2000 + sdatestructureget.Year);
void CALENDAR_getTime( char *pTimeString )
RTC_TimeTypeDef stimestructureget;
HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);
sprintf((char *)pTimeString, "%2d:%2d:%2d", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc)
RCC_OscInitTypeDef        RCC_OscInitStruct;
RCC_PeriphCLKInitTypeDef  PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
HAL_PWR_EnableBkUpAccess();
RCC_OscInitStruct.OscillatorType =  RCC_OSCILLATORTYPE_LSI;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;
RCC_OscInitStruct.LSIState = RCC_LSI_ON;
if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC;
PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;
if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
Error_Handler();
__HAL_RCC_RTC_ENABLE();
void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc)
__HAL_RCC_RTC_DISABLE();
HAL_PWR_DisableBkUpAccess();
__HAL_RCC_PWR_CLK_DISABLE();
static void configure_calendar( RTC_DateTypeDef *pDateStruct, RTC_TimeTypeDef *pTimeStruct)
if(HAL_RTC_SetDate(&RtcHandle, pDateStruct, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
if (HAL_RTC_SetTime(&RtcHandle, pTimeStruct, RTC_FORMAT_BCD) != HAL_OK)
Error_Handler();
HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2);
static void Error_Handler(void)
HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_14);
while(1);
int main(void)
initialise_monitor_handles();
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_USART3_UART_Init();
MX_I2C1_Init();
int err=-1;
float ax,ay,az,gx,gy,gz;
printf("START...\\n\\r");
while (err!=0)   {
err=imu_init();
if (err==0)
printf("Inizializzazione IMU ok...\\n\\r");
else
err = imu_init();
uint32_t tick=0,last=0;
for(int i=0;i<3;i++)   {
imu_read();
ax=imu.acc.x*1000;
ay=imu.acc.y*1000;
az=imu.acc.z*1000;
gx=imu.gyr.x*1000;
gy=imu.gyr.y*1000;
gz=imu.gyr.z*1000;
printf("L'accelerazione lungo x e': %f\\n\\r",ax);
printf("L'accelerazione lungo y e': %f\\n\\r",ay);
printf("L'accelerazione lungo z e': %f\\n\\r",az);
printf("Il rollio     (roll)  e': %f \\n\\r",gx);
printf("Il beccheggio (pitch) e': %f \\n\\r",gy);
printf("L' imbardata  (yaw)   e': %f \\n\\r",gz);
do   {
tick=HAL_GetTick();
while(tick-last<1);
last=tick;
printf("%d   %d\\n\\r",tick,last);
while (1)
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct;
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_PeriphCLKInitTypeDef PeriphClkInitStruct;
__HAL_RCC_PWR_CLK_ENABLE();
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 4;
RCC_OscInitStruct.PLL.PLLN = 216;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 3;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
if (HAL_PWREx_EnableOverDrive() != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_I2C1;
PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;
PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK)
_Error_Handler(__FILE__, __LINE__);
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
void _Error_Handler(char *file, int line)
while(1)
void assert_failed(uint8_t* file, uint32_t line)
static int app_msg_deal(void *usr_data, en_oc_lwm2m_msg_t type, void *data, int len)
unsigned char *msg;
msg = data;
int ret = -1;
if(len <= cn_app_rcv_buf_len)
if (msg[0] == 0xaa && msg[1] == 0xaa)
printf("OC respond message received! \\n\\r");
return ret;
memcpy(s_rcv_buffer,msg,len);
s_rcv_datalen = len;
osal_semp_post(s_rcv_sync);
ret = 0;
return ret;
static int app_report_task_entry()
int ret = -1;
oc_config_param_t      oc_param;
memset(&oc_param,0,sizeof(oc_param));
oc_param.app_server.address = cn_app_server;
oc_param.app_server.port = cn_app_port;
oc_param.app_server.ep_id = cn_endpoint_id;
oc_param.boot_mode = en_oc_boot_strap_mode_factory;
oc_param.rcv_func = app_msg_deal;
ret = oc_lwm2m_config( &oc_param);
if (0 != ret)
return ret;
while(1)
Manhole_Cover.messageId = cn_app_Manhole_Cover;
Manhole_Cover.Temperature = (int)E53_SC2_Data.Temperature;
Manhole_Cover.Accel_x = htons(E53_SC2_Data.Accel[0] & 0x0000FFFF);
Manhole_Cover.Accel_y = htons(E53_SC2_Data.Accel[1] & 0x0000FFFF);
Manhole_Cover.Accel_z = htons(E53_SC2_Data.Accel[2] & 0x0000FFFF);
oc_lwm2m_report((char *)&Manhole_Cover, sizeof(Manhole_Cover), 1000);
osal_task_sleep(2*1000);
return ret;
static int app_collect_task_entry()
Init_E53_SC2();
while (1)
E53_SC2_Read_Data();
printf("\\r\\n******************************Temperature      is  %d\\r\\n", (int)E53_SC2_Data.Temperature);
printf("\\r\\n******************************Accel[0]         is  %d\\r\\n", (int)E53_SC2_Data.Accel[0]);
printf("\\r\\n******************************Accel[1]         is  %d\\r\\n", (int)E53_SC2_Data.Accel[1]);
printf("\\r\\n******************************Accel[2]         is  %d\\r\\n", (int)E53_SC2_Data.Accel[2]);
if( X == 0 && Y == 0 && Z == 0)
X = (int)E53_SC2_Data.Accel[0];
Y = (int)E53_SC2_Data.Accel[1];
Z = (int)E53_SC2_Data.Accel[2];
else
if(X+100<E53_SC2_Data.Accel[0]||X-100>E53_SC2_Data.Accel[0]||Y+100<E53_SC2_Data.Accel[1]||Y-100>E53_SC2_Data.Accel[1]||Z+100<E53_SC2_Data.Accel[2]||Z-100>E53_SC2_Data.Accel[2])
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_SET);
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9,GPIO_PIN_RESET);
Manhole_Cover.Status[0] = ' ';
Manhole_Cover.Status[1] = 'T';
Manhole_Cover.Status[2] = 'i';
Manhole_Cover.Status[3] = 'l';
Manhole_Cover.Status[4] = 't';
else
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_RESET);
HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9,GPIO_PIN_SET);
Manhole_Cover.Status[0] = 'L';
Manhole_Cover.Status[1] = 'e';
Manhole_Cover.Status[2] = 'v';
Manhole_Cover.Status[3] = 'e';
Manhole_Cover.Status[4] = 'l';
LCD_ShowString(10, 135, 200, 16, 16, "Temperature:");
LCD_ShowNum(140, 135, (int)E53_SC2_Data.Temperature, 5, 16);
LCD_ShowString(10, 160, 200, 16, 16, "Acce_X:");
LCD_ShowNum(140, 160, (int)E53_SC2_Data.Accel[0], 5, 16);
LCD_ShowString(10, 185, 200, 16, 16, "Acce_Y:");
LCD_ShowNum(140, 185, (int)E53_SC2_Data.Accel[1], 5, 16);
LCD_ShowString(10, 210, 200, 16, 16, "Acce_Z:");
LCD_ShowNum(140, 210, (int)E53_SC2_Data.Accel[2], 5, 16);
osal_task_sleep(2*1000);
return 0;
int standard_app_demo_main()
LCD_Clear(BLACK);
POINT_COLOR = GREEN;
LCD_ShowString(10, 10, 200, 16, 24, "Welcome to BearPi");
LCD_ShowString(30, 40, 200, 16, 24, "Manhole Demo");
LCD_ShowString(10, 80, 200, 16, 16, "NCDP_IP:");
LCD_ShowString(80, 80, 200, 16, 16, cn_app_server);
LCD_ShowString(10, 110, 200, 16, 16, "NCDP_PORT:");
LCD_ShowString(100, 110, 200, 16, 16, cn_app_port);
osal_semp_create(&s_rcv_sync,1,0);
osal_task_create("app_collect",app_collect_task_entry,NULL,0x400,NULL,3);
osal_task_create("app_report",app_report_task_entry,NULL,0x1000,NULL,2);
return 0;
bool uartInit(void)
for (int i=0; i<UART_MAX_CH; i++)
uart_tbl[i].is_open = false;
uart_tbl[i].baud = 57600;
return true;
bool uartOpen(uint8_t ch, uint32_t baud)
bool ret = false;
switch(ch)
case _DEF_UART1:
uart_tbl[ch].p_huart   = &huart3;
uart_tbl[ch].p_hdma_rx = &hdma_usart3_rx;
uart_tbl[ch].p_huart->Instance         = USART3;
uart_tbl[ch].p_huart->Init.BaudRate    = baud;
uart_tbl[ch].p_huart->Init.WordLength  = UART_WORDLENGTH_8B;
uart_tbl[ch].p_huart->Init.StopBits    = UART_STOPBITS_1;
uart_tbl[ch].p_huart->Init.Parity      = UART_PARITY_NONE;
uart_tbl[ch].p_huart->Init.Mode        = UART_MODE_TX_RX;
uart_tbl[ch].p_huart->Init.HwFlowCtl   = UART_HWCONTROL_NONE;
uart_tbl[ch].p_huart->Init.OverSampling= UART_OVERSAMPLING_16;
HAL_UART_DeInit(uart_tbl[ch].p_huart);
qbufferCreate(&uart_tbl[ch].qbuffer, &rx_buf[0][0], UART_MAX_BUF_SIZE);
__HAL_RCC_DMA1_CLK_ENABLE();
if (HAL_UART_Init(uart_tbl[ch].p_huart) != HAL_OK)
ret = false;
else
ret = true;
uart_tbl[ch].is_open = true;
if(HAL_UART_Receive_DMA(uart_tbl[ch].p_huart, (uint8_t *)&rx_buf[0][0], UART_MAX_BUF_SIZE) != HAL_OK)
ret = false;
uart_tbl[ch].qbuffer.in  = uart_tbl[ch].qbuffer.len -  ((DMA_Stream_TypeDef *)hdma_usart3_rx.Instance)->NDTR;
uart_tbl[ch].qbuffer.out = uart_tbl[ch].qbuffer.in;
break;
return ret;
bool uartClose(uint8_t ch)
return true;
uint32_t uartAvailable(uint8_t ch)
uint32_t ret = 0;
switch(ch)
case _DEF_UART1:
uart_tbl[ch].qbuffer.in = (uart_tbl[ch].qbuffer.len - ((DMA_Stream_TypeDef *)uart_tbl[ch].p_hdma_rx->Instance)->NDTR);
ret = qbufferAvailable(&uart_tbl[ch].qbuffer);
break;
return ret;
uint8_t uartRead(uint8_t ch)
uint8_t ret = 0;
switch(ch)
case _DEF_UART1:
qbufferRead(&uart_tbl[ch].qbuffer, &ret, 1);
break;
return ret;
uint32_t uartWrite(uint8_t ch, uint8_t *p_data, uint32_t length)
uint32_t ret = 0;
switch(ch)
case _DEF_UART1:
if (HAL_UART_Transmit(uart_tbl[ch].p_huart, p_data, length, 100) == HAL_OK)
ret = length;
break;
return ret;
uint32_t uartPrintf(uint8_t ch, char *fmt, ...)
char buf[256];
va_list args;
int len;
uint32_t ret;
va_start(args, fmt);
len = vsnprintf(buf, 256, fmt, args);
ret = uartWrite(ch, (uint8_t *)buf, len);
va_end(args);
return ret;
uint32_t uartGetBaud(uint8_t ch)
uint32_t ret = 0;
switch(ch)
case _DEF_UART1:
ret = uart_tbl[ch].baud;
break;
return ret;
void HAL_UART_ErrorCallback(UART_HandleTypeDef *huart)
if (huart->Instance == USART1)
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
if (huart->Instance == USART1)
qbufferWrite(&qbuffer[_DEF_UART2], &rx_data[_DEF_UART2], 1);
HAL_UART_Receive_IT(&huart1, (uint8_t *)&rx_data[_DEF_UART2], 1);
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
GPIO_InitTypeDef GPIO_InitStruct = {0};
if(uartHandle->Instance==USART3)
__HAL_RCC_USART3_CLK_ENABLE();
__HAL_RCC_GPIOD_CLK_ENABLE();
GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
GPIO_InitStruct.Pull = GPIO_NOPULL;
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
hdma_usart3_rx.Instance = DMA1_Stream0;
hdma_usart3_rx.Init.Request = DMA_REQUEST_USART3_RX;
hdma_usart3_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
hdma_usart3_rx.Init.PeriphInc = DMA_PINC_DISABLE;
hdma_usart3_rx.Init.MemInc = DMA_MINC_ENABLE;
hdma_usart3_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
hdma_usart3_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
hdma_usart3_rx.Init.Mode = DMA_CIRCULAR;
hdma_usart3_rx.Init.Priority = DMA_PRIORITY_LOW;
hdma_usart3_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
if (HAL_DMA_Init(&hdma_usart3_rx) != HAL_OK)
Error_Handler();
__HAL_LINKDMA(uartHandle,hdmarx,hdma_usart3_rx);
void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
if(uartHandle->Instance==USART3)
__HAL_RCC_USART3_CLK_DISABLE();
HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9);
HAL_DMA_DeInit(uartHandle->hdmarx);
int main(void)
HAL_Init();
SystemClock_Config();
MX_GPIO_Init();
MX_DMA_Init();
MX_I2C1_Init();
MX_USART2_UART_Init();
while (1)
StateMachineHandle();
void SystemClock_Config(void)
RCC_OscInitTypeDef RCC_OscInitStruct = {0};
RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.HSIState = RCC_HSI_ON;
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;
RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
Error_Handler();
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
Error_Handler();
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1;
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
Error_Handler();
void Error_Handler(void)
__disable_irq();
while (1)
void assert_failed(uint8_t *file, uint32_t line)
int main(void)
MPU_Config();
CPU_CACHE_Enable();
HAL_Init();
SystemClock_Config();
BSP_LED_Init(LED3);
TimMasterHandle.Instance = TIM1;
TimSlave1Handle.Instance = TIM3;
TimSlave2Handle.Instance = TIM4;
TimMasterHandle.Init.Period            = 255;
TimMasterHandle.Init.Prescaler         = 0;
TimMasterHandle.Init.ClockDivision     = 0;
TimMasterHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimMasterHandle.Init.RepetitionCounter = 4;
TimMasterHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimMasterHandle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode       = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity   = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse        = 127;
sOCConfig.OCNPolarity  = TIM_OCNPOLARITY_HIGH;
sOCConfig.OCFastMode   = TIM_OCFAST_DISABLE;
sOCConfig.OCIdleState  = TIM_OCIDLESTATE_RESET;
sOCConfig.OCNIdleState = TIM_OCNIDLESTATE_RESET;
if (HAL_TIM_PWM_ConfigChannel(&TimMasterHandle, &sOCConfig, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sMasterConfig.MasterOutputTrigger = TIM_TRGO_UPDATE;
sMasterConfig.MasterSlaveMode     = TIM_MASTERSLAVEMODE_ENABLE;
if (HAL_TIMEx_MasterConfigSynchronization(&TimMasterHandle, &sMasterConfig) != HAL_OK)
Error_Handler();
TimSlave1Handle.Init.Period            = 2;
TimSlave1Handle.Init.Prescaler         = 0;
TimSlave1Handle.Init.ClockDivision     = 0;
TimSlave1Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimSlave1Handle.Init.RepetitionCounter = 0;
TimSlave1Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimSlave1Handle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode     = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse = 1;
if (HAL_TIM_PWM_ConfigChannel(&TimSlave1Handle, &sOCConfig, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode        = TIM_SLAVEMODE_GATED;
sSlaveConfig.InputTrigger     = TIM_TS_ITR0;
sSlaveConfig.TriggerPolarity  = TIM_TRIGGERPOLARITY_NONINVERTED;
sSlaveConfig.TriggerPrescaler = TIM_TRIGGERPRESCALER_DIV1;
sSlaveConfig.TriggerFilter    = 0;
if (HAL_TIM_SlaveConfigSynchronization(&TimSlave1Handle, &sSlaveConfig) != HAL_OK)
Error_Handler();
TimSlave2Handle.Init.Period            = 1;
TimSlave2Handle.Init.Prescaler         = 0;
TimSlave2Handle.Init.ClockDivision     = 0;
TimSlave2Handle.Init.CounterMode       = TIM_COUNTERMODE_UP;
TimSlave2Handle.Init.RepetitionCounter = 0;
TimSlave2Handle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
if (HAL_TIM_PWM_Init(&TimSlave2Handle) != HAL_OK)
Error_Handler();
sOCConfig.OCMode     = TIM_OCMODE_PWM1;
sOCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;
sOCConfig.Pulse = 1;
if (HAL_TIM_PWM_ConfigChannel(&TimSlave2Handle, &sOCConfig, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
sSlaveConfig.SlaveMode     = TIM_SLAVEMODE_GATED;
sSlaveConfig.InputTrigger  = TIM_TS_ITR0;
if (HAL_TIM_SlaveConfigSynchronization(&TimSlave2Handle, &sSlaveConfig) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimMasterHandle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimSlave1Handle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
if (HAL_TIM_PWM_Start(&TimSlave2Handle, TIM_CHANNEL_1) != HAL_OK)
Error_Handler();
while (1)
static void Error_Handler(void)
BSP_LED_On(LED3);
while (1)
void SystemClock_Config(void)
RCC_ClkInitTypeDef RCC_ClkInitStruct;
RCC_OscInitTypeDef RCC_OscInitStruct;
HAL_StatusTypeDef ret = HAL_OK;
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
RCC_OscInitStruct.HSEState = RCC_HSE_ON;
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
RCC_OscInitStruct.PLL.PLLM = 25;
RCC_OscInitStruct.PLL.PLLN = 432;
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;
RCC_OscInitStruct.PLL.PLLQ = 9;
ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);
if(ret != HAL_OK)
while(1) { ; }
ret = HAL_PWREx_EnableOverDrive();
if(ret != HAL_OK)
while(1) { ; }
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;
ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);
if(ret != HAL_OK)
while(1) { ; }
