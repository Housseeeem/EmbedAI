code,comment
(HAL_RNG_Init(&hrng)  != HAL_OK);,Return status of RNG initialization function
if  (GPIO_Pin == BUTTON_USER_PIN) { ubUserButtonClickEvent = SET; },Action to be taken when the user button is clicked
(HAL_Delay(500));,Function call for delay of 500ms
BSP_LED_Toggle(LED9);,Function call to toggle LED9
if (GPIO_Pin == BUTTON_USER_PIN) { ubUserButtonClickEvent = SET; RNGStatus = 1;},"Action to be taken when the user button is clicked, setting UserButtonClickEvent and enabling RNG status"
(HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin));,Function call for rising edge EXTI line detection callbacks
if (GPIO_Pin == BUTTON_USER_PIN) { ubUserButtonClickEvent = SET; },"Action to be taken when the user button is clicked, setting UserButtonClickEvent"
(BSP_LED_Toggle(LED9));,Function call to toggle LED9
HAL_Delay(500);,Function call for delay of 500ms in the infinite loop after error handling
"HAL_GPIO_Init(GPIOE, &GPIOE_InitStruct);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET);",This line is used to reset or turn off the LED.
__disable_irq(); while 1: {},This block of code acts as an error handler and will make the program enter an infinite loop until a reset occurs.
void Error_Handler(void) { __disable_irq(); while (1) {} },"This function is executed when an error occurs. The program will enter an infinite loop until a reset occurs, effectively handling any errors in the code."
HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),This function is a callback for EXTI line detection.
"LCD_DrawRectangle( 12, 8, 227, 152);",drawing border
"LCD_DrawLine( 0, 80, 239, 80);",centre line
"if(Ladc3 > 695) { LCD_ShowString( 20, 270, 240, 16, 16, ""pen down""); penState = 1; } else { LCD_ShowString( 20, 270, 240, 16, 16, ""pen up      ""); penState = 0; }",detemine whether the pen is down
"asm330lhh_device_id_get(&dev_ctx, &whoamI); if (whoamI != ASM330LHH_ID) while(1);",Check device ID.
"asm330lhh_xl_data_rate_set(&dev_ctx, ASM330LHH_XL_ODR_417Hz);",Set XL Output Data Rate to 416 Hz.
"asm330lhh_xl_full_scale_set(&dev_ctx, ASM330LHH_2g);",Set 2g full XL scale.
"asm330lhh_xl_hp_path_internal_set(&dev_ctx, ASM330LHH_USE_SLOPE);",Apply high-pass digital filter on Wake-Up function.
"asm330lhh_wkup_threshold_set(&dev_ctx, 2);",Set Wake-Up threshold: 1 LSb corresponds to FS_XL/2^6.
"asm330lhh_pin_int1_route_get(&dev_ctx, &int1_route); int1_route.md1_cfg.int1_wu = PROPERTY_ENABLE; asm330lhh_pin_int1_route_set(&dev_ctx, &int1_route);",Enable interrupt generation on Wake-Up INT1 pin.
"while (1) { HAL_Delay(2000); printf(""loop %d\r\n"",counter); counter++; }",Infinite loop
BSP_LED_Init(LED2);,Initialize LEDs mounted on STM32L073-Nucleo Rev A board
EXTI4_15_IRQHandler_Config();,Configure External lines 4 to 15 (connected to PC.13 pin) in interrupt mode
static void EXTI4_15_IRQHandler_Config(void) { ... },Configures EXTI lines 4 to 15 (connected to PC.13 pin) in interrupt mode
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if (GPIO_Pin == GPIO_PIN_13) { BSP_LED_Toggle(LED2); } },EXTI line detection callbacks
static void SendMail (void const *arg) { ... },Thread 'SendMail': Send an email
static void BlinkLed (void const *arg) { ... },Thread 'BlinkLed': Blink the LEDs on an eval board
int fgetc(FILE *f) { ... },Place your implementation of fgetc here
void board_init(void) { ... },board_init
"void NVIC_SetVectorTable(uint32_t NVIC_VectTab, uint32_t Offset) { assert_param(IS_NVIC_VECTTAB(NVIC_VectTab)); assert_param(IS_NVIC_OFFSET(Offset)); SCB->VTOR = NVIC_VectTab | (Offset & (uint32_t)0x1FFFFF80); }",Check the parameters
BSP_LED_Init(LED1); BSP_LED_Init(LED2);,Configure LED1 and LED2
MPU_AccessPermConfig();,Set MPU regions
BSP_LED_Toggle(LED1); HAL_Delay(100);,Toggle LED1
"if (HAL_CAN_Start(&hcan1) != HAL_OK) { printf(""start error\r\n""); }",Start Error
bool uartInit(void) { uint8_t i; for (i=0; i<UART_MAX_CH; i++) { uart_tbl[i].is_open = false; uart_tbl[i].rx_mode = UART_MODE_POLLING; uart_tbl[i].tx_mode = UART_MODE_POLLING; uart_tbl[i].tx_done = false; uart_tbl[i].txDoneISR = NULL; uart_tbl[i].err_cnt = 0; uart_tbl[i].hw_driver = UART_HW_NONE; } return true; },Initialize UART
"bool uartOpen(uint8_t channel, uint32_t baud) { bool ret = false; uart_t *p_uart; if (channel >= UART_MAX_CH) { return false; } switch(channel) { case _DEF_UART1: p_uart = &uart_tbl[channel]; p_uart->baud = baud; p_uart->hw_driver = UART_HW_STM32_UART; p_uart->rx_mode = UART_MODE_DMA; p_uart->tx_mode = UART_MODE_POLLING; p_uart->hdma_rx = &hdma_usart2_rx; p_uart->handle = &huart2; p_uart->handle->Instance = USART2; p_uart->handle->Init.BaudRate = baud; p_uart->handle->Init.WordLength = UART_WORDLENGTH_8B; p_uart->handle->Init.StopBits = UART_STOPBITS_1; p_uart->handle->Init.Parity = UART_PARITY_NONE; p_uart->handle->Init.Mode = UART_MODE_TX_RX; p_uart->handle->Init.HwFlowCtl = UART_HWCONTROL_NONE; p_uart->handle->Init.OverSampling = UART_OVERSAMPLING_16; p_uart->handle->Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; p_uart->handle->AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; qbufferCreate(&p_uart->qbuffer_rx, p_uart->rx_buf, UART_RX_BUF_LENGTH); HAL_UART_DeInit(p_uart->handle); HAL_UART_Init(p_uart->handle); p_uart->is_open = true; uartStartRx(channel); ret = true; break; } return ret; }",Configure UART channel
"void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { GPIO_InitTypeDef GPIO_InitStruct = {0}; if(uartHandle->Instance==USART2) { uart_t *p_uart = &uart_tbl[_DEF_UART1]; __HAL_RCC_USART2_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); GPIO_InitStruct.Pin = GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); GPIO_InitStruct.Pin = GPIO_PIN_15; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF3_USART2; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); if (p_uart->rx_mode == UART_MODE_DMA) { __HAL_RCC_DMA1_CLK_ENABLE(); hdma_usart2_rx.Instance = DMA1_Channel6; hdma_usart2_rx.Init.Request = DMA_REQUEST_2; hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY; hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE; hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE; hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; hdma_usart2_rx.Init.Mode = DMA_CIRCULAR; hdma_usart2_rx.Init.Priority = DMA_PRIORITY_LOW; if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK) { Error_Handler(); } __HAL_LINKDMA(uartHandle,hdmarx,hdma_usart2_rx); } } }",USART2 GPIO Configuration
"static void set_led_state(bool level) { if (level) { printf(""LED is turned ON\r\n""); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); } else { printf(""LED is turned OFF\r\n""); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); } }",Control LED state
"azure_iot_nx_client_publish_float_telemetry(&azure_iot_nx_client, ""temperature"", lps22hb_data.temperature_degC, packet_ptr);",Send telemetry data
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim->Instance == TIM3) { SoftUartHandler(); } },Handle TIM3 period elapsed interrupt
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin==GPIO_PIN_10) { SoftUartRxHelper(0); } else if(GPIO_Pin==GPIO_PIN_1) { SoftUartRxHelper(1); } },Handle GPIO EXTI interrupt
"uint8_t getchar(uint8_t SoftUartNumber) { uint8_t ch; while(SoftUartRxAlavailable(SoftUartNumber)==0); SoftUartReadRxBuffer(SoftUartNumber,&ch,1); return ch; }",Read character from soft UART
"SoftUartInit(0,SU_TX_GPIO_Port,SU_TX_Pin,SU_RX_GPIO_Port,SU_RX_Pin); SoftUartInit(1,SU2_TX_GPIO_Port,SU2_TX_Pin,SU2_RX_GPIO_Port,SU2_RX_Pin);",Initialize soft UART
SoftUartEnableRx(0); SoftUartEnableRx(1);,Enable soft UART reception
"static void MX_TIM3_Init(void) { TIM_ClockConfigTypeDef sClockSourceConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0}; htim3.Instance = TIM3; htim3.Init.Prescaler = 15; htim3.Init.CounterMode = TIM_COUNTERMODE_UP; htim3.Init.Period = 103; htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; if (HAL_TIM_Base_Init(&htim3) != HAL_OK) { Error_Handler(); } sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig) != HAL_OK) { Error_Handler(); } sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig) != HAL_OK) { Error_Handler(); } }",TIM3 Initialization Function
"static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOA, SU2_TX_Pin|SU_TX_Pin, GPIO_PIN_SET); GPIO_InitStruct.Pin = LED_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct); GPIO_InitStruct.Pin = SU2_TX_Pin|SU_TX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); GPIO_InitStruct.Pin = SU2_RX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(SU2_RX_GPIO_Port, &GPIO_InitStruct); GPIO_InitStruct.Pin = SU_RX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(SU_RX_GPIO_Port, &GPIO_InitStruct); HAL_NVIC_SetPriority(EXTI0_1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI0_1_IRQn); HAL_NVIC_SetPriority(EXTI4_15_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI4_15_IRQn); }",GPIO Initialization Function
"__HAL_SPI_ENABLE_IT(&hspi2, SPI_IT_RXNE); __HAL_SPI_ENABLE(&hspi2);",Enable SPI interrupts and SPI
static void MX_SPI2_Init(void) { hspi2.Instance = SPI2; hspi2.Init.Mode = SPI_MODE_SLAVE; hspi2.Init.Direction = SPI_DIRECTION_2LINES; hspi2.Init.DataSize = SPI_DATASIZE_8BIT; hspi2.Init.CLKPolarity = SPI_POLARITY_LOW; hspi2.Init.CLKPhase = SPI_PHASE_1EDGE; hspi2.Init.NSS = SPI_NSS_HARD_INPUT; hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi2.Init.TIMode = SPI_TIMODE_DISABLE; hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi2.Init.CRCPolynomial = 10; if (HAL_SPI_Init(&hspi2) != HAL_OK) { Error_Handler(); } },SPI2 Initialization Function
static void MX_USART3_UART_Init(void) { huart3.Instance = USART3; huart3.Init.BaudRate = 115200; huart3.Init.WordLength = UART_WORDLENGTH_8B; huart3.Init.StopBits = UART_STOPBITS_1; huart3.Init.Parity = UART_PARITY_NONE; huart3.Init.Mode = UART_MODE_TX_RX; huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart3.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart3) != HAL_OK) { Error_Handler(); } },USART3 Initialization Function
"static void MX_NVIC_Init(void) { HAL_NVIC_SetPriority(SPI2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(SPI2_IRQn); HAL_NVIC_SetPriority(USART3_IRQn, 0, 0); HAL_NVIC_EnableIRQ(USART3_IRQn); }",NVIC Configuration
static void MX_USART1_UART_Init(void) { huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); } },USART1 init function
static void MX_USART2_UART_Init(void) { huart2.Instance = USART2; huart2.Init.BaudRate = 38400; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); } },USART2 init function
"static void MX_I2C1_Init(void) { hi2c1.Instance = I2C1; hi2c1.Init.Timing = 0x0000020B; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.Init.OwnAddress2 = 0; hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK; hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; if (HAL_I2C_Init(&hi2c1) != HAL_OK) { Error_Handler(); } if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK) { Error_Handler(); } }",I2C1 init function
BSP_LED_Init(LED9);,Initialize LED Error on board
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Configure User push-button in Interrupt mode
static void MX_ICACHE_Init(void) { if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK) { Error_Handler(); } if (HAL_ICACHE_Enable() != HAL_OK) { Error_Handler(); } },Enable instruction cache in 1-way (direct mapped cache)
static void MX_RNG_Init(void) { hrng.Instance = RNG; hrng.Init.ClockErrorDetection = RNG_CED_ENABLE; if (HAL_RNG_Init(&hrng) != HAL_OK) { Error_Handler(); } },RNG Initialization Function
void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin) { if (GPIO_Pin == BUTTON_USER_PIN) { ubUserButtonClickEvent = SET; RNGStatus = 1; } },Set variable to report push button event to main program
"static int32_t cache_enable(hal_cache_size_t cache_size) { hal_cache_region_t region, region_number; region_number = (hal_cache_region_t)(sizeof(region_cfg_tbl) / sizeof(region_cfg_tbl[0])); if (region_number > HAL_CACHE_REGION_MAX) { return -1; } hal_cache_init(); hal_cache_set_size(cache_size); for (region = HAL_CACHE_REGION_0; region < region_number; region++) { hal_cache_region_config(region, &region_cfg_tbl[region]); hal_cache_region_enable(region); } for (; region < HAL_CACHE_REGION_MAX; region++) { hal_cache_region_disable(region); } hal_cache_enable(); return 0; }",do cache initialization
"static void _main_sys_random_init(void) { #if defined(HAL_TRNG_MODULE_ENABLED) uint32_t seed; hal_trng_status_t s; s = hal_trng_init(); if (s == HAL_TRNG_STATUS_OK) { s = hal_trng_get_generated_random_number(&seed); } if (s == HAL_TRNG_STATUS_OK) { srand((unsigned int)seed); } if (s != HAL_TRNG_STATUS_OK) { printf(""trng init failed\n""); } #endif }",get random seed
"static void MX_LPUART1_UART_Init(void) { hlpuart1.Instance = LPUART1; hlpuart1.Init.BaudRate = 115200; hlpuart1.Init.WordLength = UART_WORDLENGTH_8B; hlpuart1.Init.StopBits = UART_STOPBITS_1; hlpuart1.Init.Parity = UART_PARITY_NONE; hlpuart1.Init.Mode = UART_MODE_TX_RX; hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1; hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&hlpuart1) != HAL_OK) { Error_Handler(); } if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK) { Error_Handler(); } if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK) { Error_Handler(); } if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK) { Error_Handler(); } }",LPUART1 Initialization Function
"void Serialbegin(long baud, uint8_t portNum) { switch(portNum) { case 1: huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); } delay(500); HAL_UART_Receive_IT(&huart1, (uint8_t *)rx1_temp, 1); break; case 2: huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); } delay(500); HAL_UART_Receive_IT(&huart2, (uint8_t *)rx2_temp, 1); break; default: break; } }",connects the internal peripheral in the processor and configures it
void Serialclose(uint8_t portNum) { switch(portNum) { case 1: HAL_UART_DeInit(&huart1); break; case 2: HAL_UART_DeInit(&huart2); break; default: break; } },disconnects the internal peripheral in the processor
static void MX_USART1_UART_Init(void) { huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); } },USART1 Initialization Function
"static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOA_CLK_ENABLE(); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); GPIO_InitStruct.Pin = GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); }",GPIO Initialization Function
"static void MX_TIM1_Init(void) { TIM_MasterConfigTypeDef sMasterConfig = {0}; TIM_OC_InitTypeDef sConfigOC = {0}; TIM_BreakDeadTimeConfigTypeDef sBreakDeadTimeConfig = {0}; htim1.Instance = TIM1; htim1.Init.Prescaler = 48000-1; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 1000-1; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_OC_Init(&htim1) != HAL_OK) { Error_Handler(); } sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&htim1, &sMasterConfig) != HAL_OK) { Error_Handler(); } sConfigOC.OCMode = TIM_OCMODE_TIMING; sConfigOC.Pulse = 0; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCNPolarity = TIM_OCNPolarity = TIM_OCNPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET; sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET; if (HAL_TIM_OC_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) { Error_Handler(); } sBreakDeadTimeConfig.OffStateRunMode = TIM_OSSR_DISABLE; sBreakDeadTimeConfig.OffStateIDLEMode = TIM_OSSI_DISABLE; sBreakDeadTimeConfig.LockLevel = TIM_LOCKLEVEL_OFF; sBreakDeadTimeConfig.DeadTime = 0; sBreakDeadTimeConfig.BreakState = TIM_BREAK_DISABLE; sBreakDeadTimeConfig.BreakPolarity = TIM_BREAKPOLARITY_HIGH; sBreakDeadTimeConfig.AutomaticOutput = TIM_AUTOMATICOUTPUT_DISABLE; if (HAL_TIMEx_ConfigBreakDeadTime(&htim1, &sBreakDeadTimeConfig) != HAL_OK) { Error_Handler(); } HAL_TIM_MspPostInit(&htim1); }",TIM1 Initialization Function
static void MX_USART2_UART_Init(void) { huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); } },USART2 Initialization Function
MX_FREERTOS_Init();,Call init function for freertos objects (in freertos.c)
osKernelStart();,Start scheduler
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },Period elapsed callback in non blocking mode
static void MX_PKA_Init(void) { hpka.Instance = PKA; if (HAL_PKA_Init(&hpka) != HAL_OK) { Error_Handler(); } },PKA Initialization Function
HAL_TIM_Base_Start_IT(&htim7);,Start the heartbeat of task management!
BSP_LED_Init(LED1);,Initialize LED1
BSP_LED_Fade(LED1);,Fade LED1
"for(int i = 0; i < 100; i++) { BSP_LED_SetLuminosity(LED1, i); HAL_Delay(5); }",Increase LED1 luminosity from 0 to 100
"for(int i = 0; i < 100; i++) { BSP_LED_SetLuminosity(LED1, 100 - i); HAL_Delay(5); }",Decrease LED1 luminosity from 100 to 0
BSP_LED_Toggle(LED1);,Toggle LED1 state
HAL_PWREx_EnableUltraLowPower();,Enable Ultra low power mode
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_HSI);,Configure HSI as wakeup clock for stop mode
HAL_SuspendTick();,Suspend SysTick
"HAL_RTCEx_SetWakeUpTimer_IT(&hrtc, 5, RTC_WAKEUPCLOCK_CK_SPRE_16BITS);",Set RTC wakeup timer with 5-second interval
"HAL_PWR_EnterSTOPMode(PWR_LOWPOWERREGULATOR_ON, PWR_STOPENTRY_WFI);",Enter Stop Mode
HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);,Deactivate RTC wakeup timer
HAL_ResumeTick();,Resume SysTick
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc) { },Callback for RTC_IRQHandler()
LED1_GPIO_CLK_ENABLE();,Enable GPIO clock for LED1 configuration
LED2_GPIO_CLK_ENABLE();,Enable GPIO clock for LED2 configuration
LED3_GPIO_CLK_ENABLE();,Enable GPIO clock for LED3 configuration
LED4_GPIO_CLK_ENABLE();,Enable GPIO clock for LED4 configuration
GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull  = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;,Configure IO in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Pin = LED1_PIN; HAL_GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStruct);",Configure LED1 IO
"GPIO_InitStruct.Pin = LED2_PIN; HAL_GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStruct);",Configure LED2 IO
"GPIO_InitStruct.Pin = LED3_PIN; HAL_GPIO_Init(LED3_GPIO_PORT, &GPIO_InitStruct);",Configure LED3 IO
"GPIO_InitStruct.Pin = LED4_PIN; HAL_GPIO_Init(LED4_GPIO_PORT, &GPIO_InitStruct);",Configure LED4 IO
"while (1) { HAL_GPIO_TogglePin(LED1_GPIO_PORT, LED1_PIN); HAL_Delay(100); HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN); HAL_Delay(100); HAL_GPIO_TogglePin(LED3_GPIO_PORT, LED3_PIN); HAL_Delay(100); HAL_GPIO_TogglePin(LED4_GPIO_PORT, LED4_PIN); HAL_Delay(100); }",Toggle IO in an infinite loop
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the USART.
BSP_UART_Init(115200);,Initialize UART with 115200 baud rate
"HAL_UART_Transmit_DMA(&huart6,&Data,1);",transmit data on UART 6
"int _write(int file, char *ptr, int len) { CDC_Transmit_FS((uint8_t *)ptr, len); return len; }",Redirect printf to USB serial
"if (now - last_tick >=  OTPUT_PORT, LED_Pin); last_blink = now; }",Toggle LED every 500ms
HAL_TIM_Base_Start_IT(&htim1);,Start Timer 1 with interrupts
HAL_TIM_Base_Start_IT(&htim2);,Start Timer 2 with interrupts
"void StartOffTask(void *argument) { for(;;) { osDelay(1100); HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET); } }",Task to turn off LD2 every 1100ms
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM17) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode - This function is called when TIM17 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
static void LED_Thread2(void const *argument) { uint32_t count; (void) argument; for (;;) { count = osKernelSysTick() + 10000; while (count >= osKernelSysTick()) { BSP_LED_Toggle(LED4); osDelay(500); } BSP_LED_Off(LED4); osThreadResume(LEDThread1Handle); osThreadSuspend(NULL); } },Toggle LED4 thread
"static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOC_CLK_ENABLE(); HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET); GPIO_InitStruct.Pin = LED_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct); }",GPIO Initialization Function
"void StartBlink01(void *argument) { for(;;) { HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); osDelay(500); } osThreadTerminate(NULL); }",Function implementing the blink01 thread.
"void StartBlink02(void *argument) { for(;;) { HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); osDelay(300); } osThreadTerminate(NULL); }",Function implementing the blink02 thread.
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM4) { HAL_IncTick(); } },Period elapsed callback in non blocking mode
TIMER2_Init();,inicializa el conteo del timer2
HAL_TIM_Base_Start(&htimer2);,inicializa el conteo del timer2
void TIMER2_Init(void) { htimer2.Instance = TIM2; htimer2.Init.Prescaler = 3999; htimer2.Init.Period = 99; if(HAL_TIM_Base_Init(&htimer2) != HAL_OK) { Error_Handler(); } },inicializa el conteo del timer2
ADC1_Config();,configure ADC1
Display_GPIO_Config();,Configure 7-Segment Displays
Alarm_GPIO_Config();,Configure alarm pins
initLCD();,configure LCD
HAL_ADC_Start(&ADC1_Handle);,start ADC conversion
adc_val = HAL_ADC_GetValue(&ADC1_Handle);,get the value
temp = convertTemp(adcState->x);,convert the filterd value of the ADC into temperature
trigger_alarm();,Alarm triggering
shutoff_alarm();,Alarm triggering
display(displayTemp);,display on 7-segment display
halInit();,Application entry point.
"tx_byte_pool_create(&byte_pool_0, ""byte pool 0"", memory_area, DEFAULT_BYTE_POOL_SIZE);",Create a byte memory pool from which to allocate the thread stacks.
Watchdog_Init();,start watchdog
"palClearPad(GPIOB, GPIOB_LD2);",turn LED2 off
"sdStart(&SERIAL_DRIVER, NULL);",starts the serial driver
"status = tx_thread_create(&clrStartupThread, ""CLR Thread"", ClrStartupThread_entry, (uint32_t)&clrSettings, clrStartupThreadStack, CLR_THREAD_STACK_SIZE, CLR_THREAD_PRIORITY, CLR_THREAD_PRIORITY, TX_NO_TIME_SLICE, TX_AUTO_START);",Create CLR startup thread
tx_kernel_enter();,Enter the ThreadX kernel
halInit();,"HAL initialization, this also initializes the configured device drivers and performs the board-specific initializations."
SwoInit();,init SWO as soon as possible to make it available to output ASAP
osKernelInitialize();,"The kernel is initialized but not started yet, this means that main() is executing with absolute priority but interrupts are already enabled."
"sduObjectInit(&SERIAL_DRIVER); sduStart(&SERIAL_DRIVER, &serusbcfg);",Initializes a serial-over-USB CDC driver.
"usbDisconnectBus(serusbcfg.usbp); chThdSleepMilliseconds(100); usbStart(serusbcfg.usbp, &usbcfg); usbConnectBus(serusbcfg.usbp);","Activates the USB driver and then the USB bus pull-up on D+. Note, a delay is inserted in order to not have to disconnect the cable after a reset."
"osThreadCreate(osThread(ReceiverThread), NULL);",create the receiver thread
osKernelStart();,"start kernel, after this main() will behave like a thread with priority osPriorityNormal"
BlockStorageList_Initialize(); BlockStorage_AddDevices();,initialize block storage list and devices
ConfigurationManager_Initialize();,initialize configuration manager
ReportSuccessfullNanoBooter();,report successfull nanoBooter execution
AD5060_CS_init(); AD5060_setval(20000);,Initialize AD5060 DAC
"sFilterConfig.FilterBank = 0; sFilterConfig.FilterMode = CAN_FILTERMODE_IDMASK; sFilterConfig.FilterScale = CAN_FILTERSCALE_32BIT; sFilterConfig.FilterIdHigh = 0x0000; sFilterConfig.FilterIdLow = 0x0000; sFilterConfig.FilterMaskIdHigh = 0x0000; sFilterConfig.FilterMaskIdLow = 0x0000; sFilterConfig.FilterFIFOAssignment = CAN_RX_FIFO0; sFilterConfig.FilterActivation = ENABLE; sFilterConfig.SlaveStartFilterBank = 14; if (HAL_CAN_ConfigFilter(&hcan1, &sFilterConfig) != HAL_OK) { Error_Handler(); }",Configure CAN filter
"if (HAL_CAN_ActivateNotification(&hcan1, CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_TX_MAILBOX_EMPTY) != HAL_OK) { Error_Handler(); }",Activate CAN notifications
static void MX_CAN1_Init(void) { hcan1.Instance = CAN1; hcan1.Init.Prescaler = 16; hcan1.Init.Mode = CAN_MODE_NORMAL; hcan1.Init.SyncJumpWidth = CAN_SJW_1TQ; hcan1.Init.TimeSeg1 = CAN_BS1_1TQ; hcan1.Init.TimeSeg2 = CAN_BS2_1TQ; hcan1.Init.TimeTriggeredMode = DISABLE; hcan1.Init.AutoBusOff = DISABLE; hcan1.Init.AutoWakeUp = DISABLE; hcan1.Init.AutoRetransmission = DISABLE; hcan1.Init.ReceiveFifoLocked = DISABLE; hcan1.Init.TransmitFifoPriority = DISABLE; if (HAL_CAN_Init(&hcan1) != HAL_OK) { Error_Handler(); } },CAN1 Initialization Function
static void MX_SPI1_Init(void) { hspi1.Instance = SPI1; hspi1.Init.Mode = SPI_MODE_MASTER; hspi1.Init.Direction = SPI_DIRECTION_2LINES; hspi1.Init.DataSize = SPI_DATASIZE_8BIT; hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; hspi1.Init.NSS = SPI_NSS_SOFT; hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2; hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi1.Init.TIMode = SPI_TIMODE_DISABLE; hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi1.Init.CRCPolynomial = 10; if (HAL_SPI_Init(&hspi1) != HAL_OK) { Error_Handler(); } },SPI1 Initialization Function
TIM_HandleTypeDef    TimHandle;,TIM handle declaration
BSP_LED_Init(LED2);,Configure LED2
uwPrescalerValue = (uint32_t)(SystemCoreClock / 2500) - 1;,Compute the prescaler value to have TIMx counter clock equal to 2500 Hz
TimHandle.Instance = TIMx;,Set TIMx instance
TimHandle.Init.Period            = 2500 - 1; TimHandle.Init.Prescaler         = uwPrescalerValue; TimHandle.Init.ClockDivision     = 0; TimHandle.Init.CounterMode       = TIM_COUNTERMODE_UP;,Initialize TIMx peripheral as follows: + Period = 2500 - 1 + Prescaler = (SystemCoreClock/2500) - 1 + ClockDivision = 0 + Counter direction = Up
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { BSP_LED_Toggle(LED2); },Period elapsed callback in non blocking mode
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5; RCC_OscInitStruct.MSICalibrationValue=0x00; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,Enable MSI Oscillator
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
__HAL_RCC_PWR_CLK_ENABLE();,Enable Power Control clock
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet."
__HAL_RCC_PWR_CLK_DISABLE();,Disable Power Control clock
static RingBuffer USART_RingBuffer_Tx;,UART transmit buffer descriptor
static char RingBufferData_Tx[1024];,UART transmit buffer memory pool
static char RingBufferData_Rx[1024];,UART receive buffer memory pool
"if (__HAL_USART_GET_FLAG(&UartHandle, USART_FLAG_RXNE)) { if (__HAL_USART_GET_IT_SOURCE(&UartHandle, USART_IT_RXNE)) { char c = USARTx->DR; RingBuffer_PutChar(&USART_RingBuffer_Rx, c); } }",the RXNE interrupt has occurred ... the RXNE interrupt is enabled ... receive character
"if (__HAL_USART_GET_FLAG(&UartHandle, USART_FLAG_TXE)) { if (__HAL_USART_GET_IT_SOURCE(&UartHandle, USART_IT_TXE)) { char c; if(RingBuffer_GetChar(&USART_RingBuffer_Tx, &c)) { USARTx->DR = c; } else { __USART_DISABLE_IT(&UartHandle, USART_IT_TXE); } } }",the TXE interrupt has occurred ... the TXE interrupt is enabled ... send character ... if failed disable interrupt
"void HAL_UART_MspInit(UART_HandleTypeDef *huart) { GPIO_InitTypeDef  GPIO_InitStruct; USARTx_TX_GPIO_CLK_ENABLE(); USARTx_RX_GPIO_CLK_ENABLE(); USARTx_CLK_ENABLE(); GPIO_InitStruct.Pin       = USARTx_TX_PIN; GPIO_InitStruct.Mode      = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull      = GPIO_NOPULL; GPIO_InitStruct.Speed     = GPIO_SPEED_FAST; GPIO_InitStruct.Alternate = USARTx_TX_AF; HAL_GPIO_Init(USARTx_TX_GPIO_PORT, &GPIO_InitStruct); GPIO_InitStruct.Pin = USARTx_RX_PIN; GPIO_InitStruct.Alternate = USARTx_RX_AF; HAL_GPIO_Init(USARTx_RX_GPIO_PORT, &GPIO_InitStruct); HAL_NVIC_SetPriority(USARTx_IRQn, 0, 1); HAL_NVIC_EnableIRQ(USARTx_IRQn); }",This function configures the hardware resources used in this example: - Peripheral's clock enable - Peripheral's GPIO Configuration - NVIC configuration for UART interrupt request enable
"void HAL_UART_MspDeInit(UART_HandleTypeDef *huart) { USARTx_FORCE_RESET(); USARTx_RELEASE_RESET(); HAL_GPIO_DeInit(USARTx_TX_GPIO_PORT, USARTx_TX_PIN); HAL_GPIO_DeInit(USARTx_RX_GPIO_PORT, USARTx_RX_PIN); HAL_NVIC_DisableIRQ(USARTx_IRQn); }",This function frees the hardware resources used in this example: - Disable the Peripheral's clock - Revert GPIO and NVIC configuration to their default state
"bool USART_Init(void) { RingBuffer_Init(&USART_RingBuffer_Tx, RingBufferData_Tx, sizeof(RingBufferData_Tx)); RingBuffer_Init(&USART_RingBuffer_Rx, RingBufferData_Rx, sizeof(RingBufferData_Rx)); UartHandle.Instance          = USARTx; UartHandle.Init.BaudRate     = 115200; UartHandle.Init.WordLength   = UART_WORDLENGTH_8B; UartHandle.Init.StopBits     = UART_STOPBITS_1; UartHandle.Init.Parity       = UART_PARITY_NONE; UartHandle.Init.HwFlowCtl    = UART_HWCONTROL_NONE; UartHandle.Init.Mode         = UART_MODE_TX_RX; UartHandle.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_MspInit(&UartHandle); if(HAL_UART_Init(&UartHandle) != HAL_OK) { printf(""ERROR in USART_Init""); return false; } __USART_ENABLE_IT(&UartHandle, USART_IT_RXNE); return true; }","This function initialize ring buffers, USART device and enable receive interrupt."
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode ... This function is called when TIM6 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
"void LEDtask_entry(void *argument){ while(1){ HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin); osDelay(500); } }",LED task to toggle LED2 every 500ms
"void USBtask_entry(void *argument){ uint8_t buffer[] = ""Hello Wilson\n\r""; while(1){ CDC_Transmit_FS(buffer, sizeof(buffer)); osDelay(5000); } }","USB task to transmit ""Hello Wilson"" every 5000ms"
"void buzzer_on(uint16_t psc, uint16_t pwm){ __HAL_TIM_PRESCALER(&htim12, psc); __HAL_TIM_SetCompare(&htim12, TIM_CHANNEL_1, pwm); }",Turn on buzzer with specified prescaler and PWM value
"void buzzer_off(void) { __HAL_TIM_SetCompare(&htim12, TIM_CHANNEL_1, 0); }",Turn off buzzer
"void Buzzertask_entry(void *argument){ buzzer_on(24, 5000); HAL_Delay(250); while(1){ buzzer_off(); osDelay(1); } }",Buzzer task to turn on buzzer briefly then keep it off
"void Servotask_entry(void *argument){ while(1){ __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, 1200); __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, 1200); __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, 1200); osDelay(5000); __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_2, 1600); __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_3, 1600); __HAL_TIM_SetCompare(&htim5, TIM_CHANNEL_4, 1600); osDelay(5000); } }","Servo task to control PWM for servo channels, alternating between 1200 and 1600 every 5000ms"
"void Buttontask_entry(void *argument){ while(1){ if (HAL_GPIO_ReadPin(GPIOB, Custom_Button_Pin) == GPIO_PIN_SET){ HAL_GPIO_WritePin(Button_LED_GPIO_Port, Button_LED_Pin, GPIO_PIN_RESET); } else{ HAL_GPIO_WritePin(Button_LED_GPIO_Port, Button_LED_Pin, GPIO_PIN_SET); } } }",Button task to toggle LED based on button state
"if (CAN_Config(&hcan2, CAN_MODE_NORMAL) != HAL_OK) { Error_Handler(); }",Configure CAN bus in normal mode
"Display_Init(); Display_DrawString(""Loading..."", FONT24, 0, 0); Display_Update(); Display_Clear();",Initialize display and show loading message
"while (1) { Display_DrawString(""SUPP VOLT:"", FONT16, 0, 0); Display_DrawString(""TEMP:"", FONT16, 0, 50); Display_DrawString(""VOLT:"", FONT16, 0, 100); Display_DrawString(""CURR:"", FONT16, 0, 150); Display_DrawCANMessage(CAN_RetrieveData(SUPPLEMENTAL_VOLTAGE), FONT24, 120, 0); Display_DrawCANMessage(CAN_RetrieveData(TEMP_DATA), FONT24, 60, 50); Display_DrawCANMessage(CAN_RetrieveData(VOLT_DATA), FONT24, 60, 100); Display_DrawCANMessage(CAN_RetrieveData(CURRENT_DATA), FONT24, 60, 150); Display_Update(); HAL_Delay(10000); Display_Clear(); }","Main loop to display CAN bus data (supplemental voltage, temperature, voltage, current) every 10 seconds"
static void uartStartRx(uint8_t channel);,Function to start UART receive operation
"if (p_uart->rx_mode == UART_MODE_INTERRUPT) { HAL_UART_Receive_IT(p_uart->handle, p_uart->rx_buf, 1); } if (p_uart->rx_mode == UART_MODE_DMA) { HAL_UART_Receive_DMA(p_uart->handle, (uint8_t *)p_uart->qbuffer_rx.p_buf, p_uart->qbuffer_rx.length); }",Start UART reception based on mode (interrupt or DMA)
"led_set_mode(&hLED, led_mode_off);",Set LED mode to off
"can_init(&hCAN, CAN); can_disable(&hCAN);",Initialize and disable CAN peripheral
q_frame_pool = queue_create(CAN_QUEUE_SIZE); q_from_host  = queue_create(CAN_QUEUE_SIZE); q_to_host    = queue_create(CAN_QUEUE_SIZE);,"Create queues for CAN frame pool, from host, and to host"
"struct gs_host_frame *msgbuf = calloc(CAN_QUEUE_SIZE, sizeof(struct gs_host_frame)); for (unsigned i=0; i<CAN_QUEUE_SIZE; i++) { queue_push_back(q_frame_pool, &msgbuf[i]); }",Allocate and initialize CAN frame pool
"USBD_Init(&hUSB, (USBD_DescriptorsTypeDef*)&FS_Desc, DEVICE_FS); USBD_RegisterClass(&hUSB, &USBD_GS_CAN); USBD_GS_CAN_Init(&hUSB, q_frame_pool, q_from_host, &hLED); USBD_GS_CAN_SetChannel(&hUSB, 0, &hCAN); USBD_Start(&hUSB);",Initialize and start USB device with CAN interface
if (USBD_GS_CAN_TxReady(&hUSB)) { send_to_host(); },Send data to host if USB Tx is ready
if (USBD_GS_CAN_DfuDetachRequested(&hUSB)) { dfu_run_bootloader(); },Run bootloader if USB DFU detach requested
"#define BIT_0	( 1 << 0 )",Define signal bit 0
"#define BIT_1	( 1 << 1 )",Define signal bit 1
"#define BIT_2	( 1 << 2 )",Define signal bit 2
"osThreadId LED1_ThreadId, LED2_ThreadId;",Thread IDs for LED tasks
MPU_Config();,Configure the MPU attributes
CPU_CACHE_Enable();,Enable the CPU Cache
BSP_LED_Init(LED1); BSP_LED_Init(LED2);,Initialize LEDs
"LED1_ThreadId = osThreadCreate(osThread(LED1), NULL);",Start thread 1
"LED2_ThreadId = osThreadCreate(osThread(LED2), NULL);",Start thread 2
"osThreadCreate(osThread(SIGNAL_GEN), NULL);",Start thread 3
"static void LED_Thread1(void const *argument) { (void) argument; osEvent event; for(;;) { event = osSignalWait( BIT_0, osWaitForever); if(event.value.signals == BIT_0) { BSP_LED_Toggle(LED1); } } }",Thread (LED_Thread1) used to toggle a LED when getting the appropriate signal.
"static void LED_Thread2(void const *argument) { (void) argument; osEvent event; for(;;) { event = osSignalWait( BIT_1 | BIT_2, osWaitForever); if(event.value.signals == (BIT_1 | BIT_2)) { BSP_LED_Toggle(LED2); } } }",Thread (LED_Thread2) used to toggle a LED when getting the appropriate signal.
"static void Signal_Gen_Thread(void const *argument) { (void) argument; for(;;) { osSignalSet( LED1_ThreadId, BIT_0 ); osDelay(500); osSignalSet( LED2_ThreadId, BIT_1 | BIT_2 ); osDelay(500); } }",Signal generator thread
"GPIO_PinState state = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13); HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, state);",Read button state and set LED accordingly
"GPIO_InitStruct.Pin = GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC13
"GPIO_InitStruct.Pin = GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pin : PA5
USART2_UART_Init();,Initialize USART2
ssd1331_init();,Initialize SSD1331 OLED display
"ssd1331_gotoxy(10, 4);","Go to location X = 10, Y = 4"
"ssd1331_puts(""Hello STM32"", &FontSet_10, SSD1331_COLOR_RED, 1);","Display text ""Hello STM32"" in red"
"ssd1331_gotoxy(15, 25);","Go to location X = 15, Y = 25"
"ssd1331_drawcircle(60, 40, 10, SSD1331_COLOR_YELLOW); ssd1331_drawcircle(60, 40, 20, SSD1331_COLOR_ORANGE); ssd1331_drawcircle(60, 40, 30, SSD1331_COLOR_WHITE);","Draw concentric circles in yellow, orange, and white"
HAL_Delay(100);,Make a little delay
__PWR_CLK_ENABLE();,Enable Power Control clock
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,Configure voltage scaling for power optimization
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2; RCC_OscInitStruct.PLL.PLLR = 2;,Configure HSI oscillator and PLL
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Configure system clock and dividers
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure Systick interrupt time
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Configure Systick clock source
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16;,Configure USART2 parameters
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF); while (HAL_UART_GetState(&huart2) != HAL_UART_STATE_READY); return ch; }",Retarget printf to USART2
"GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);","Configure USART2 GPIO pins (PA2, PA3)"
MX_TIM3_Init();,Initialize TIM3
htim3.Instance = TIM3; htim3.Init.Prescaler = 8000; htim3.Init.CounterMode = TIM_COUNTERMODE_UP; htim3.Init.Period = 50000; htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;,Configure TIM3 parameters
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;,Set TIM3 clock source to internal
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;,Configure TIM3 master synchronization
__HAL_RCC_TIM3_CLK_ENABLE();,Enable TIM3 clock
__HAL_RCC_TIM3_CLK_DISABLE();,Disable TIM3 clock
void TIM3_IRQHandler(void) { HAL_TIM_IRQHandler(&htim3); },Handle TIM3 global interrupt
UINT64 Timer3GetCycle(VOID) { static UINT64 bacCycle; static UINT64 cycleTimes; UINT64 swCycles = htim3.Instance->CNT; if (swCycles < bacCycle) { cycleTimes++; } bacCycle = swCycles; return swCycles + cycleTimes * TIMER3_RELOAD; },Get TIM3 cycle count
HAL_TIM_Base_Start_IT(&htim3);,Start TIM3 in interrupt mode
BSP_LED_Init(LED1); BSP_LED_Init(LED2); BSP_LED_Init(LED3);,"Configure LED1, LED2 and LED3"
LL_SPI_Enable(hspi1.Instance);,Enable SPI before start transmission
"if(( LL_SPI_IsActiveFlag_TXE(hspi1.Instance)) && (ubNbDataToTransmit > 0)) { LL_SPI_TransmitData16(hspi1.Instance, aTxBuffer[ubTransmitIndex++]); ubNbDataToTransmit--; }",Check TXE flag to transmit data ... Transmit 16bit Data
if(LL_SPI_IsActiveFlag_RXNE(hspi1.Instance)) { aRxBuffer[ubReceiveIndex++] = LL_SPI_ReceiveData16(hspi1.Instance); ubNbDataToReceive--; },Check RXE flag ... Receive 16bit Data
"if (Buffercmp((uint8_t *)aTxBuffer, (uint8_t *)aRxBuffer, COUNTOF(aTxBuffer))) { Error_Handler(); } else { BSP_LED_On(LED1); }",Compare the sent and received buffers ... Turn LED1 on if transfer is correct
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1;,"Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
"static uint16_t Buffercmp(uint8_t* pBuffer1, uint8_t* pBuffer2, uint16_t BufferLength) { while (BufferLength--) { if((*pBuffer1) != *pBuffer2) { return BufferLength; } pBuffer1++; pBuffer2++; } return 0; }","Compares two buffers ... Returns 0 if identical, else non-zero"
main_loop();,Start main application loop
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;,Configure USB clock source
hcrc.Instance = CRC; hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE; hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE; hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE; hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE; hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;,Configure CRC peripheral
"GPIO_InitStruct.Pin = B1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_EVT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : B1_Pin
"GPIO_InitStruct.Pin = EXT_RESET_Pin | LD3_Pin | LD6_Pin | LD4_Pin | LD5_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pins : EXT_RESET_Pin LD3_Pin LD6_Pin LD4_Pin LD5_Pin
BSP_LED_Init(LED3); BSP_LED_Init(LED4);,Configure LED3 and LED4
uwPrescalerValue = (uint32_t) ((SystemCoreClock / 10000) - 1);,Compute the prescaler value to have TIM3 counter clock equal to 10 KHz
TimHandle.Init.Period = 10000 - 1; TimHandle.Init.Prescaler = uwPrescalerValue; TimHandle.Init.ClockDivision = 0; TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP;,"Initialize TIM3 peripheral: Period = 10000 - 1, Prescaler = (SystemCoreClock/10000) - 1, ClockDivision = 0, Counter direction = Up"
if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK) { Error_Handler(); },Handle TIM3 initialization error
if(HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK) { Error_Handler(); },Start TIM3 in interrupt mode
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { BSP_LED_Toggle(LED4); },Period elapsed callback to toggle LED4
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,Configure voltage scaling for power optimization
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 400; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSI Oscillator and activate PLL with HSI as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
BSP_LED_Init(LED2);,Initialize BSP Led for LED2
UartHandle.Instance = USARTx; UartHandle.Init.BaudRate = 9600; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_ODD; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; UartHandle.Init.OverSampling = UART_OVERSAMPLING_16;,Configure the UART peripheral
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the USART
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure voltage scaling for power optimization
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
if(HAL_PWREx_EnableOverDrive() != HAL_OK) { Error_Handler(); },Enable OverDrive mode
BSP_LED_Init(LED3); BSP_LED_Init(LED4); BSP_LED_Init(LED5); BSP_LED_Init(LED6);,"Configure LED3, LED4, LED5 and LED6"
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Configure USER Button
while (!UserPressButton) { Toggle_Leds(); },Toggle LEDs between each Test
BSP_examples[DemoIndex++].DemoFunc();,Run the current demo function
if(DemoIndex >= COUNT_OF_EXAMPLE(BSP_examples)) { DemoIndex = 0; },Reset DemoIndex to restart BSP example
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSE Oscillator and activate PLL with HSE as source
if (HAL_GetREVID() == 0x1001) { __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); },Enable the Flash prefetch for specific STM32F4 revisions
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if (KEY_BUTTON_PIN == GPIO_Pin) { while (BSP_PB_GetState(BUTTON_KEY) != RESET); UserPressButton = 1; } },Handle button press interrupt
void Toggle_Leds(void) { BSP_LED_Toggle(LED3); HAL_Delay(100); BSP_LED_Toggle(LED4); HAL_Delay(100); BSP_LED_Toggle(LED5); HAL_Delay(100); BSP_LED_Toggle(LED6); HAL_Delay(100); },Toggle LEDs
"SBUS_Init(&sbus, &huart1);",Initialize SBUS protocol with USART1
"if (sbus.flags != SBUS_FAILSAFE_ACTIVE) { for (int x = 0; x < 8; x++) { report[x] = _constrain(_map(sbus.ch[x], SBUS_DIGITAL_CHANNEL_MIN, SBUS_DIGITAL_CHANNEL_MAX, -127, 127), -127, 127); } } else { for (int x = 0; x < 8; x++) { report[x] = 0; } }",Process SBUS channel data or set to zero if failsafe active
"USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, (uint8_t*) report, 8);",Send HID report over USB
HAL_Delay(2);,Short delay for USB report timing
__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);,Configure LSE Drive Capability
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_USB; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1; PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_MSI; PeriphClkInit.PLLSAI1.PLLSAI1M = 1; PeriphClkInit.PLLSAI1.PLLSAI1N = 24; PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7; PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2; PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2; PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK;,"Configure peripheral clocks for USART1, USART2, and USB"
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure the Systick interrupt time
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Configure the Systick
HAL_RCCEx_EnableMSIPLLMode();,Enable MSI Auto calibration
MX_FREERTOS_Init();,Init FreeRTOS
"osThreadDef(blinkLed, StartBlinkLedTask, osPriorityIdle, 0, 128); blinkLedHandle = osThreadCreate(osThread(blinkLed), NULL);",Create blink LED task
void StartDefaultTask(void const * argument) { for(;;) { osDelay(1000); } },Default task with 1-second delay loop
"void StartDialogTask(void const * argument) { Dialog_Init(&huart1); osDelay(500); printf(""StartComTask\r\n""); for(;;) { Dialog_Process(); } }",Dialog task to initialize UART communication and process dialog
"void StartBlinkLedTask(void const * argument) { for(;;) { HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); osDelay(250); HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET); osDelay(250); } }",Blink LED task to toggle LED4 every 250ms
DacHandle.Instance = DACx;,Configure the DAC peripheral
BSP_LED_On(LED2);,Turn LED2 on
BSP_LED_Init(LED1);,"Configure LED1, LED3 and LED4"
BSP_LED_Init(LED3);,"Configure LED1, LED3 and LED4"
BSP_LED_Init(LED4);,"Configure LED1, LED3 and LED4"
"HAL_HASH_SHA1_Start_DMA(&HashHandle, (uint8_t*)aInput, strlen((char const*)aInput));",Start HASH computation using DMA transfer
"HAL_HASH_SHA1_Finish(&HashHandle, aSHA1Digest, 0xFF);",Get the computed digest value
BSP_LED_On(LED3);,Turn LED3 on
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);",Start PWM signal
"static void MX_TIM2_Init(void) { TIM_ClockConfigTypeDef sClockSourceConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0}; TIM_OC_InitTypeDef sConfigOC = {0}; htim2.Instance = TIM2; htim2.Init.Prescaler = 0; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 1023; htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_ENABLE; if (HAL_TIM_Base_Init(&htim2) != HAL_OK) { Error_Handler(); } sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&htim2, &sClockSourceConfig) != HAL_OK) { Error_Handler(); } if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) { Error_Handler(); } sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; if (HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig) != HAL_OK) { Error_Handler(); } sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = 25; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; if (HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1) != HAL_OK) { Error_Handler(); } HAL_TIM_MspPostInit(&htim2); }",TIM2 Initialization Function
static void MX_USART2_UART_Init(void) { huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); } },USART2 Initialization Function
Init_Retarget(&huart1);,retarget HW UART to printf
Init_ADC();,Initialize ADC
Init_SPI();,Initialize SPI
Disable_All_Digits();,Disable all display digits
Init_Fan();,Initialize fan
Denit_Fan();,Deinitialize fan
Init_Delay_Timer();,Initialize delay timer
ds1820_read();,Read temperature from DS1820 sensor
"bool gpioInit(void) { bool ret = true; __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); for (int i=0; i<GPIO_MAX_CH; i++) { gpioPinMode(i, gpio_tbl[i].mode); gpioPinWrite(i, gpio_tbl[i].init_value); } #ifdef _USE_HW_CLI cliAdd(""gpio"", cliGpio); #endif return ret; }",Initialize GPIO pins
"bool gpioPinMode(uint8_t ch, uint8_t mode) { bool ret = true; GPIO_InitTypeDef GPIO_InitStruct = {0}; if (ch >= GPIO_MAX_CH) { return false; } switch(mode) { case _DEF_INPUT: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_INPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_INPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; case _DEF_OUTPUT: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_OUTPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_OUTPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; } GPIO_InitStruct.Pin = gpio_tbl[ch].pin; HAL_GPIO_Init(gpio_tbl[ch].port, &GPIO_InitStruct); return ret; }",Configure GPIO pin mode
"void gpioPinToggle(uint8_t ch) { if (ch >= GPIO_MAX_CH) { return; } HAL_GPIO_TogglePin(gpio_tbl[ch].port, gpio_tbl[ch].pin); }",Toggle GPIO pin
MX_GPIO_Init();,Initialize GPIO
BSP_UART_Init(115200);,Initialize UART with specified baud rate
"if(HAL_UART_Receive_IT(&huart6,&Data,1) == HAL_OK) { HAL_UART_Transmit_IT(&huart6,&Data,1); }",Receive and transmit data on UART6 using interrupts
"int fputc(int ch, FILE *f) { if (ch == '\n') { HAL_UART_Transmit(&huart1, (void *)""\r"", 1,30000); } HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Redirect printf to UART1
"int _write(int fd, char *ptr, int len) { (void)HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF); return len; }",Redirect write to UART1
"int fgetc(FILE *f) { uint8_t ch = 0; HAL_UART_Receive(&huart1, &ch, 1,30000); return ch; }",Redirect fgetc to UART1
void MX_RNG_Init(void) { hrng.Instance = RNG; if (HAL_RNG_Init(&hrng) != HAL_OK) { Error_Handler(); } },RNG Initialization Function
"void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOE_CLK_ENABLE(); GPIO_InitStruct.Pin = GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOE, &GPIO_InitStruct); HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI1_IRQn); }",GPIO Initialization Function
BSP_LED_Init(LED3);,Initialize LED
"GPIO_InitStruct.Pin = GPIO_PIN_12; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; __HAL_RCC_GPIOA_CLK_ENABLE(); HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure PA.12 (Arduino D2) as input with External interrupt
"NVIC_SetPriority((IRQn_Type)(EXTI4_15_IRQn), 0x03); HAL_NVIC_EnableIRQ((IRQn_Type)(EXTI4_15_IRQn));",Enable and set PA.12 (Arduino D2) EXTI Interrupt to the lowest priority
"osSemaphoreDef(SEM); osSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1);",Create the semaphore used by the two threads
"static void SemaphoreTest(void const *argument) { for (;;) { if (osSemaphore != NULL) { if (osSemaphoreWait(osSemaphore , 0) == osOK) { BSP_LED_Toggle(LED3); } } } }",Semaphore Test
CrcHandle.Instance = CRC; if (HAL_CRC_Init(&CrcHandle) != HAL_OK) { Error_Handler(); },Configure the CRC peripheral
"uwCRCValue = HAL_CRC_Accumulate(&CrcHandle, (uint32_t *)aDataBuffer, BUFFER_SIZE);","Compute the CRC of ""aDataBuffer"""
if (uwCRCValue != uwExpectedCRCValue) { Error_Handler(); } else { BSP_LED_On(LED3); },Compare the CRC value to the Expected one
static void MX_USART1_UART_Init(void) { huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); } },USART1 Initialization Function
"static void MX_DMA_Init(void) { __HAL_RCC_DMA2_CLK_ENABLE(); HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn); }",Enable DMA controller clock
EPD_Paint_Screen(black);,Paint screen black
EPD_Paint_Screen(white);,Paint screen white
"EPD_Buff_Screen((uint8_t*)&gImage_b1, sizeof(gImage_b1), black);",Display image buffer
BSP_LED_Init(LED1);,Configure LED1
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Configure BUTTON_KEY
HAL_Delay(500);,Insert delay 500 ms
BSP_LED_Toggle(LED1);,Toggle LED1
BSP_LED_Toggle(LED2);,Toggle LED2
BSP_LED_Toggle(LED3);,Toggle LED3
if(GPIO_Pin == KEY_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } },EXTI line detection callback: Suspend or resume tick increment based on button state
HAL_SuspendTick();,Suspend tick increment
HAL_ResumeTick();,Resume tick increment
BSP_LED_Init(LED1);,Configure LED1 & LED3
BSP_LED_Init(LED3);,Configure LED1 & LED3
uwPrescalerValue = (uint32_t)((SystemCoreClock / 2) / 10000) - 1;,Compute the prescaler value to have TIMx counter clock equal to 10000 Hz
TimHandle.Init.Period = 10000 - 1; TimHandle.Init.Prescaler = uwPrescalerValue; TimHandle.Init.ClockDivision = 0; TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP; TimHandle.Init.RepetitionCounter = 0; TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;,Initialize TIMx peripheral as follows: + Period = 10000 - 1 + Prescaler = ((SystemCoreClock / 2)/10000) - 1 + ClockDivision = 0 + Counter direction = Up
HAL_TIM_Base_Init(&TimHandle),Initialize TIMx peripheral
HAL_TIM_Base_Start_IT(&TimHandle),Start the TIM Base generation in interrupt mode
BSP_LED_Toggle(LED1);,Toggle LED1 on period elapsed
"HAL_GPIO_TogglePin(USER_LED_GPIO_Port, USER_LED_Pin);",Toggle USER_LED
test();,Call test function
"HAL_GPIO_WritePin(USER_LED_GPIO_Port, USER_LED_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(GPIOA, SPI1_CS_Pin|HV_EN_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = USER_LED_Pin|SPI1_CS_Pin|HV_EN_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : USER_LED_Pin SPI1_CS_Pin HV_EN_Pin
"HAL_UART_Transmit(&huart3 , (uint8_t *)&ch, 1, 0xFFFF);",Transmit character over UART3
BSP_LED_Init(LED1);,Configure LED1 and LED3
BSP_LED_Init(LED3);,Configure LED1 and LED3
AdcHandle.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV2; AdcHandle.Init.Resolution = ADC_RESOLUTION_12B; AdcHandle.Init.ScanConvMode = DISABLE; AdcHandle.Init.ContinuousConvMode = ENABLE; AdcHandle.Init.DiscontinuousConvMode = DISABLE; AdcHandle.Init.NbrOfDiscConversion = 0; AdcHandle.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE; AdcHandle.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1; AdcHandle.Init.DataAlign = ADC_DATAALIGN_RIGHT; AdcHandle.Init.NbrOfConversion = 1; AdcHandle.Init.DMAContinuousRequests = ENABLE; AdcHandle.Init.EOCSelection = DISABLE;,Configure the ADC peripheral
sConfig.Channel = ADCx_CHANNEL; sConfig.Rank = 1; sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES; sConfig.Offset = 0;,Configure ADC regular channel
"HAL_ADC_Start_DMA(&AdcHandle, (uint32_t*)&uhADCxConvertedValue, 1)",Start the conversion process and enable interrupt
BSP_LED_On(LED1);,Turn LED1 on: Transfer process is correct
HAL_UART_MspInit(UART_HandleTypeDef* huart),called from HAL_UART_Init
__HAL_RCC_USART1_CLK_ENABLE();,Enable clock for USART1 peripheral
__HAL_RCC_USART2_CLK_ENABLE();,Enable clock for USART2 peripheral
__HAL_RCC_USART3_CLK_ENABLE();,Enable clock for USART3 peripheral
"HAL_GPIO_Init(uart_uart, &uart_tx);",Initialize GPIO for UART TX
"HAL_GPIO_Init(uart_uart, &uart_rx);",Initialize GPIO for UART RX
"HAL_GPIO_DeInit(uart_uart, uart_pins);",Deinitialize GPIO pins for UART
"if (sr & USART_SR_RXNE) { uint8_t ch = uart->DR; rbuf_write(&rx_rbuf, ch); return; }",Handle RX interrupt: read data and store in ring buffer
if (sr & USART_SR_TXE) { if (rbuf_is_empty(&tx_rbuf)) uart->CR1 &= ~USART_CR1_TXEIE; else uart->DR = rbuf_read(&tx_rbuf); },Handle TX interrupt: send data from ring buffer or disable TX interrupt if empty
serial_init(uint32_t baud),Initialize UART with specified baud rate
uart->CR1 |= USART_CR1_RXNEIE;,enable RX interrupt
uart->CR1 |= USART_CR1_TXEIE;,enable TX interrupt to start transmit
serial_puts(const char *str),"Send string over UART, converting LF to CR+LF"
"serial_print(const char *format, ...)",Formatted print over UART
SCB->VTOR = (uint32_t)(&g_pfnVectors) & 0xFFFF;,Vector Table Relocation to startup vector table
reenumerate_usb();,Reenumerate USB
TICK_Init();,Initialize tick
vTaskDelete( NULL );,Delete default task
if (htim->Instance == TIM4) { HAL_IncTick(); },Increment tick for TIM4 interrupt
"BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);",Configure User push-button
while (1) { HAL_Delay(1000); BSP_LED_Toggle(LED2); },"Insert a Delay of 1000 ms and toggle LED2, in an infinite loop"
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == BUTTON_SW1_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback.
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM2) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode - This function is called when TIM2 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
"ASK25_LCD_Init(Inc, DispShiftOff);",initialize LCD
"ASK25_LCD_Display_String(""EDUTECH"",1,1,Off);",display string
BSP_LED_Init(LED1);,Initialize LED 1
BSP_LED_Init(LED2);,Initialize LED 2
static void LED_Thread1(void const *argument) { uint32_t count = 0; (void) argument; for (;;) { count = osKernelSysTick() + 5000; while (count >= osKernelSysTick()) { BSP_LED_Toggle(LED1); osDelay(200); } BSP_LED_Off(LED1); osThreadSuspend(NULL); count = osKernelSysTick() + 5000; while (count >= osKernelSysTick()) { BSP_LED_Toggle(LED1); osDelay(400); } osThreadResume(LEDThread2Handle); } },Toggle LED1 thread 1
static void LED_Thread2(void const *argument) { uint32_t count; (void) argument; for (;;) { count = osKernelSysTick() + 10000; while (count >= osKernelSysTick()) { BSP_LED_Toggle(LED2); osDelay(500); } BSP_LED_Off(LED2); osThreadResume(LEDThread1Handle); osThreadSuspend(NULL); } },Toggle LED2 thread 2
all_rcc_clk_enable();,"enable all LED, Button, Uart, USB clock"
SysTick_Config(SystemCoreClock / 1000);,1ms tick timer
__HAL_RCC_USB_CLK_ENABLE();,Start USB clock
"printf(""Hello World!\r\n"");",Print Hello World via UART
"int fputc(int ch, FILE *f) { uint8_t temp[1] = {ch}; HAL_UART_Transmit(&huart1, temp, 1, 2); return ch; }",Redirect printf to UART
"void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { printf(""%c\r\n"", aRxBuffer[0]); HAL_UART_Receive_IT(&huart1,(uint8_t*)aRxBuffer,1); }",Callback for UART receive complete
"HAL_UART_Transmit(&huart2, lepton_raw, 4800, 1000);",Send the data over USART2
osKernelInitialize();,initialize CMSIS-RTOS
LED_Initialize();,Initialize LED
Buttons_Initialize();,Initialize Buttons
Init_Thread_LED();,Create LED thread
osKernelStart();,start thread execution
"while (1) { while (Buttons_GetState() & 1U); osSignalSet(tid_Thread_LED, 1U); osDelay(500); }",Wait while holding USER button - Signal LED thread - Wait 500ms
IWDG_DisDebugMCU();,Disable IWDG during debug
MX_GPIO_Init();,Initialize GPIO pins and ports
MX_TIM7_Init();,Initialize Timer 7 peripheral
MX_USART2_UART_Init();,Initialize USART2 peripheral for UART communication
MX_IWDG_Init();,Initialize independent watchdog timer
MX_NVIC_Init();,Initialize interrupts
BLDR_IfUartEnter(NULL);,Enter UART bootloader.
__GPIOA_CLK_ENABLE();,Enable each GPIO Clock (to be able to program the configuration registers)
"GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Pin = GPIO_PIN_4; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure IOs in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Pin = GPIO_PIN_3; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Cobfigure PA3 in Input Mode with Pull-up
"while (1) { if(HAL_GPIO_ReadPin(GPIOA,GPIO_PIN_3) == GPIO_PIN_RESET) { HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_SET); } else { HAL_GPIO_WritePin(GPIOA,GPIO_PIN_4,GPIO_PIN_RESET); } }",Activate LED on Buttonpress
"USBD_DFU_RegisterMedia(&USBD_Device, &USBD_DFU_Flash_fops);",Add DFU Media interface
USBD_Start(&USBD_Device);,Start Device Process
if (BSP_LED_Init(LED3) != BSP_ERROR_NONE) { Error_Handler(); },Initialize status LEDs
"if (SECURE_HASH_SHA1_8BITS((uint8_t *)aInput, strlen((char const *)aInput), (uint8_t *)aSHA1Digest) == SUCCESS) { if (memcmp(aSHA1Digest, aExpectSHA1Digest, sizeof(aExpectSHA1Digest) / sizeof(aExpectSHA1Digest[0])) != 0) { BSP_LED_On(LED3); } else { BSP_LED_On(LED1); } } else { Error_Handler(); }",Call Secure HASH SHA-1 service
static void MX_DMA_Init(void) { __HAL_RCC_DMAMUX1_CLK_ENABLE(); __HAL_RCC_DMA2_CLK_ENABLE(); },Enable DMA controller clock
void SecureFault_Callback(void) { Error_Handler(); },Callback called by secure code following a secure fault interrupt
void SecureError_Callback(void) { Error_Handler(); },Callback called by secure code following a GTZC TZIC secure interrupt (GTZC_IRQn)
BSP_LED_Init(LED4);,Initialize LED 4
BSP_RTC_Init();,Initialize RTC
BSP_RTC_TimeStamp_Init(RTC_TIMESTAMPEDGE_RISING);,Time stamp event detection on PIN C13 Rising edge mode
void HAL_RTCEx_TimeStampEventCallback(RTC_HandleTypeDef *hrtc) { BSP_LED_Toggle(LED4); },Time stamp event callback
init_sysclk_216MHz();,Initialise system clock to 216 MHz
init_random();,Initialise random number generator
"void leds_off(void) { write_gpio(led1, LOW); write_gpio(led2, LOW); write_gpio(led3, LOW); write_gpio(led4, LOW); write_gpio(led5, LOW); write_gpio(led6, LOW); }",Turn off all LEDs
BSP_UART_Init(115200);,Initialize UART
ASK25_LED_Init(ALEDALL);,initialize GPIOE.8 to GPIOE.15 as output pin to blink LEDs on ASK25
ASK25_LED_Off(ALEDALL);,Turn off all LEDs
ASK25_LED_Toggle(ALEDALL);,Toggle all LEDs
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM14) { HAL_IncTick(); } },Period elapsed callback in non blocking mode
MX_LPUART1_UART_Init(); MX_USART1_UART_Init(); MX_USART2_UART_Init();,Initialize UART peripherals
"int fputc(int ch, FILE *f) { if (ch == '\n') { HAL_UART_Transmit(&huart1, (void *)""\r"", 1, 30000); } HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Redirect printf to UART1
"int fgetc(FILE *f) { uint8_t ch = 0; HAL_UART_Receive(&huart1, &ch, 1, 30000); return ch; }",Redirect fgetc to UART1
"bool_t uart_at_init(int baud) { memset(&g_atio_cb, 0, sizeof(g_atio_cb)); if (false == osal_semp_create(&g_atio_cb.rcvsync, CN_RCVMEM_LEN, 0)) { printf(""%s:semp create error\n\r"", __FUNCTION__); goto EXIT_SEMP; } ring_buffer_init(&g_atio_cb.rcvring, g_atio_cb.rcvringmem, CN_RCVMEM_LEN, 0, 0); uart_at.Instance = s_pUSART; uart_at.Init.BaudRate = baud; uart_at.Init.WordLength = UART_WORDLENGTH_8B; uart_at.Init.StopBits = UART_STOPBITS_1; uart_at.Init.Parity = UART_PARITY_NONE; uart_at.Init.HwFlowCtl = UART_HWCONTROL_NONE; uart_at.Init.Mode = UART_MODE_TX_RX; uart_at.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&uart_at) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } __HAL_UART_CLEAR_FLAG(&uart_at, UART_FLAG_TC); LOS_HwiCreate(s_uwIRQn, 3, 0, atio_irq, 0); __HAL_UART_ENABLE_IT(&uart_at, UART_IT_IDLE); __HAL_UART_ENABLE_IT(&uart_at, UART_IT_RXNE); return true; EXIT_SEMP: return false; }",use this function to initialize the uart
"void uartat_deinit(void) { __HAL_UART_DISABLE(&uart_at); __HAL_UART_DISABLE_IT(&uart_at, UART_IT_IDLE); __HAL_UART_DISABLE_IT(&uart_at, UART_IT_RXNE); }",Deinitialize UART
"static void init_clocks(void) { static const RCC_OscInitTypeDef rcc_osc_init = { RCC_OSCILLATORTYPE_HSE, RCC_HSE_ON, RCC_HSE_PREDIV_DIV1, 0, 0, 0, 0, { RCC_PLL_ON, RCC_PLLSOURCE_HSE, RCC_PLL_MUL9 } }; static const RCC_ClkInitTypeDef rcc_clk_init = { (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2), RCC_SYSCLKSOURCE_PLLCLK, RCC_SYSCLK_DIV1, RCC_HCLK_DIV2, RCC_HCLK_DIV1 }; HAL_RCC_OscConfig((RCC_OscInitTypeDef*)&rcc_osc_init); HAL_RCC_ClockConfig((RCC_ClkInitTypeDef*)&rcc_clk_init, FLASH_LATENCY_2); __HAL_RCC_PWR_CLK_ENABLE(); SystemCoreClockUpdate(); }",reconfigure clocks
"static void Blink(int count) { int i; for (i = 0; i < count; i++) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(50); HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(200); } HAL_Delay(500); }",Blink LED
MPU_Config();,Set MPU regions
MPU_AccessPermConfig();,Configure MPU access permissions
HAL_Delay(100);,Insert a delay
"HAL_UART_Transmit(&huart4, (void *)""\r"", 1, 30000);",Transmit carriage return before newline
"HAL_UART_Transmit(&huart4, (uint8_t *)&ch, 1, 0xFFFF);",Transmit character over UART4
"HAL_UART_Transmit(&huart4, (uint8_t *)ptr, len, 0xFFFF);",Transmit data over UART4
"HAL_UART_Receive(&huart4, &ch, 1, 30000);",Receive character over UART4
MX_UART4_Init();,Initialize UART4 peripheral for serial communication
MX_USART1_UART_Init();,Initialize USART1 peripheral for serial communication
MX_MEMS_Process();,Initialize MEMS sensor peripherals
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,Configure the main internal regulator output voltage
HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)","Initializes the CPU, AHB and APB buses clocks"
__HAL_RCC_GPIOC_CLK_ENABLE();,GPIO Port C Clock Enable
__HAL_RCC_GPIOH_CLK_ENABLE();,GPIO Port H Clock Enable
__HAL_RCC_GPIOA_CLK_ENABLE();,GPIO Port A Clock Enable
__HAL_RCC_GPIOB_CLK_ENABLE();,GPIO Port B Clock Enable
"GPIO_InitStruct.Pin = GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pin : PB10
HW_SPI_Init();,Initialize SPI hardware
SPI1_Init();,Initialize SPI1
delay_init(80);,Initialize delay with 80 MHz system clock
uart_init(115200);,Initialize UART with 115200 baud rate
Control_GPIO_Init();,Initialize control GPIOs
CC1125_Init();,Initialize CC1125 radio module
"printf(""Tx\r\n"");",Print transmission start message
"printf(""CR=4/%d, CRC=%s, IMPL_HEAD=%s, LDR=%s\n"",4+LORA_CR_NO1,LORA_HAS_CRC_NO1?""ON"":""OFF"",LORA_IMPL_HEAD_NO1?""ON"":""OFF"",LORA_LOWDATERATEOPTIMIZE_NO1?""ON"":""OFF"");",Print LoRa configuration
"printf(""FREQ1:%d,sf1:%d,\r\nFREQ2:%d,sf2:%d\r\n"",RF_FREQUENCY_NO1,LORA_SF_NO1,RF_FREQUENCY_NO2,LORA_SF_NO2);",Print LoRa frequency and spreading factor settings
for (int j = 0; j < BufferSize; j++) { Tx_Buffer[j] = 0x31; },Fill transmit buffer with 0x31
"packet_freq_points_No1 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO1, LORA_CR_NO1, LORA_HAS_CRC_NO1, LORA_IMPL_HEAD_NO1, &symbol_len_No1, LORA_LOWDATERATEOPTIMIZE_NO1);",Encode LoRa channel data for first packet
"packet_freq_points_No2 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO2, LORA_CR_NO2, LORA_HAS_CRC_NO2, LORA_IMPL_HEAD_NO2, &symbol_len_No2, LORA_LOWDATERATEOPTIMIZE_NO2);",Encode LoRa channel data for second packet in double mode
free(packet_freq_points_No1);,Free memory for first packet frequency points
free(packet_freq_points_No2);,Free memory for second packet frequency points
"printf(""Tx done, Count:%d\r\n"",i+1);",Print transmission completion with packet count
delay_ms(INTERVAL_TIME);,Delay between transmissions
"printf(""finish!!\r\n"");",Print completion message
"osThreadCreate(osThread(timeTask), NULL);",Create the thread(s)
"HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = LED_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LED_Pin
MX_LPUART1_UART_Init();,Initialize low-power UART1 peripheral
MX_LPTIM1_Init();,Initialize low-power timer 1 peripheral
morse_1_init();,Initialize Morse code module
morse_1_step();,Process Morse code step
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1_BOOST);,Configure the main internal regulator output voltage
"HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4)","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1|RCC_PERIPHCLK_LPTIM1; PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1; PeriphClkInit.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSI; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Initializes the peripherals clocks
hlptim1.Instance = LPTIM1; hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC; hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1; hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE; hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH; hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE; hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL; hlptim1.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO; hlptim1.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO; HAL_LPTIM_Init(&hlptim1),Initialize LPTIM1
"HAL_UART_Transmit(&hlpuart1, (uint8_t *)&ch, 1, 0xFFFF);",Transmit character over LPUART1
"HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8)",Set TX FIFO threshold
"HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8)",Set RX FIFO threshold
HAL_UARTEx_DisableFifoMode(&hlpuart1),Disable FIFO mode
__HAL_RCC_GPIOF_CLK_ENABLE();,GPIO Port F Clock Enable
"GPIO_InitStruct.Pin = USER_BUTTON_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : USER_BUTTON_Pin
"GPIO_InitStruct.Pin = USER_LED_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(USER_LED_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : USER_LED_Pin
BSP_LED_Init(LED3);,Initialize BSP Led for LED3
UartHandle.Instance = USARTx; UartHandle.Init.BaudRate = 9600; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_ODD; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; HAL_UART_Init(&UartHandle),Configure the UART peripheral
"printf(""\n\r UART Printf Example: retarget the C library printf function to the UART\n\r"");",Output a message on Hyperterminal using printf function
"printf(""** Test finished successfully. ** \n\r"");",Output a message on Hyperterminal using printf function
MX_ADC1_Init();,Initialize ADC1 peripheral
MX_USART2_UART_Init();,Initialize USART2 peripheral
hadc1.Instance = ADC1; hadc1.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4; hadc1.Init.Resolution = ADC_RESOLUTION12b; hadc1.Init.ScanConvMode = DISABLE; hadc1.Init.ContinuousConvMode = DISABLE; hadc1.Init.DiscontinuousConvMode = DISABLE; hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE; hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT; hadc1.Init.NbrOfConversion = 1; hadc1.Init.DMAContinuousRequests = DISABLE; hadc1.Init.EOCSelection = EOC_SINGLE_CONV; HAL_ADC_Init(&hadc1);,"Configure the global features of the ADC (Clock, Resolution, Data Alignment and number of conversion)"
"sConfig.Channel = ADC_CHANNEL_0; sConfig.Rank = 1; sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES; HAL_ADC_ConfigChannel(&hadc1, &sConfig);",Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time.
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pins : PC0 PC1
"GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pins : PC2 PC3
"GPIO_InitStruct.Pin = LD2_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_LOW; HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LD2_Pin
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
init_hardware();,Initialize hardware
init_heap();,Initialize heap memory
"FreeRTOS_IPInit(ipaddr, netmask, gwaddr, dnsaddr, macaddr);",Initialise networking task
"xTaskCreate(blinker, ""blinker"", 512, ""1"", configMAX_PRIORITIES - 1, NULL);",Create blinker task for LED2
"xTaskCreate(blinker, ""blinker"", 512, ""2"", configMAX_PRIORITIES - 1, NULL);",Create blinker task for LED3
vTaskStartScheduler();,Start FreeRTOS scheduler
gpio_toggle(pin);,Toggle LED pin
vTaskDelay(pdMS_TO_TICKS(ms));,Delay task for specified milliseconds
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable GPIOA clock
__HAL_RCC_GPIOC_CLK_ENABLE();,Enable GPIOC clock
__HAL_RCC_GPIOG_CLK_ENABLE();,Enable GPIOG clock
"GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Alternate = GPIO_AF11_ETH; GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_7; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);",Initialize GPIO pins for Ethernet on GPIOA
"GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);",Initialize GPIO pins for Ethernet on GPIOC
"GPIO_InitStructure.Pin = GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14; HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);",Initialize GPIO pins for Ethernet on GPIOG
"HAL_NVIC_SetPriority(ETH_IRQn, 0x7, 0); HAL_NVIC_EnableIRQ(ETH_IRQn);",Enable Ethernet interrupt
__HAL_RCC_ETH_CLK_ENABLE();,Enable Ethernet clock
"pin_state = !pin_state; HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, pin_state);",Toggle GPIO pin PB13
HAL_Delay(1000);,Delay for 1 second
huart2.Instance = USART2; huart2.Init.BaudRate = 38400; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; HAL_UART_Init(&huart2);,Initialize USART2
__HAL_RCC_GPIOC_CLK_ENABLE();,Enable clock for GPIO C port
__HAL_RCC_GPIOF_CLK_ENABLE();,Enable clock for GPIO F port
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable clock for GPIO A port
__HAL_RCC_GPIOB_CLK_ENABLE();,Enable clock for GPIO B port
"GPIO_InitStruct.Pin = B1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : B1_Pin
"GPIO_InitStruct.Pin = LD2_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LD2_Pin
"HAL_UART_Transmit(&huart1, (void *)""\r"", 1,30000);",Handle '\n' to send '\r' first for proper newline
"HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);",Transmit single character over UART
"HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF);",Transmit buffer over UART
"HAL_UART_Receive(&huart1, &ch, 1,30000);",Receive single character over UART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Set oscillator type to HSI
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Enable internal high-speed oscillator
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL for frequency multiplication
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;,Set PLL input source to HSI
RCC_OscInitStruct.PLL.PLLM = 8;,Set PLL divider M to 8
RCC_OscInitStruct.PLL.PLLN = 180;,Set PLL multiplier N to 180
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;,Set PLL divider P to 2
RCC_OscInitStruct.PLL.PLLQ = 8;,Set PLL divider Q to 8
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Apply oscillator configuration or trigger error handler
if (HAL_PWREx_EnableOverDrive() != HAL_OK) { Error_Handler(); },Activate the Over-Drive mode
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Configure AHB, APB buses, and SYSCLK"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set system clock source to PLL
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Disable AHB clock division (full speed)
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;,Divide APB1 clock by 4
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Divide APB2 clock by 2
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }",Apply clock configuration and handle errors
board_init();,Initialize hardware components
MX_USART1_UART_Init();,Initialize USART1
dwt_delay_init(SystemCoreClock);,Initialize DWT delay
MX_RNG_Init();,Initialize RNG
"printf(""hardware init ok\r\n"");",Print initialization confirmation
MPU_Config();,MPU Configuration
SCB_EnableICache();,Enable I-Cache
SCB_EnableDCache();,Enable D-Cache
MX_FMC_Init();,Initialize the FMC (Flexible Memory Controller) peripheral
MX_I2C3_Init();,Initialize I2C3 peripheral
MX_LTDC_Init();,Initialize LTDC (LCD-TFT Display Controller) peripheral
MX_QUADSPI_Init();,Initialize Quad-SPI peripheral for external memory
MX_TouchGFX_Init();,Initialize TouchGFX for graphics display
osKernelInitialize();,Init scheduler
__HAL_RCC_PWR_CLK_ENABLE();,Configure the main internal regulator output voltage
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Initializes the RCC Oscillators according to the specified parameters
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Configure clock for CPU, AHB, and APB buses"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set the system clock source to PLL
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set the AHB clock divider
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;,Set the APB1 clock divider
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Set the APB2 clock divider
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK) { Error_Handler(); }",Configure clock settings with the specified latency
PeriphClkInitStruct.PLLSAIDivR = RCC_PLLSAIDIVR_8;,Set the PLLSAI divider for peripheral clocks
PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1;,Set the I2C3 clock source
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { Error_Handler(); },Configure peripheral clocks based on the settings
HAL_MPU_Disable();,Disable the Memory Protection Unit (MPU)
MPU_InitStruct.Enable = MPU_REGION_ENABLE;,Configure the MPU region and memory protection settings
MPU_InitStruct.Size = MPU_REGION_SIZE_256MB;,Configure the size of the MPU region
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;,Set the MPU region type extension field
MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;,Set the access permissions for the MPU region
MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;,Set the shareability setting for the MPU region
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;,Set the cacheable setting for the MPU region
HAL_MPU_ConfigRegion(&MPU_InitStruct);,Configure the MPU region with the specified settings
MPU_InitStruct.Number = MPU_REGION_NUMBER1;,Configure the second MPU region and memory protection
MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;,Set the second MPU region as cacheable
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);,Enables the MPU
if (htim->Instance == TIM6) { HAL_IncTick(); },Period elapsed callback in non blocking mode
HAL_Delay(500);,Insert 500 ms delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Configure oscillator type to HSI
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Enable HSI oscillator
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;,Set the default calibration value for HSI
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL oscillator
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;,Set PLL source to HSI
RCC_OscInitStruct.PLL.PLLM = 8;,Set PLL M divider to 8
RCC_OscInitStruct.PLL.PLLN = 200;,Set PLL N multiplier to 200
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;,Set PLL P divider to DIV2
RCC_OscInitStruct.PLL.PLLQ = 2;,Set PLL Q divider to 2
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },"Check for successful oscillator configuration, handle errors"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Configure clock types for HCLK, SYSCLK, PCLK1, and PCLK2"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set SYSCLK source to PLL clock
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock divider to SYSCLK/1
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Set APB2 clock divider to HCLK/2
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6) != HAL_OK) { Error_Handler(); }","Check for successful clock configuration, handle errors"
"osThreadStaticDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 128, defaultTaskBuffer, &defaultTaskControlBlock);",definition and creation of defaultTask
"defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);",definition and creation of defaultTask
LL_FLASH_SetLatency(LL_FLASH_LATENCY_2);,Configure system clock latency
LL_RCC_HSE_EnableBypass();,Enable HSE bypass
LL_RCC_HSE_Enable();,Enable HSE
while(LL_RCC_HSE_IsReady() != 1) {},Wait till HSE is ready
"LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSE_DIV_1, LL_RCC_PLL_MUL_3);",Configure PLL
LL_RCC_PLL_Enable();,Enable PLL
while(LL_RCC_PLL_IsReady() != 1) {},Wait till PLL is ready
LL_RCC_SetAHBPrescaler(LL_RCC_SYSCLK_DIV_1);,Set AHB prescaler
LL_RCC_SetAPB1Prescaler(LL_RCC_APB1_DIV_2);,Set APB1 prescaler
LL_RCC_SetAPB2Prescaler(LL_RCC_APB2_DIV_1);,Set APB2 prescaler
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);,Set system clock source
while(LL_RCC_GetSysClkSource() != LL_RCC_SYS_CLKSOURCE_STATUS_PLL) {},Wait till System clock is ready
LL_Init1msTick(72000000);,Initialize 1ms tick
LL_SYSTICK_SetClkSource(LL_SYSTICK_CLKSOURCE_HCLK);,Set SysTick clock source
LL_SetSystemCoreClock(72000000);,Set system core clock
LL_RCC_ConfigMCO(LL_RCC_MCO1SOURCE_PLLCLK_DIV_2);,Configure MCO
LL_RCC_SetUSBClockSource(LL_RCC_USB_CLKSOURCE_PLL_DIV_1_5);,Set USB clock source
GPIO_InitStruct.Pin = LL_GPIO_PIN_8;,Configure pin 8 for MCO alternate function
GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;,Set pin mode to alternate function
GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_LOW;,Set pin speed to low frequency
GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;,Set pin output type to push-pull
"LL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Initialize pin 8 with alternate function on GPIOA
MX_USB_DEVICE_Init();,init code for USB_DEVICE
osDelay(1);,Delay task for 1ms
if (htim->Instance == TIM7) { HAL_IncTick(); },Period elapsed callback in non blocking mode
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/RHINO_CONFIG_TICKS_PER_SECOND);,Configure the Systick interrupt time
stduart_init();,default uart init
brd_peri_init();,Initialize board peripherals
MX_DMA_Init();,Initialize DMA
MX_SAI1_Init();,Initialize SAI1
MX_SPI1_Init();,Initialize SPI1
MX_CRC_Init();,Initialize CRC
drv_codec_nau8810_init();,Initialize audio codec
audio_init();,Initialize audio
uart_0.config.baud_rate = 115200;,Configure UART baud rate
uart_0.config.data_width = DATA_WIDTH_8BIT;,Configure UART data width
uart_0.config.flow_control = FLOW_CONTROL_DISABLED;,Configure UART flow control
uart_0.config.mode = MODE_TX_RX;,Configure UART mode
uart_0.config.parity = NO_PARITY;,Configure UART parity
uart_0.config.stop_bits = STOP_BITS_1;,Configure UART stop bits
hal_uart_init(&uart_0);,Initialize UART
hal_i2c_init(&brd_i2c1_dev);,Initialize I2C1
hal_i2c_init(&brd_i2c2_dev);,Initialize I2C2
HAL_IncTick();,Increment system tick
krhino_intrpt_enter();,Enter interrupt context
krhino_tick_proc();,Process RTOS tick
krhino_intrpt_exit();,Exit interrupt context
lv_tick_inc(1);,Increment LittlevGL tick
"if (ch == '\n') { hal_uart_send(&uart_0, (void *)""\r"", 1, 30000); }",Handle newline for UART output
"hal_uart_send(&uart_0, &ch, 1, 30000);",Send character over UART
"ret = hal_uart_recv_II(&uart_0, &ch, 1, &recv_size, HAL_WAIT_FOREVER);",Receive character over UART
BSP_LED_Init(LED1);,Initialize Led 1 mounted on STM327x6G-EVAL board
BSP_LED_Init(LED2);,Initialize Leds 2 mounted on STM327x6G-EVAL board
BSP_LED_Init(LED3);,Initialize Led 3 mounted on STM327x6G-EVAL board
BSP_LED_Init(LED4);,Initialize Led 4 mounted on STM327x6G-EVAL board
BSP_LED_On(LED1);,Turn on LED1
BSP_LED_On(LED3);,Turn on LED3
if (SysTick_Config(SystemCoreClock / 1000)) { while (1) {} },Setup SysTick Timer for 1 msec interrupts
BSP_LED_Toggle(LED2);,Toggle LED2 and LED4
BSP_LED_Toggle(LED4);,Toggle LED2 and LED4
HAL_Delay(50);,Insert 50 ms delay
BSP_LED_Toggle(LED1);,Toggle LED1 and LED3
BSP_LED_Toggle(LED3);,Toggle LED1 and LED3
HAL_Delay(100);,Insert 100 ms delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_OscInitStruct.HSEState = RCC_HSE_ON;,Turn on HSE Oscillator
RCC_OscInitStruct.HSIState = RCC_HSI_OFF;,Turn off HSI Oscillator
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Select HSE as PLL source
RCC_OscInitStruct.PLL.PLLM = 25;,Set PLLM value to 25
RCC_OscInitStruct.PLL.PLLN = 432;,Set PLLN value to 432
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;,Set PLLP divider to 2
RCC_OscInitStruct.PLL.PLLQ = 9;,Set PLLQ value to 9
HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure RCC Oscillators with the specified settings
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,Select PLL as system clock source
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,"Configure AHB, APB1, and APB2 clocks dividers"
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock divider to 1
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;,Set APB1 clock divider to 4
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Set APB2 clock divider to 2
HAL_MPU_Disable();,Disable the MPU
MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;,Configure the MPU region as non-bufferable
MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE;,Configure the MPU region as non-cacheable
MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;,Set the region type to Level 0 for external access
HAL_MPU_ConfigRegion(&MPU_InitStruct);,Configure the MPU with the specified region settings
HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);,Enable the MPU
__HAL_RCC_GPIOC_CLK_ENABLE();,Enable GPIOC clock for LED
GPIO_InitStruct.Pin = LED_PIN;,Configure LED pin
"HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);",Configure LED pin
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable GPIOA clock for button and USB
GPIO_InitStruct.Pin = BUTTON_PIN;,Configure button pin
"HAL_GPIO_Init(BUTTON_PORT, &GPIO_InitStruct);",Configure button pin
GPIO_InitStruct.Pin = (GPIO_PIN_11 | GPIO_PIN_12);,Configure USB DM and DP pins
__HAL_RCC_USB_CLK_ENABLE();,USB Clock enable
"HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN);",Read button state
system_ticks++;,Increment system tick
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Enable the HSE Oscillator and activate PLL with HSE as the source
oscinitstruct.HSEState = RCC_HSE_ON;,Set HSE state to ON
oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;,Set HSE pre-divider value to divide by 1
oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL9;,Configure PLL multiplication factor to 9
oscinitstruct.PLL.PLLState = RCC_PLL_ON;,Enable the PLL and set its source to HSE
oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Apply the configuration to the RCC oscillators
HAL_RCC_OscConfig(&oscinitstruct);,Enable HSE Oscillator and activate PLL with HSE as source
rccperiphclkinit.PeriphClockSelection = RCC_PERIPHCLK_USB;,USB clock selection
rccperiphclkinit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;,USB clock selection
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,"Select PLL as the system clock source and configure the HCLK, PCLK1, and PCLK2 clock dividers"
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set the system clock source to PLL
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set the AHB clock divider to 1
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;,Set the APB1 clock divider to 2
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;,Set the APB2 clock divider to 1
"lis3de_data_rate_set(&dev_ctx, LIS3DE_ODR_100Hz);",Set Output Data Rate to 100 Hz
"lis3de_full_scale_set(&dev_ctx, LIS3DE_2g);",Set full scale to 2 g
ctrl_reg3.int1_ig1 = PROPERTY_ENABLE;,Enable AOI1 interrupt on INT pin 1
"lis3de_pin_int1_config_set(&dev_ctx, &ctrl_reg3);",Enable AOI1 interrupt on INT pin 1
"lis3de_int1_pin_notification_mode_set(&dev_ctx, LIS3DE_INT1_LATCHED);",Enable Interrupt 1 pin latched
"lis3de_int1_gen_threshold_set(&dev_ctx, 0x16);",Set threshold to 16h -> 350 mg
"lis3de_int1_gen_duration_set(&dev_ctx, 0x03);",Set Duration to 03h -> minimum event duration
ig1_cfg.aoi = PROPERTY_ENABLE;,Configure free-fall recognition
"lis3de_int1_gen_conf_set(&dev_ctx, &ig1_cfg);",Configure free-fall recognition
"lis3de_operating_mode_set(&dev_ctx, LIS3DE_LP);",Set device in HR mode
"if (platform_reap_int_pin()) { lis3de_int1_gen_source_get(&dev_ctx, &src); sprintf((char *)tx_buffer, ""freefall detected\r\n""); tx_com(tx_buffer, strlen((char const *)tx_buffer)); }",Poll on platform INT pin 1 waiting for free fall event detection
reg |= 0x80;,Set MSB for multiple read/write command
"HAL_UART_Transmit(&huart2, tx_buffer, len, 1000);",Send buffer to console
HAL_Delay(ms);,platform specific delay
"HAL_UART_Transmit(&huart3, ""Hello from the board\n\r"", 24, 100);",The string lenght to transmit is 24 characters long
HAL_Delay(1000);,Insert 1000 ms delay
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,Configure the main internal regulator output voltage
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Enable HSI oscillator and set default calibration value
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Set PLL state to none
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;,Initialize RCC oscillators with specified parameters
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,Handle error if oscillator configuration fails
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Configure CPU, AHB, and APB buses clocks"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI;,Set SYSCLK source to HSI
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;,Set APB1 clock divider to 2
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Set APB2 clock divider to 1
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }",Handle error if clock configuration fails
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3;,Configure USART3 clock
PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;,Configure USART3 clock
huart3.Init.BaudRate = 115200;,Configure USART3 baud rate to 115200
huart3.Init.WordLength = UART_WORDLENGTH_8B;,Set word length to 8 bits for USART3
huart3.Init.StopBits = UART_STOPBITS_1;,Set stop bits to 1 for USART3
huart3.Init.Parity = UART_PARITY_NONE;,Set parity to none for USART3
huart3.Init.Mode = UART_MODE_TX_RX;,Set mode to TX and RX for USART3
huart3.Init.OverSampling = UART_OVERSAMPLING_16;,Set oversampling to 16 for USART3
huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;,Disable one-bit sampling for USART3
setup_usart();,init the UART for diagnostics
"printf(""SYSCLK = %d\n\r"", HAL_RCC_GetSysClockFreq());",Print system clock frequency
led_init();,init LED
spi_init();,init SPI
usb_init();,init USB
"if(prev_ser_state != ser_state) { prev_ser_state = ser_state; printf(""State = %d, err = %d\n\r"", prev_ser_state, ser_err); if(prev_ser_state) { led_on(LED1); } else { led_off(LED1); } }",Handle state change and update LED
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;,"Enable HSI48 oscillator for CPU, AHB, and APB buses clock initialization"
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;,Activate HSI48 oscillator
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,Disable PLL during clock configuration
"if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Initialize RCC oscillators with the specified HSI48 configuration
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1;,Select HSI48 as the system clock source
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;,Set AHB clock divider to 1 (no division)
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set APB1 clock divider to 1 (no division)
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,Apply clock configuration and set flash latency to 1
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Handle errors if HAL_RCC_OscConfig or HAL_RCC_ClockConfig fails
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB;,Configure USB clock
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;,Configure USB clock
__HAL_RCC_CRS_CLK_ENABLE();,Enable the SYSCFG APB clock
RCC_CRSInitStruct.Source = RCC_CRS_SYNC_SOURCE_USB;,Configures CRS
HAL_RCCEx_CRSConfig(&RCC_CRSInitStruct);,Configures CRS
HAL_SYSTICK_IRQHandler();,Handle SysTick interrupt
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);",Start PWM on TIM2 Channel 1
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 10; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4)","Initializes the CPU, AHB and APB buses clocks"
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1),Configure the main internal regulator output voltage
"HAL_GPIO_WritePin(LD4_GPIO_Port, LD4_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = SMPS_EN_Pin|SMPS_V1_Pin|SMPS_SW_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : SMPS_EN_Pin SMPS_V1_Pin SMPS_SW_Pin
"GPIO_InitStruct.Pin = SMPS_PG_Pin; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(SMPS_PG_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : SMPS_PG_Pin
"GPIO_InitStruct.Pin = LD4_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LD4_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LD4_Pin
MX_ADC_Init();,Initialize the ADC peripheral with the configured settings
MX_TIM3_Init();,Initialize the TIM3 (Timer 3) peripheral with the configured settings
MX_TIM14_Init();,Initialize the TIM14 (Timer 14) peripheral with the configured settings
MX_USART1_UART_Init();,Initialize the USART1 (Universal Synchronous Asynchronous Receiver-Transmitter) peripheral with the configured settings
MX_SPI1_Init();,Initialize the SPI1 (Serial Peripheral Interface) peripheral with the configured settings
MX_TIM1_Init();,Initialize the TIM1 (Timer 1) peripheral with the configured settings
Init_Retarget(&huart1);,Retarget HW UART to printf
__HAL_RCC_GPIOB_CLK_ENABLE();,Enable GPIOB clock
"gpioPinWrite(i, gpio_tbl[i].init_value);",Set initial GPIO pin value
"HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].off_state);",Write GPIO pin off state
"HAL_GPIO_ReadPin(gpio_tbl[ch].port, gpio_tbl[ch].pin)",Read GPIO pin state
"HAL_GPIO_TogglePin(gpio_tbl[ch].port, gpio_tbl[ch].pin);",Toggle GPIO pin
Stm32_Clock_Init(RCC_PLL_MUL9);,Set clock to 72M
uart_init(115200);,Initialize serial port
LED_Init();,Initialize LED
KEY_Init();,Initialize buttons
LED0 = !LED0;,Flash LED to indicate system is running
delay_ms(10);,Delay for 10 milliseconds
"HAL_UART_Receive_IT(&huart6, &Data, 1)",Receive data on UART6 using interrupt
"HAL_UART_Transmit_IT(&huart6, &Data, 1);",Transmit received data on UART6 using interrupt
__PWR_CLK_ENABLE();,Enable power clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure HSE oscillator and PLL
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);",Configure system clock source and bus clocks
"HAL_UART_Transmit(&huart1, (void *)""\r"", 1, 30000);",Transmit carriage return before newline
"HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF);",Transmit character over USART1
"HAL_UART_Receive(&huart1, &ch, 1, 30000);",Receive character over USART1
"HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF);",Transmit data over USART1
__HAL_RCC_PWR_CLK_ENABLE();,Enable power control clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.LSEState = RCC_LSE_ON; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = 0; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 6; RCC_OscInitStruct.PLL.PLLN = 20; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
hrng.Instance = RNG; HAL_RNG_Init(&hrng);,Initialize RNG
"GPIO_InitStruct.Pin = GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);",Configure GPIO pin : PE1
"HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI1_IRQn);",EXTI interrupt init
"GPIO_InitStruct.Pin = GPIO_PIN_12; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure PA.12 (Arduino D2) as input with External interrupt
"osSemaphore = osSemaphoreCreate(osSemaphore(SEM), 1);",Create the semaphore used by the two threads
"osSemaphoreWait(osSemaphore, 0)",Try to obtain the semaphore
osSemaphoreRelease(osSemaphore);,Release the semaphore from EXTI callback
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5; RCC_OscInitStruct.MSICalibrationValue = 0x00; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; HAL_RCC_OscConfig(&RCC_OscInitStruct),Enable MSI Oscillator
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency
BSP_LED_Init(LED3);,Configure LED3 and LED4
BSP_LED_Init(LED4);,Configure LED3 and LED4
CrcHandle.Instance = CRC; HAL_CRC_Init(&CrcHandle);,Configure the CRC peripheral
BSP_LED_On(LED3);,Right CRC value: Turn LED3 on
HAL_Delay(1000);,Delay for error indication
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; oscinitstruct.HSEState = RCC_HSE_ON; oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV2; oscinitstruct.PLL.PLLState = RCC_PLL_ON; oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL6; HAL_RCC_OscConfig(&oscinitstruct),Enable HSE Oscillator and activate PLL with HSE as source
"clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1; clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1; clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_0)","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
__HAL_RCC_PWR_CLK_ENABLE();,Enable power clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 216; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7)","Initializes the CPU, AHB and APB buses clocks"
HAL_PWREx_EnableOverDrive(),Activate the Over-Drive mode
__HAL_RCC_DMA2_CLK_ENABLE();,DMA controller clock enable
"HAL_NVIC_SetPriority(DMA2_Stream2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(DMA2_Stream2_IRQn);",DMA interrupt init
AdcHandle.Instance = ADCx; AdcHandle.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4; AdcHandle.Init.Resolution = ADC_RESOLUTION_12B; AdcHandle.Init.ScanConvMode = DISABLE; AdcHandle.Init.ContinuousConvMode = ENABLE; AdcHandle.Init.DiscontinuousConvMode = DISABLE; AdcHandle.Init.NbrOfDiscConversion = 0; AdcHandle.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE; AdcHandle.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1; AdcHandle.Init.DataAlign = ADC_DATAALIGN_RIGHT; AdcHandle.Init.NbrOfConversion = 1; AdcHandle.Init.DMAContinuousRequests = DISABLE; AdcHandle.Init.EOCSelection = DISABLE; if (HAL_ADC_Init(&AdcHandle) != HAL_OK) { Error_Handler(); },Configure the ADC peripheral
"sConfig.Channel = ADC_CHANNEL_10; sConfig.Rank = 1; sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES; sConfig.Offset = 0; if (HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK) { Error_Handler(); }",Configure ADC regular channel
static void Error_Handler(void) { BSP_LED_On(LED2); while (1) { } },This function is executed in case of error occurrence.
if (BSP_LED_Init(LED_RED) != BSP_ERROR_NONE) { Error_Handler(); },Configure LED_RED
if (BSP_LED_Init(LED_GREEN) != BSP_ERROR_NONE) { Error_Handler(); },Configure LED_GREEN
HAL_PWREx_EnterSTOP1Mode(PWR_STOPENTRY_WFI);,Enter in Stop mode
void Error_Handler(void) { (void) BSP_LED_On(LED_RED); while (1) { } },This function is executed in case of error occurrence.
"tcpip_init(NULL, NULL);",Initilialize the LwIP stack without RTOS
"(void)netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);",Add the network interface (IPv4/IPv6) without RTOS
netif_set_default(&gnetif);,Registers the default network interface
"void hieth_hw_init(void) { extern void ETH_IRQHandler(void); (void)LOS_HwiCreate(ETH_IRQn + 16, 1, 0, ETH_IRQHandler, 0); }",Enable Ethernet interrupt
void atiny_reboot(void) { HAL_NVIC_SystemReset(); },Perform system reboot
"void accel_init(void) { GPIO_InitTypeDef GPIO_InitStructure; GPIOB->BSRRH = GPIO_PIN_5; GPIO_InitStructure.Pin = GPIO_PIN_5; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStructure.Speed = GPIO_SPEED_LOW; GPIO_InitStructure.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &GPIO_InitStructure); }",Initialize accelerometer GPIO
STATIC mp_obj_t pyb_accel_z(mp_obj_t self_in) { return read_axis(MMA_REG_Z); },Get the z-axis value.
"GPIO_InitStruct.Pin = LED_PIN; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);",LED
"GPIO_InitStruct.Pin = BUTTON_PIN; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLDOWN; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(BUTTON_PORT, &GPIO_InitStruct);",Button
"trace_printf(""%d\n\r"",uwFrequency);",Display captured frequency
BSP_LED_Init(LED3);,Configure LED
PVD_Config();,Configure the PVD
__HAL_RCC_PWR_CLK_ENABLE();,Enable Power Clock
"HAL_NVIC_SetPriority(PVD_IRQn, 0, 0); HAL_NVIC_EnableIRQ(PVD_IRQn);",Configure the NVIC for PVD
sConfigPVD.PVDLevel = PWR_PVDLEVEL_3; sConfigPVD.Mode = PWR_PVD_MODE_IT_RISING_FALLING; HAL_PWR_ConfigPVD(&sConfigPVD);,"Configure the PVD Level to 3 and generate an interrupt on rising and falling edges(PVD detection level set to 2.5V, refer to the electrical characteristics of you device datasheet for more details)"
HAL_PWR_EnablePVD();,Enable the PVD Output
"int fputc(int ch, FILE *f) { if (ch == '\n') { HAL_UART_Transmit(&huart1, (void *)""\r"", 1,30000); } HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Redirect printf to UART
"int _write(int fd, char *ptr, int len) { (void)HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF); return len; }",Redirect write to UART
"int fgetc(FILE *f) { uint8_t ch = 0; HAL_UART_Receive(&huart1, &ch, 1,30000); return ch; }",Read a character from UART
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Set oscillator type to HSE  
oscinitstruct.HSEState = RCC_HSE_ON;,Enable HSE oscillator  
oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;,Set HSE predivider to divide by 1  
oscinitstruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL  
oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Set PLL source to HSE  
oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL9;,Set PLL multiplication factor to 9  
if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK) { while(1); },Configure oscillator settings and handle error if configuration fails  
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,"Specify clock types for system, AHB, APB1, and APB2  "
clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set PLL as system clock source  
clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock divider to 1  
clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1;,Set APB2 clock divider to 1  
clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;,Set APB1 clock divider to 2
"HAL_UART_Transmit(&huart4, (void *)""\r"", 1, 30000);",Handle '\n' to send '\r' first for proper newline
"HAL_UART_Receive(&huart4, &ch, 1, 30000);",Receive character over UART
board_init();,Initialize board peripherals
HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);,Supply configuration update enable
while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {},Wait for voltage scaling ready
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Set oscillator type to HSI  
RCC_OscInitStruct.HSIState = RCC_HSI_DIV1;,Set HSI oscillator to divide by 1  
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;,Set HSI calibration to default value  
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL  
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI;,Set PLL source to HSI  
RCC_OscInitStruct.PLL.PLLN = 129;,Set PLL multiplication factor N to 129  
RCC_OscInitStruct.PLL.PLLP = 2;,Set PLL division factor P to 2  
RCC_OscInitStruct.PLL.PLLQ = 2;,Set PLL division factor Q to 2  
RCC_OscInitStruct.PLL.PLLR = 2;,Set PLL division factor R to 2  
RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_3;,Set PLL VCO input range to range 3  
RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;,Set PLL VCO selection to wide range  
RCC_OscInitStruct.PLL.PLLFRACN = 0;,Set PLL fractional divider to 0  
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Configure oscillator settings and handle error if configuration fails  
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2|RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;,"Specify clock types for HCLK, SYSCLK, PCLK1, PCLK2, D3PCLK1, and D1PCLK1  "
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set PLL as system clock source  
RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;,Set system clock divider to 1  
RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;,Set AHB clock divider to 2  
RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;,Set APB3 clock divider to 2  
RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;,Set APB1 clock divider to 2  
RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;,Set APB2 clock divider to 2  
RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;,Set APB4 clock divider to 2  
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }",Configure clock settings with flash latency 2 and handle error if configuration fails  
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_UART4|RCC_PERIPHCLK_USART1;,Select UART4 and USART1 peripheral clocks  
PeriphClkInitStruct.Usart234578ClockSelection = RCC_USART234578CLKSOURCE_D2PCLK1;,Set UART2/3/4/5/7/8 clock source to D2PCLK1  
PeriphClkInitStruct.Usart16ClockSelection = RCC_USART16CLKSOURCE_D2PCLK2;,Set USART1/6 clock source to D2PCLK2
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Turn on the HSI oscillator
RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT;,Set HSI calibration to default
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable the PLL
RCC_OscInitStruct.PLL.PLLM = 16;,Set PLLM division factor to 16
RCC_OscInitStruct.PLL.PLLN = 336;,Set PLLN multiplication factor to 336
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;,Set PLLP division factor to 4
RCC_OscInitStruct.PLL.PLLQ = 7;,Set PLLQ division factor to 7
if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Apply oscillator configuration
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,Select clocks to configure
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set APB1 clock divider to 1
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }",Apply clock configuration
GPIO_InitStruct.Pin = GPIO_PIN_10;,Configure GPIO pin : PB10
HW_SPI_Init();,Initialize hardware SPI
delay_init(80);,Initialize delay with 80 MHz clock
"printf(""Tx\r\n"");",Print transmission start
"printf(""FREQ1:%d,sf1:%d,\r\nFREQ2:%d,sf2:%d\r\n"",RF_FREQUENCY_NO1,LORA_SF_NO1,RF_FREQUENCY_NO2,LORA_SF_NO2);",Print frequency and spreading factor settings
"packet_freq_points_No1 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO1, LORA_CR_NO1, LORA_HAS_CRC_NO1, LORA_IMPL_HEAD_NO1, &symbol_len_No1, LORA_LOWDATERATEOPTIMIZE_NO1);",Encode LoRa packet for channel 1
"packet_freq_points_No2 = LoRa_Channel_Coding(data_0x001D004E, 64, LORA_BW, LORA_SF_NO2, LORA_CR_NO2, LORA_HAS_CRC_NO2, LORA_IMPL_HEAD_NO2, &symbol_len_No2, LORA_LOWDATERATEOPTIMIZE_NO2);",Encode LoRa packet for channel 2
"LoRa_Generate_Signal(packet_freq_points_No1,symbol_len_No1);",Generate LoRa signal for channel 1
"LoRa_Generate_Double_Packet(packet_freq_points_No1,symbol_len_No1,packet_freq_points_No2,symbol_len_No2);",Generate dual-channel LoRa packet
free(packet_freq_points_No1);,Free memory for channel 1 packet
free(packet_freq_points_No2);,Free memory for channel 2 packet
"printf(""finish!!\r\n"");",Print transmission sequence completion
init();,Initialize application-specific components
"osThreadCreate(osThread(shutdownMonitorTask), NULL);",Create shutdownMonitorTask thread
"osThreadCreate(osThread(timeTask), NULL);",Create timeTask thread
"osThreadCreate(osThread(controlsTask), NULL);",Create controlsTask thread
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Set oscillator source to external crystal (HSE)
RCC_OscInitStruct.HSEState = RCC_HSE_ON;,Turn on the external oscillator
RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;,Set HSE predivider to 1
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Turn on internal high-speed oscillator
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable the main PLL
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Set PLL input source to HSE
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,Select clock types to configure
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Set system clock source to PLL output
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock to SYSCLK / 1
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,Set APB1 clock to HCLK / 1
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }",Apply clock settings and flash latency
GPIO_InitStruct.Pin = LED_Pin;,Configure GPIO pin : LED_Pin
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD;,Configure GPIO pin : LED_Pin
"HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LED_Pin
if (htim->Instance == TIM4) { HAL_IncTick(); },Period elapsed callback in non blocking mode
"HAL_PWR_EnterSLEEPMode(PWR_MAINREGULATOR_ON, PWR_SLEEPENTRY_WFI);",Enter sleep mode in idle hook
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI;,Set oscillator types to HSI and LSI  
RCC_OscInitStruct.HSIState = RCC_HSI_ON;,Enable HSI oscillator  
RCC_OscInitStruct.LSIState = RCC_LSI_ON;,Enable LSI oscillator  
RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV4;,Set PLL division factor M to 4  
RCC_OscInitStruct.PLL.PLLN = 85;,Set PLL multiplication factor N to 85  
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;,Set PLL division factor P to 2  
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;,Set PLL division factor Q to 2  
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;,Set PLL division factor R to 2  
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Specify clock types for HCLK, SYSCLK, PCLK1, and PCLK2  "
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock divider to 1  
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,Set APB1 clock divider to 1  
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Set APB2 clock divider to 1  
"if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) { Error_Handler(); }",Configure clock settings with flash latency 4 and handle error if configuration fails  
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1|RCC_PERIPHCLK_LPTIM1;,Select LPUART1 and LPTIM1 peripheral clocks  
PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;,Set LPUART1 clock source to PCLK1  
PeriphClkInit.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSI;,Set LPTIM1 clock source to LSI  
if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks and handle error if configuration fails  
hlptim1.Instance = LPTIM1;,Set LPTIM1 instance  
hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;,Set LPTIM1 clock source to APB clock or low-power oscillator  
hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;,Set LPTIM1 prescaler to divide by 1  
hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;,Set LPTIM1 trigger source to software  
hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;,Set LPTIM1 output polarity to high  
hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;,Set LPTIM1 update mode to immediate  
hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;,Set LPTIM1 counter source to internal  
if (HAL_LPTIM_Init(&hlptim1) != HAL_OK) { Error_Handler(); },Initialize LPTIM1 and handle error if initialization fails  
hlpuart1.Instance = LPUART1;,Set LPUART1 instance  
hlpuart1.Init.BaudRate = 115200;,Set LPUART1 baud rate to 115200  
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;,Set LPUART1 word length to 8 bits  
hlpuart1.Init.StopBits = UART_STOPBITS_1;,Set LPUART1 stop bits to 1  
hlpuart1.Init.Mode = UART_MODE_TX_RX;,Set LPUART1 mode to transmit and receive  
hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;,Disable LPUART1 one-bit sampling  
hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1;,Set LPUART1 clock prescaler to divide by 1  
if (HAL_UART_Init(&hlpuart1) != HAL_OK) { Error_Handler(); },Initialize LPUART1 and handle error if initialization fails  
GPIO_InitStruct.Pin = USER_BUTTON_Pin;,Set GPIO pin for user button  
GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING;,Set user button GPIO mode to interrupt on rising edge  
"HAL_GPIO_Init(USER_BUTTON_GPIO_Port, &GPIO_InitStruct);",Initialize user button GPIO  
GPIO_InitStruct.Pin = USER_LED_Pin;,Set GPIO pin for user LED  
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;,Set user LED GPIO mode to output push-pull  
GPIO_InitStruct.Pull = GPIO_NOPULL;,Set user LED GPIO pull to no pull-up/pull-down  
GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;,Set user LED GPIO speed to low  
"HAL_GPIO_Init(USER_LED_GPIO_Port, &GPIO_InitStruct);",Initialize user LED GPIO  
"HAL_UART_Transmit(&hlpuart1, (uint8_t *)&ch, 1, 0xFFFF);",Transmit single character via LPUART1 with timeout  
UartHandle.Init.StopBits = UART_STOPBITS_1;,Set UART stop bits to 1  
UartHandle.Init.Mode = UART_MODE_TX_RX;,Set UART mode to transmit and receive  
"HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 0xFFFF);",Transmit single character via UART with timeout  
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;,Set oscillator type to MSI  
RCC_OscInitStruct.MSIState = RCC_MSI_ON;,Enable MSI oscillator  
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5;,Set MSI clock range to range 5  
RCC_OscInitStruct.MSICalibrationValue = 0x00;,Set MSI calibration value to 0  
if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK) { while(1); },Configure MSI oscillator settings and loop indefinitely if configuration fails  
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,"Specify clock types for SYSCLK, HCLK, PCLK1, and PCLK2  "
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI;,Set MSI as system clock source  
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet"
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,Set power regulator voltage scaling to scale 2  
RCC_OscInitStruct.PLL.PLLM = 16;,Set PLL division factor M to 16  
HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure oscillator settings  
"HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);",Configure system clock with flash latency 2  
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure SysTick interrupt to trigger every millisecond  
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Set SysTick clock source to HCLK
"HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);",SysTick_IRQn interrupt configuration
hadc1.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4;,Set ADC clock prescaler to PCLK divided by 4  
hadc1.Init.Resolution = ADC_RESOLUTION12b;,Set ADC resolution to 12 bits  
hadc1.Init.DiscontinuousConvMode = DISABLE;,Disable discontinuous conversion mode  
hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;,Set ADC data alignment to right  
hadc1.Init.NbrOfConversion = 1;,Set ADC number of conversions to 1  
hadc1.Init.EOCSelection = EOC_SINGLE_CONV;,Set ADC end-of-conversion selection to single conversion  
HAL_ADC_Init(&hadc1);,Initialize ADC with configured settings  
sConfig.Channel = ADC_CHANNEL_0;,Set ADC channel to channel 0  
sConfig.Rank = 1;,Set ADC channel rank to 1  
sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES;,Set ADC sampling time to 3 cycles  
"HAL_ADC_ConfigChannel(&hadc1, &sConfig);",Configure ADC channel settings  
huart2.Instance = USART2;,Set USART2 instance  
huart2.Init.BaudRate = 115200;,Set USART2 baud rate to 115200  
huart2.Init.StopBits = UART_STOPBITS_1;,Set USART2 stop bits to 1  
huart2.Init.Parity = UART_PARITY_NONE;,Set USART2 parity to none  
huart2.Init.Mode = UART_MODE_TX_RX;,Set USART2 mode to transmit and receive  
huart2.Init.OverSampling = UART_OVERSAMPLING_16;,Set USART2 oversampling to 16  
HAL_UART_Init(&huart2);,Initialize USART2 with configured settings
GPIO_InitStruct.Pin = B1_Pin;,Set GPIO pin to B1_Pin  
"HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Initialize B1_Pin GPIO with configured settings  
GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;,Set GPIO pins to PC0 and PC1  
"HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Initialize PC0 and PC1 GPIO with configured settings  
GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;,Set GPIO pins to PC2 and PC3  
"HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Initialize PC2 and PC3 GPIO with configured settings  
GPIO_InitStruct.Pin = LD2_Pin;,Set GPIO pin to LD2_Pin  
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;,Set LD2_Pin GPIO mode to output push-pull  
GPIO_InitStruct.Speed = GPIO_SPEED_LOW;,Set LD2_Pin GPIO speed to low  
"HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);",Initialize LD2_Pin GPIO with configured settings
init_hardware();,Initialize hardware components
mg_mgr_free(&mgr);,Free Mongoose manager
vTaskDelay(pdMS_TO_TICKS(ms));,Delay task
GPIO_InitStructure.Alternate = GPIO_AF11_ETH;,Set GPIO alternate function to Ethernet (AF11)  
GPIO_InitStructure.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5;,"Set GPIO pins to PC1, PC4, and PC5 for Ethernet  "
"HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);","Initialize PC1, PC4, and PC5 GPIO with configured settings  "
GPIO_InitStructure.Pin = GPIO_PIN_2 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;,"Set GPIO pins to PG2, PG11, PG13, and PG14 for Ethernet  "
"HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);","Initialize PG2, PG11, PG13, and PG14 GPIO with configured settings  "
"HAL_NVIC_SetPriority(ETH_IRQn, 0x7, 0);",Set Ethernet interrupt priority to 0x7 with sub-priority 0  
HAL_NVIC_EnableIRQ(ETH_IRQn);,Enable Ethernet interrupt request
HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);,Set NVIC priority grouping
pin_state = !pin_state;,Toggle pin state
HAL_Delay(1000);,Delay for 1000 ms
"void UART_TransmitString(const char* str) { HAL_UART_Transmit(&huart1, (uint8_t*)str, strlen(str), HAL_MAX_DELAY); }",Transmit a string over UART
"void I2C_Scan() { UART_TransmitString(""Scanning I2C bus...\r\n""); HAL_StatusTypeDef res; for(uint16_t i = 0; i < 128; i++) { res = HAL_I2C_IsDeviceReady(&hi2c1, i << 1, 1, 10); if(res == HAL_OK) { char msg[64]; snprintf(msg, sizeof(msg), ""0x%02X"", i); UART_TransmitString(msg); } else { UART_TransmitString("".""); } } UART_TransmitString(""\r\n""); }",Scan I2C bus for devices and print addresses
si5351_Init(correction);,Initialize Si5351 clock generator
"si5351_SetupCLK0(28000000, SI5351_DRIVE_STRENGTH_4MA);",Configure CLK0 to 28MHz with 4mA drive strength
"si5351_SetupCLK2(144000000, SI5351_DRIVE_STRENGTH_4MA);",Configure CLK2 to 144MHz with 4mA drive strength
si5351_EnableOutputs((1<<0) | (1<<2));,Enable CLK0 and CLK2 outputs
"HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);",Toggle GPIO pin PC13
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)","Initializes the CPU, AHB and APB buses clocks"
hi2c1.Instance = I2C1; hi2c1.Init.ClockSpeed = 100000; hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.Init.OwnAddress2 = 0; hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; HAL_I2C_Init(&hi2c1),Configure I2C1 peripheral
huart1.Instance = USART1; huart1.Init.BaudRate = 9600; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; HAL_HalfDuplex_Init(&huart1),Configure USART1 in half-duplex mode
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_13; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC13
HAL_ADCEx_Calibration_Start(&hadc1);,Calibrate ADC
InitDisplay();,Initialize display
HAL_ADC_Start_IT(&hadc1);,Start ADC in interrupt mode
"HAL_GPIO_TogglePin(SIG_GPIO_Port, SIG_Pin);",Toggle signal pin
"void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc) { if (hadc == &hadc1) { const uint16_t oldPeriod = signalPeriod; signalPeriod = Max((uint16_t)HAL_ADC_GetValue(&hadc1), 1); if (oldPeriod != signalPeriod) { UpdateDisplay(); } HAL_ADC_Start_IT(&hadc1); } }",Handle ADC conversion complete interrupt
"void InitDisplay(void) { HAL_Delay(16); const uint8_t setBusTo8Bit = 0x34, shiftOnWrite = 0x6, enableDisplay = 0xC; const uint8_t busCmdDelay = 1, shiftCmdDelay = 1, enableCmdDelay = 1; SendToDisplay(false, setBusTo8Bit, busCmdDelay); SendToDisplay(false, shiftOnWrite, shiftCmdDelay); SendToDisplay(false, enableDisplay, enableCmdDelay); ResetDisplay(); }","Initialize display with 8-bit bus, shift, and enable commands"
"void ResetDisplay(void) { const uint8_t resetDataCmd = 0x1, resetDataDelay = 2; SendToDisplay(false, resetDataCmd, resetDataDelay); }",Reset display
"void PrintNextSymbol(const char symbol) { SendToDisplay(true, symbol, 1); }",Print a symbol to the display
bool PrintNextNumber(const uint8_t nextNumber) { const bool isNumberValid = nextNumber < 10; if (isNumberValid) { const uint8_t asciiNumberOffset = 0x30; PrintNextSymbol(nextNumber + asciiNumberOffset); } return isNumberValid; },Print a single digit to the display
"void UpdateDisplay(void) { ResetDisplay(); const double frequency = (double)1000 / signalPeriod; const uint16_t integralFrequency = (uint16_t)frequency; const uint8_t integralFreqDigitsCount = GetDigitsCount(integralFrequency); for (uint8_t curDigit = integralFreqDigitsCount; curDigit > 0; --curDigit) { PrintNextNumber(integralFrequency % (uint16_t)pow(10, curDigit) / pow(10, (curDigit - 1))); } if (FRACTIONAL_FREQ_DISPLAY_LENGTH > 0) { PrintNextSymbol('.'); const double fractionalFrequency = frequency - integralFrequency; for (uint8_t curDigit = 1; curDigit <= FRACTIONAL_FREQ_DISPLAY_LENGTH; ++curDigit) { PrintNextNumber((uint8_t)(fractionalFrequency * pow(10, curDigit)) % 10); } } const char postfix[] = "" Hz""; for (uint8_t symbol = 0; symbol < sizeof(postfix) / sizeof(postfix[0]); ++symbol) { PrintNextSymbol(postfix[symbol]); } }",Update display with frequency value
uint8_t GetDigitsCount(uint16_t number) { uint8_t digitsCount = 0; do { number /= 10; ++digitsCount; } while (number != 0); return digitsCount; },Calculate number of digits in a number
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure ADC peripheral clock
hadc1.Instance = ADC1; hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE; hadc1.Init.ContinuousConvMode = DISABLE; hadc1.Init.DiscontinuousConvMode = DISABLE; hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START; hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT; hadc1.Init.NbrOfConversion = 1; HAL_ADC_Init(&hadc1),Configure ADC1 peripheral
"sConfig.Channel = ADC_CHANNEL_1; sConfig.Rank = ADC_REGULAR_RANK_1; sConfig.SamplingTime = ADC_SAMPLETIME_239CYCLES_5; HAL_ADC_ConfigChannel(&hadc1, &sConfig)",Configure ADC channel
BSP_LED_Init(LED1);,"Configure LED1, LED2 and LED3"
BSP_LED_On(LED1);,Turn LED1 on: Transfer in transmission process is correct
void Timeout_Error_Handler(void) { while (1) { BSP_LED_On(LED3); HAL_Delay(500); BSP_LED_Off(LED3); HAL_Delay(500); } },Toggle LED3 to indicate timeout error
"uint16_t Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength) { while (BufferLength--) { if ((*pBuffer1) != *pBuffer2) { return BufferLength; } pBuffer1++; pBuffer2++; } return 0; }",Compares two buffers
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; HAL_RCC_OscConfig(&RCC_OscInitStruct),"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.AHBCLK3Divider = RCC_SYSCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)","Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
hspi1.Instance = SPI1; hspi1.Init.Mode = SPI_MODE_SLAVE; hspi1.Init.Direction = SPI_DIRECTION_2LINES; hspi1.Init.DataSize = SPI_DATASIZE_8BIT; hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; hspi1.Init.NSS = SPI_NSS_SOFT; hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi1.Init.TIMode = SPI_TIMODE_DISABLE; hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi1.Init.CRCPolynomial = 7; hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE; hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE; HAL_SPI_Init(&hspi1),SPI1 parameter configuration
"bool_t uart_at_init(int baud) { memset(&g_atio_cb,0,sizeof(g_atio_cb)); if(false == osal_semp_create(&g_atio_cb.rcvsync,CN_RCVMEM_LEN,0)) { printf(""%s:semp create error\n\r"",__FUNCTION__); goto EXIT_SEMP; } ring_init(&g_atio_cb.rcvring,g_atio_cb.rcvringmem,CN_RCVMEM_LEN,0,0); uart_at.Instance = s_pUSART; uart_at.Init.BaudRate = baud; uart_at.Init.WordLength = UART_WORDLENGTH_8B; uart_at.Init.StopBits = UART_STOPBITS_1; uart_at.Init.Parity = UART_PARITY_NONE; uart_at.Init.HwFlowCtl = UART_HWCONTROL_NONE; uart_at.Init.Mode = UART_MODE_TX_RX; uart_at.Init.OverSampling = UART_OVERSAMPLING_16; if(HAL_UART_Init(&uart_at) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } __HAL_UART_CLEAR_FLAG(&uart_at,UART_FLAG_TC); LOS_HwiCreate(s_uwIRQn, 3, 0, atio_irq, 0); __HAL_UART_ENABLE_IT(&uart_at, UART_IT_IDLE); __HAL_UART_ENABLE_IT(&uart_at, UART_IT_RXNE); return true; EXIT_SEMP: return false; }",Initialize UART with interrupt handling
"void atio_irq(void) { unsigned char value; unsigned short ringspace; if(__HAL_UART_GET_FLAG(&uart_at, UART_FLAG_RXNE) != RESET) { value = (uint8_t)(uart_at.Instance->DR & 0x00FF); g_atio_cb.rcvlen++; if(g_atio_cb.w_next < CN_RCVBUF_LEN) { g_atio_cb.rcvbuf[g_atio_cb.w_next] = value; g_atio_cb.w_next++; } else { g_atio_cb.rframeover++; } } else if (__HAL_UART_GET_FLAG(&uart_at,UART_FLAG_IDLE) != RESET) { __HAL_UART_CLEAR_IDLEFLAG(&uart_at); ringspace = CN_RCVMEM_LEN - ring_datalen(&g_atio_cb.rcvring); if(ringspace < g_atio_cb.w_next) { g_atio_cb.rframedrop++; } else { ringspace = g_atio_cb.w_next; ring_write(&g_atio_cb.rcvring,(unsigned char *)&ringspace,sizeof(ringspace)); ring_write(&g_atio_cb.rcvring,g_atio_cb.rcvbuf,ringspace); osal_semp_post(g_atio_cb.rcvsync); g_atio_cb.rcvframe++; } g_atio_cb.w_next=0; } }",Handle UART receive and idle interrupts
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage
MX_FATFS_Init(),Initialize FatFS
BSP_LED_Init(LED_OK);,Configure LED_OK and LED_ERROR
BSP_LED_Init(LED_ERROR);,Configure LED_OK and LED_ERROR
BSP_SD_Init(0);,Initialize SD card
BSP_SD_DetectITConfig(0);,Configure SD card detection interrupt
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0);,Enable voltage range 0 for frequency above 80 Mhz
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6; RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 55; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Enable MSI Oscillator and activate PLL with MSI as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3)",Configure system clock with AHB prescaler divider 2 as first step
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5)",Set AHB prescaler divider to 1 as second step
HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY),Enable instruction cache in 1-way (direct mapped cache)
HAL_ICACHE_Enable(),Enable instruction cache
MX_USART1_UART_Init();,Initialize UART
"int fputc(int ch, FILE *f) { if (ch == '\n') { HAL_UART_Transmit(&huart1, (void *)""\r"", 1, 30000); } HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Redirect putchar to UART
"int fgetc(FILE *f) { uint8_t ch = 0; HAL_UART_Receive(&huart1, &ch, 1, 30000); return ch; }",Redirect getchar to UART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.LSEState = RCC_LSE_OFF; RCC_OscInitStruct.HSICalibrationValue = 70; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLM = RCC_PLLM_DIV2; RCC_OscInitStruct.PLL.PLLN = 30; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV5; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV5; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV5; HAL_RCC_OscConfig(&RCC_OscInitStruct),Configure RCC oscillators
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_HCLK3); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)",Configure system clock dividers
InitRTC();,Initialize Real Time Clock
UART_Console_Init();,Initialize console
BSP_LED_Init(LED2);,Initialize LED
InitTimers();,Initialize timers
BSP_ACCELERO_Init(),Initialize accelerometer
BSP_GYRO_Init(),Initialize gyroscope
BSP_MAGNETO_Init(),Initialize magnetometer
BSP_HSENSOR_Init(),Initialize humidity sensor
BSP_TSENSOR_Init(),Initialize temperature sensor
BSP_PSENSOR_Init(),Initialize pressure sensor
"void InitTimers(void) { uint32_t uwPrescalerValue; TIM_OC_InitTypeDef sConfig; uwPrescalerValue = (uint32_t)((SystemCoreClock / 2000) - 1); TimCCHandle.Instance = TIM1; TimCCHandle.Init.Period = 65535; TimCCHandle.Init.Prescaler = uwPrescalerValue; TimCCHandle.Init.ClockDivision = 0; TimCCHandle.Init.CounterMode = TIM_COUNTERMODE_UP; if (HAL_TIM_OC_Init(&TimCCHandle) != HAL_OK) { STM32_Error_Handler(); } sConfig.OCMode = TIM_OCMODE_TOGGLE; sConfig.OCPolarity = TIM_OCPOLARITY_LOW; sConfig.Pulse = DEFAULT_TIM_CC1_PULSE; if (HAL_TIM_OC_ConfigChannel(&TimCCHandle, &sConfig, TIM_CHANNEL_1) != HAL_OK) { STM32_Error_Handler(); } }",Initialize timers for sending the Telemetry data to IoT hub
void InitRTC(void) { RtcHandle.Instance = RTC; RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24; RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV; RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV; RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE; RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH; RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN; if (HAL_RTC_Init(&RtcHandle) != HAL_OK) { STM32_Error_Handler(); } },Initialize the Real Time Clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE | RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.LSEState = RCC_LSE_ON; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = 0; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_11; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 6; RCC_OscInitStruct.PLL.PLLN = 20; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Configure RCC oscillators
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4)","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_USART1 | RCC_PERIPHCLK_USART3 | RCC_PERIPHCLK_I2C2 | RCC_PERIPHCLK_RNG; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1; PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1; PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; PeriphClkInit.RngClockSelection = RCC_RNGCLKSOURCE_MSI; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure peripheral clocks
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1),Configure voltage scaling
HAL_RCCEx_EnableMSIPLLMode();,Enable MSI PLL mode
"UartHandle.Instance = USART1; UartHandle.Init.BaudRate = CFG_HW_UART1_BAUDRATE; UartHandle.Init.WordLength = CFG_HW_UART1_WORDLENGTH; UartHandle.Init.StopBits = CFG_HW_UART1_STOPBITS; UartHandle.Init.Parity = CFG_HW_UART1_PARITY; UartHandle.Init.Mode = CFG_HW_UART1_MODE; UartHandle.Init.HwFlowCtl = CFG_HW_UART1_HWFLOWCTL; UartHandle.AdvancedInit.AdvFeatureInit = CFG_HW_UART1_ADVFEATUREINIT; BSP_COM_Init(COM1, &UartHandle);",Configure UART interface
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { switch (GPIO_Pin) { case USER_BUTTON_PIN: ButtonPressed = 1; break; case GPIO_PIN_1: SPI_WIFI_ISR(); break; } },EXTI line detection callback
init_sysclk_216MHz();,Set system clock to 216 MHz
"init_gpio(led1, OUTPUT);",Initialize GPIO pin for LED1 as output
"init_gpio(led2, OUTPUT);",Initialize GPIO pin for LED2 as output
"init_gpio(led3, OUTPUT);",Initialize GPIO pin for LED3 as output
"init_gpio(pb1, INPUT);",Initialize GPIO pin for push button as input
"write_gpio(led1, HIGH);",Turn LED1 on
"write_gpio(led2, HIGH);",Turn LED2 on
"write_gpio(led3, HIGH);",Turn LED3 on
"write_gpio(led1, LOW);",Turn LED1 off
"write_gpio(led2, LOW);",Turn LED2 off
"write_gpio(led3, LOW);",Turn LED3 off
read_gpio(pb1),Read push button state
mpu6050Config();,Configure MPU6050 sensor
mpu6050GyroRead();,Read gyroscope data from MPU6050
mpu6050AccelRead();,Read accelerometer data from MPU6050
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 180; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2; RCC_OscInitStruct.PLL.PLLR = 2; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5)","Initializes the CPU, AHB and APB buses clocks"
hi2c1.Instance = I2C1; hi2c1.Init.ClockSpeed = 400000; hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.Init.OwnAddress2 = 0; hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; HAL_I2C_Init(&hi2c1),Configure I2C1 peripheral
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart2),Configure USART2 peripheral
BSP_LED_Init(LED1);,"Configure LED1, LED2, LED3 and LED4"
BSP_JOY_Init(JOY_MODE_EXTI);,Configure Joystick in EXTI mode
while(1) { HAL_Delay(500); BSP_LED_Toggle(LED1); BSP_LED_Toggle(LED2); BSP_LED_Toggle(LED3); BSP_LED_Toggle(LED4); },"Toggle LED1, LED2, LED3 and LED4 in an Infinite loop"
BSP_LED_Toggle(LED4);,Toggle LED4
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),EXTI line detection callback.
if(GPIO_Pin == RIGHT_JOY_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } },Handle joystick right button press to suspend or resume tick increment
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet."
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2; ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"GPIO_InitStructure.Pin = GPIO_PIN_5; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStructure.Speed = GPIO_SPEED_LOW; GPIO_InitStructure.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);",Configure PB5 as output for accelerometer power control
STATIC void accel_start(void),Initialize and start the accelerometer
i2c_start(&I2cHandle_X);,start the I2C bus
GPIOB->BSRRH = GPIO_PIN_5; HAL_Delay(20); GPIOB->BSRRL = GPIO_PIN_5; HAL_Delay(20);,"turn off AVDD, wait 20ms, turn on AVDD, wait 20ms again"
"for (int i = 0; i < 10; i++) { status = HAL_I2C_IsDeviceReady(&I2cHandle_X, MMA_ADDR, 10, 200); if (status == HAL_OK) { break; } }",Check if accelerometer device is ready
accel_start();,Initialize accelerometer
"memmove(self->buf, self->buf + NUM_AXIS, NUM_AXIS * (FILT_DEPTH - 1) * sizeof(int16_t));",Shift buffer to store new accelerometer data
"STATIC mp_obj_t pyb_accel_read(mp_obj_t self_in, mp_obj_t reg)",Read data from a specified accelerometer register
#define PUTCHAR_PROTOTYPE int __io_putchar(int ch),Define prototype for retargeting printf to UART
GPIO_Output_Config();,GPIO initialization
UART_Config();,UART initialization
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&uartHandle, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the UART.
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE; rccOscInit.HSEState = RCC_HSE_ON; rccOscInit.HSEPredivValue = RCC_HSE_PREDIV_DIV1; rccOscInit.PLL.PLLState = RCC_PLL_ON; rccOscInit.PLL.PLLSource = RCC_PLLSOURCE_HSE; rccOscInit.PLL.PLLMUL = RCC_PLL_MUL9;,Configure HSE and PLL
rccClkInit.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); rccClkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; rccClkInit.AHBCLKDivider = RCC_SYSCLK_DIV1; rccClkInit.APB2CLKDivider = RCC_HCLK_DIV1; rccClkInit.APB1CLKDivider = RCC_HCLK_DIV2;,"Configure SYSCLK, HCLK, PCLK1, and PCLK2"
void GPIO_Output_Config(void),"GPIO configuration: GPIO = GPIOB Pin = PB6, PB7, PB8, PB9 Mode = Output push-pull Speed = Low"
__HAL_RCC_GPIOB_CLK_ENABLE();,Configure RCC peripheral
void UART_Config(void),UART configuration: UART = UART2 Baud rate = 9600 Word length = 8 Stop bits = 1 Parity = None Mode = TX Hardware control = None
uartHandle.Instance = USART2; uartHandle.Init.BaudRate = 9600; uartHandle.Init.WordLength = UART_WORDLENGTH_8B; uartHandle.Init.StopBits = UART_STOPBITS_1; uartHandle.Init.Parity = UART_PARITY_NONE; uartHandle.Init.Mode = UART_MODE_TX; uartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE;,Configure UART
void HAL_UART_MspInit(UART_HandleTypeDef *huart),UART MSP configuration callback.
"gpioInit.Pin = GPIO_PIN_2; gpioInit.Mode = GPIO_MODE_AF_PP; gpioInit.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOA, &gpioInit);",Configure PA2 for UART TX
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_6, GPIO_PIN_SET);",Turn red LED on
void AOS_init(void),AOS Initialization
srand(atoi(_firmTime));,Initialize random seed for PRNG
void MX_TIM2_Init(void),TIM2 init function - periodic event timebase 32-bit
__TIM2_CLK_ENABLE();,Peripheral clock enable
htim2.Instance = TIM2; htim2.Init.Prescaler = 0; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 48; HAL_TIM_Base_Init(&htim2);,Configure TIM2
"sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim2, &sMasterConfig);",Configure TIM2 master synchronization
"HAL_NVIC_SetPriority(TIM2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(TIM2_IRQn);",Peripheral interrupt init
void MX_TIM7_Init(void),TIM7 init function - 1 usec timebase 16-bit
__TIM7_CLK_ENABLE();,Peripheral clock enable
htim7.Instance = TIM7; htim7.Init.Prescaler = 48; htim7.Init.CounterMode = TIM_COUNTERMODE_DOWN; htim7.Init.Period = 1; HAL_TIM_Base_Init(&htim7);,Peripheral configuration
"sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE; HAL_TIMEx_MasterConfigSynchronization(&htim7, &sMasterConfig);",Configure TIM7 master synchronization
portENTER_CRITICAL(); if (Delay) { htim7.Instance->ARR = Delay; HAL_TIM_Base_Start(&htim7); while(htim7.Instance->CNT != 0) { } HAL_TIM_Base_Stop(&htim7); } taskEXIT_CRITICAL();,Implement micro-second delay using TIM7
void startPerEvent(uint32_t rateFactor),Load and start periodic event counter
htim2.Init.Period = rateFactor; HAL_TIM_Base_Init(&htim2); HAL_TIM_Base_Start_IT(&htim2);,Configure and start TIM2 for periodic events
UART_HandleTypeDef* GetUart(uint8_t port),Get the UART for a given port
int GetPort(UART_HandleTypeDef *huart),Get the port for a given UART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI14; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSI14State = RCC_HSI14_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.HSI14CalibrationValue = 16; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initialize the RCC Oscillators
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);","Initialize the CPU, AHB and APB busses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInit.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);,Initialize the RCC extended peripherals clocks
__SYSCFG_CLK_ENABLE();,Enable SYSCFG clock
UartHandle.Instance = USARTx; UartHandle.Init.BaudRate = 9600; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_ODD; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX;,Configure the UART peripheral
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the USART.
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; oscinitstruct.HSEState = RCC_HSE_ON; oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; oscinitstruct.PLL.PLLState = RCC_PLL_ON; oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL9;,Enable HSE Oscillator and activate PLL with HSE as source
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1; clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1; clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV2;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void Error_Handler(void),This function is executed in case of error occurrence.
void GpioClock_Config(),GPIO Clock Enable
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);,Configure the Systick interrupt time
void UsbDevice_Config(),USB Device Configuration
"USBD_Init(&hUsbDeviceFS, &FS_Desc, DEVICE_FS); USBD_RegisterClass(&hUsbDeviceFS, &USBD_CDC); USBD_CDC_RegisterInterface(&hUsbDeviceFS, &USBD_Interface_fops_FS); USBD_Start(&hUsbDeviceFS);",Configure USB device
void Led_Config(),LED Configuration
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_14; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pin : PB14
void Button_Config(),BUTTON Configuration
"GPIO_InitStruct.Pin = GPIO_PIN_4; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pin : PA4
"void _Error_Handler(char* file, uint32_t line)",This function is executed in case of error occurrence.
void __inc_tick(),increment system timer tick every 1msec
tick_count++;,increment system timer tick
void km_delay(uint32_t msec),Implement delay in milliseconds
HAL_Delay(msec);,Call HAL delay function
return tick_count;,Return tick count
return (0xFFFFFFFFU / microseconds_cycle);,Calculate maximum microsecond counter value
return (DWT->CYCCNT / microseconds_cycle);,Return microsecond counter value
uint32_t time_diff; uint32_t start = DWT->CYCCNT; do { uint32_t now = DWT->CYCCNT; if (now >= start) time_diff = now - start; else time_diff = (0xFFFFFFFFU - start) + now; } while (time_diff / microseconds_cycle < usec);,Implement microsecond delay using DWT counter
void km_system_init(),Kaluma Hardware System Initializations
km_adc_cleanup(); km_pwm_cleanup(); km_i2c_cleanup(); km_spi_cleanup(); km_uart_cleanup(); km_gpio_cleanup();,"Cleanup ADC, PWM, I2C, SPI, UART, and GPIO"
"GPIO_PinState pin_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_4); if (pin_state == GPIO_PIN_RESET) return false; else return true;",Check status of the button to determine if user script should be skipped
void SystemApp_Init(void),"initialises the system (dbg pins, trace, mbmux, systimer, LPM, ...)"
__HAL_RCC_WAKEUPSTOP_CLK_CONFIG(RCC_STOP_WAKEUPCLOCK_MSI);,Ensure that MSI is wake-up system clock
UTIL_TIMER_Init();,Initialises timer and RTC
Gpio_PreInit();,Set all pins such to minimized consumption (necessary for some STM32 families)
DBG_Init();,Configure the debug mode
GNSE_TRACER_INIT();,Initialize Tracer/Logger
GNSE_TRACER_TIMESTAMP(TimestampNow);,Set timestamp function for tracer
"APP_PPRINTF(""\r\n Powering and using HW secure element (ATECC608A-TNGLORA) \r\n"");",Output message about secure element initialization
UTIL_LPM_Init();,Init low power manager
"UTIL_LPM_SetOffMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);",Disable Stand-by mode
"UTIL_LPM_SetStopMode((1 << CFG_LPM_APPLI_Id), UTIL_LPM_DISABLE);",Disable Stop Mode
UTIL_LPM_EnterLowPower();,Enter low power mode
"SysTime_t curtime = SysTimeGet(); tiny_snprintf_like((char *)buff, MAX_TS_SIZE, ""%ds%03d:"", curtime.Seconds, curtime.SubSeconds); *size = strlen((char *)buff);",Format current system time as seconds and milliseconds
__HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); __HAL_RCC_GPIOH_CLK_ENABLE();,Enable GPIOs clock
"GPIO_InitStruct.Mode = GPIO_MODE_ANALOG; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Pin = GPIO_PIN_All & (~(GPIO_PIN_13 | GPIO_PIN_14)); HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",All GPIOs except debug pins (SWCLK and SWD)
__HAL_RCC_GPIOA_CLK_DISABLE(); __HAL_RCC_GPIOB_CLK_DISABLE(); __HAL_RCC_GPIOC_CLK_DISABLE(); __HAL_RCC_GPIOH_CLK_DISABLE();,Disable GPIOs clock
static void DBG_Init(),Initialises the system for debugging or low power mode depending on DEBUGGER_ON
"GPIO_InitStruct.Mode = GPIO_MODE_ANALOG; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Pin = (GPIO_PIN_13 | GPIO_PIN_14); __HAL_RCC_GPIOA_CLK_ENABLE(); HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Put the debugger pin PA13 and P14 in analog for LowPower
HAL_DBGMCU_DisableDBGSleepMode(); HAL_DBGMCU_DisableDBGStopMode(); HAL_DBGMCU_DisableDBGStandbyMode();,Disable debug modes for low power
"UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_DISABLE);",Disable StopMode for UART transmission
"UTIL_LPM_SetStopMode((1 << CFG_LPM_UART_TX_Id), UTIL_LPM_ENABLE);",Re-enable StopMode after UART transmission
"va_list vaArgs; va_start(vaArgs, strFormat); ADV_TRACER_VSNPRINTF(buf, maxsize, strFormat, vaArgs); va_end(vaArgs);",Format string using variable arguments for tracer
return GNSE_RTC_GetTimerValue();,Return RTC-based tick value
os_delay_us(us);,Implement delay in microseconds
DHT11_IO_OUT; DHT11_OUT_LOW; tempHumDelay(18*1000); DHT11_OUT_HIGH;,"SET OUTPUT, Pull down Least 18ms, then pull high"
static uint8_t ICACHE_FLASH_ATTR dht11ReadBit(void),Read a single bit from DHT11
for (i=0; i<8; i++) { dat<<=1; dat |= dht11ReadBit(); },Read 8 bits to form a byte
"static uint8_t ICACHE_FLASH_ATTR dht11ReadData(u8 * temperature, u8 * humidity)",Read temperature and humidity data from DHT11
dht11Rst(); if(0 == dht11Check()) { for(i=0; i<5; i++) { buf[i] = hdt11ReadByte(); } if((buf[0]+buf[1]+buf[2]+buf[3])==buf[4]) { *humidity=buf[0]; *temperature=buf[2]; } },"Reset DHT11, check response, read 5 bytes, verify checksum, and assign temperature and humidity"
"uint8_t ICACHE_FLASH_ATTR dh11Read(uint8_t * temperature, uint8_t * humidity)",Read and average temperature and humidity from DHT11
dht11Rst();,Reset DHT11
"os_printf(""dh11Init \r\n"");",Print initialization message
"dht11ReadData(&curTem, &curHum); os_printf(""Temperature : %d , Humidity : %d"", curTem, curHum);",Read and print temperature and humidity
"USBD_UsrLog(""\033[2J"");",clear screen
MX_USB_DEVICE_Init();,Initialize USB device
MX_TIM2_Init();,Initialize TIM2
HAL_TIM_Base_Start_IT(&htim2);,Start TIM2 with interrupt
"while (1) { if (chk_wr_cache && sec_cache.is_cached && sec_cache.need_wr) { EraseSector ((sec_cache.blk_adr&SECTOR_MASK)*STORAGE_BLK_SIZ); ProgramData ((sec_cache.blk_adr&SECTOR_MASK)*STORAGE_BLK_SIZ, &sec_cache.buf[0], FLASH_SECTOR_SIZE); sec_cache.is_cached = false; chk_wr_cache = false; sec_cache.need_wr = false; __HAL_TIM_SET_COUNTER(&htim2, 1); } }",Main loop to check and flush cache to flash memory
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5;,Configure USB clock
"GPIO_InitStruct.Pin = USB_DP_PIN; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_MEDIUM; HAL_GPIO_Init(USB_DP_PORT, &GPIO_InitStruct);",Configure GPIO pin : USB_DP
sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;,Set internal clock source for TIM2
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;,Configure TIM2 master synchronization
sConfigOC.OCMode = TIM_OCMODE_TIMING; sConfigOC.Pulse = 0; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;,Configure TIM2 output compare channel
LED_Toggle(); HAL_Delay(80);,Toggle LED to indicate error
"while (1) { CDC_Transmit_FS(buff, strlen((char*)buff)); HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); HAL_Delay(500); }",Infinite loop
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;,Configure USB clock
static void MX_SPI1_Init(void),SPI1 Initialization Function
static void MX_GPIO_Init(void),GPIO Initialization Function
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim),Period elapsed callback in non blocking mode
if (htim->Instance == TIM1) { HAL_IncTick(); },"This function is called when TIM1 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
if (UserButtonPressed == 1U) { if (SystemCoreClock == 4000000U) { SECURE_SystemClock_MSI_PLL_110Mhz_Config(); SysTickUpdate(); ToggleDelay = FAST_DELAY; } else if (SystemCoreClock == 110000000U) { SECURE_SystemClock_MSI_4Mhz_Config(); SysTickUpdate(); ToggleDelay = SLOW_DELAY; } else { } UserButtonPressed = 0U; },Handle button press to toggle between fast and slow LED toggling based on system clock
"HAL_GPIO_TogglePin(LED1_GPIO_Port, LED1_Pin);",Toggle LED1
HAL_Delay(ToggleDelay);,Insert delay based on ToggleDelay value
"HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = BUTTON_USER_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(BUTTON_USER_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : BUTTON_USER_Pin
"GPIO_InitStruct.Pin = LED1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; HAL_GPIO_Init(LED1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LED1_Pin
"HAL_NVIC_SetPriority(EXTI13_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI13_IRQn);",EXTI interrupt init
if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK) { Error_Handler(); },Re-initialize 1ms tick timebase
void HAL_GPIO_EXTI_Rising_Callback(uint16_t GPIO_Pin),EXTI line rising detection callback.
if (GPIO_Pin == BUTTON_USER_Pin) { UserButtonPressed = 1; },Handle user button press to set flag
BSP_LED_Init(LED1); BSP_LED_Init(LED3);,Configure LED1 and LED3
"osMessageQDef(osqueue, QUEUE_SIZE, uint16_t); osQueue = osMessageCreate (osMessageQ(osqueue), NULL);",Create the queue used by the two tasks to pass the incrementing number.
static void MessageQueueProducer (const void *argument),Message Queue Producer Thread.
"if(osMessagePut (osQueue, ProducerValue, 100) != osOK) { BSP_LED_Toggle(LED3); } else { ++ProducerValue; BSP_LED_Toggle(LED1); osDelay(250); }","Producer posts incrementing number to queue, toggles LED3 on error, LED1 on success"
static void MessageQueueConsumer (const void *argument),Message Queue Consumer Thread.
"event = osMessageGet(osQueue, 100);",Get the message from the queue
if(event.status == osEventMessage) { if(event.value.v != ConsumerValue) { ConsumerValue = event.value.v; BSP_LED_Toggle(LED3); } else { ++ConsumerValue; } },"Consumer checks queue message, updates value, toggles LED3 on error"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive();,Activate the Over-Drive mode
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
BSP_LED_Init(LED6); BSP_LED_Init(LED5);,Configure LED6 and LED5
MPU_SRAM_Config();,Set SRAM MPU regions
BSP_LED_Toggle(LED6);,Toggle LED6
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9;,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 216 Mhz Frequency
static void CPU_CACHE_Enable(void),CPU L1-Cache enable.
void USB_HP_IRQHandler(void) { tud_int_handler(0); },Forward USB high-priority interrupt to TinyUSB IRQ Handler
void USB_LP_IRQHandler(void) { tud_int_handler(0); },Forward USB low-priority interrupt to TinyUSB IRQ Handler
void USBWakeUp_IRQHandler(void) { tud_int_handler(0); },Forward USB wakeup interrupt to TinyUSB IRQ Handler
board_stm32f1_clock_init();,Initialize STM32F1 clock
"NVIC_SetPriority(USB_HP_CAN1_TX_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY); NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY); NVIC_SetPriority(USBWakeUp_IRQn, configLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY);",Set USB interrupt priorities for FreeRTOS
"GPIO_InitStruct.Pin = LED_PIN; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = LED_STATE_ON ? GPIO_PULLDOWN : GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);",Configure LED pin
"GPIO_InitStruct.Pin = BUTTON_PIN; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = BUTTON_STATE_ACTIVE ? GPIO_PULLDOWN : GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(BUTTON_PORT, &GPIO_InitStruct);",Configure Button pin
"void board_led_write(bool state) { HAL_GPIO_WritePin(LED_PORT, LED_PIN, state ? LED_STATE_ON : (1-LED_STATE_ON)); }",Write state to LED
"uint32_t board_button_read(void) { return BUTTON_STATE_ACTIVE == HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN); }",Read button state
void SysTick_Handler (void) { system_ticks++; },Increment system ticks for millisecond counter
uint32_t board_millis(void) { return system_ticks; },Return system time in milliseconds
"void HardFault_Handler (void) { asm(""bkpt""); }",Handle hard fault with breakpoint
huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16;,Configure USART1 parameters
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle),Initialize UART MSP (MCU Support Package)
__HAL_RCC_USART1_CLK_ENABLE();,USART1 clock enable
"GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART1; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);","Configure USART1 GPIO pins (PA9: TX, PA10: RX)"
__HAL_RCC_USART1_CLK_DISABLE();,Peripheral clock disable
"HAL_GPIO_DeInit(GPIOA, GPIO_PIN_9|GPIO_PIN_10);",Deconfigure USART1 GPIO pins
HAL_NVIC_DisableIRQ(USART1_IRQn);,USART1 interrupt Deinit
SystemClock_Config(CPU_CLK_160M);,Configure system clock to 160 MHz
GPIO_Init();,Initialize GPIO pins
I2C_Init();,Initialize I2C interface
"HAL_I2C_Write(&hi2c, DEVICE_ADDR, 0x00 + i, (uint8_t *)(w_buf + i), 1);",Write single byte to I2C device (AT24CXX)
HAL_Delay(10);,Insert 10ms delay after each I2C write
"if (HAL_I2C_Read(&hi2c, DEVICE_ADDR, 0x00, r_buf, len) != HAL_OK) { printf(""read failed\r\n""); }",Read data from I2C device and report failure
"if (memcmp(w_buf, r_buf, len)) { printf(""err: %s\r\n"", r_buf); }",Compare read data with written data and report error
hi2c.Instance = I2C; hi2c.Frequency = 400000; HAL_I2C_Init(&hi2c);,Configure I2C with 400kHz frequency
__HAL_RCC_GPIO_CLK_ENABLE();,Enable GPIO clock
"GPIO_InitStruct.Pin = GPIO_PIN_1; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pin PA1 as output
"GPIO_InitStruct.Pin = GPIO_PIN_4; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pin PA4 as output
void Error_Handler(void),Handle error occurrence
"void assert_failed(uint8_t *file, uint32_t line) { printf(""Wrong parameters value: file %s on line %d\r\n"", file, line); }",Report assertion failure with file and line number
__HAL_RCC_TIM1_CLK_ENABLE();,Enable TIM1 clock
Res = AlcoholColumnCreate();,Initialize module for LED alcohol column
Res = DeviceDS18B20ConversionTemperature();,Start temperature conversion
DeviceDS18B20GetReadyTemperature(&ReadyTemp);,Check if temperature reading is ready
"Res = DeviceDS18B20GetTemperature(&Temp, &DS18B20ExCode);",Read temperature from sensor
AlcoholColumnSet(Temp);,Set LED column based on temperature
if(Temp > TEMPERATURE_MAX || Temp < TEMPERATURE_MIN) { Blink = 0; if(Temp > TEMPERATURE_MAX) OverflowTemp = TEMPERATURE_MAX; else OverflowTemp = TEMPERATURE_MIN; } else Blink = -1;,Check if temperature is out of range and set blink mode
TIMDelay(SYS_DELAY);,Insert system delay for periodic polling
void SystemClock_Config(void),Configure system clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,Configure HSI oscillator and PLL
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,Configure system clock source and dividers
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1; PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;,Configure I2C1 clock source
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure SysTick for 1ms interrupts
"HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);",Configure SysTick interrupt priority
"HAL_NVIC_EnableIRQ(TIM1_BRK_UP_TRG_COM_IRQn); HAL_NVIC_SetPriority(TIM1_BRK_UP_TRG_COM_IRQn, 1, 0);",Enable and configure TIM1 interrupt
init_led();,Initialize LEDs
init_spi();,Initialize SPI interface
init_lis();,Initialize LIS sensor
int8_t x = read_x();,Read X-axis value from sensor
"if (x > 0) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_SET); } else { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_14, GPIO_PIN_RESET); }",Set LEDs based on X-axis value
int8_t y = read_y();,Read Y-axis value from sensor
"if (y > 0) { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_RESET); } else { HAL_GPIO_WritePin(GPIOD, GPIO_PIN_13, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOD, GPIO_PIN_15, GPIO_PIN_SET); }",Set LEDs based on Y-axis value
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 50; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7;,Configure HSI oscillator and PLL
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV8; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;,Configure system clock source and dividers
"init_structure.Pin = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15; init_structure.Mode = GPIO_MODE_OUTPUT_PP; init_structure.Pull = GPIO_NOPULL; init_structure.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOD, &init_structure);","Configure LED pins (PD12, PD13, PD14, PD15)"
void init_spi(),Initialize SPI1 peripheral
__HAL_RCC_SPI1_CLK_ENABLE();,Enable SPI1 clock
hspi1.Instance = SPI1; hspi1.Init.Mode = SPI_MODE_MASTER; hspi1.Init.Direction = SPI_DIRECTION_2LINES; hspi1.Init.DataSize = SPI_DATASIZE_8BIT; hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; hspi1.Init.NSS = SPI_NSS_SOFT; hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi1.Init.CRCPolynomial = 1; HAL_SPI_Init(&hspi1);,Configure SPI1 parameters
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable GPIOA clock for SPI pins
"init_structure.Pin = GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7; init_structure.Pull = GPIO_NOPULL; init_structure.Speed = GPIO_SPEED_FREQ_LOW; init_structure.Mode = GPIO_MODE_AF_PP; init_structure.Alternate = GPIO_AF5_SPI1; HAL_GPIO_Init(GPIOA, &init_structure);","Configure SPI1 signal pins (PA5, PA6, PA7)"
void init_lis(),Initialize LIS sensor
__HAL_RCC_GPIOE_CLK_ENABLE();,Enable GPIOE clock for LIS slave select
"init_structure.Pin = GPIO_PIN_3; init_structure.Pull = GPIO_NOPULL; init_structure.Speed = GPIO_SPEED_FREQ_LOW; init_structure.Mode = GPIO_MODE_OUTPUT_PP; HAL_GPIO_Init(GPIOE, &init_structure);",Configure PE3 as slave select for LIS
"HAL_GPIO_WritePin(GPIOE, GPIO_PIN_3, GPIO_PIN_RESET);",Slave deselect
HAL_Delay(100);,Insert short delay after LIS initialization
int8_t read_x(),Read X-axis value from LIS sensor
int8_t read_y(),Read Y-axis value from LIS sensor
MX_GPIO_Init();,Initialize GPIO peripherals
MX_DMA_Init();,Initialize DMA peripherals
MX_USART1_UART_Init();,Initialize USART1 peripheral
"SET_BIT(huart1.Instance->CR3, USART_CR3_DMAR);",Enable the DMA transfer for the receiver request
"__HAL_UART_ENABLE_IT(&huart1, UART_IT_IDLE);",Enable idle interrupt
__HAL_DMA_DISABLE(&hdma_usart1_rx);,Disable DMA
while(hdma_usart1_rx.Instance->CR & DMA_SxCR_EN) { __HAL_DMA_DISABLE(&hdma_usart1_rx); },Ensure DMA is disabled
hdma_usart1_rx.Instance->PAR = (uint32_t)&(USART1->DR);,Set DMA peripheral address to USART1 data register
hdma_usart1_rx.Instance->M0AR = (uint32_t) dmaRxBuffer[0];,Set DMA memory address for first buffer
hdma_usart1_rx.Instance->M1AR = (uint32_t) dmaRxBuffer[1];,Set DMA memory address for second buffer
hdma_usart1_rx.Instance->NDTR = 36;,Set DMA number of data transfers
"SET_BIT(hdma_usart1_rx.Instance->CR, DMA_SxCR_DBM);",Enable double memory buffer
__HAL_DMA_ENABLE(&hdma_usart1_rx);,Enable DMA
"if (((dmaData[5] >> 6) & mask) == 0x3) { HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET); } else if (((dmaData[5] >> 6) & mask) == 0x2) { HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_SET); } else { HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED2_GPIO_Port, LED2_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED3_GPIO_Port, LED3_Pin, GPIO_PIN_RESET); }",Control LEDs 1-3 based on bits 6-7 of dmaData[5]
"if (((dmaData[5] >> 4) & mask) == 0x3) { HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_SET); } else if (((dmaData[5] >> 4) & mask) == 0x2) { HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_RESET); HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_SET); } else { HAL_GPIO_WritePin(LED4_GPIO_Port, LED4_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED5_GPIO_Port, LED5_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED6_GPIO_Port, LED6_Pin, GPIO_PIN_RESET); }",Control LEDs 4-6 based on bits 4-5 of dmaData[5]
HAL_Delay(10);,Insert 10ms delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 6; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4;,Configure HSE oscillator and PLL
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Configure system clock source and dividers
MX_I2C1_Init();,Initialize I2C1 peripheral
MX_TIM2_Init();,Initialize TIM2 peripheral
SCHEDULER_init(&sys);,Initialize scheduler
"EVENT_init(&sys, &htim2);",Initialize event system with TIM2
"LED_SEQUENCE_init(&sys.led, LED_1_GPIO_Port, LED_1_Pin, SEQUENCE_LED_1, 200, 12, 1);",Initialize LED sequence for LED1
"MPU_init(&sys.sensors.mpu, &hi2c1);",Initialize MPU sensor over I2C1
"GYRO_init(&sys.sensors.gyro, &sys.sensors.mpu);",Initialize gyro sensor
"if(sys.sensors.gyro.state != SENSOR_IDDLE) LED_SEQUENCE_set_sequence(&sys.led, SEQUENCE_LED_2);",Set alternate LED sequence if gyro is not idle
SCHEDULER_run();,Run scheduler
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4;,Configure HSI oscillator and PLL
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1)","Initializes the CPU, AHB and APB buses clocks"
"HAL_GPIO_WritePin(GPIOC, LD4_Pin|LD3_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = LD4_Pin|LD3_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pins : LD4_Pin LD3_Pin
SY_I2CConnTest(10),Check I2C device connection
SY_doDevDriverTasks(),Execute device driver tasks
MW_IWDGClr(),Reset counter of watch dog
SY_clockInit(),Configure the system clock
SY_GPIOInit(),Initialize GPIO
MW_USARTInit(USART2ID),UART initialize
"DD_RCInit((uint8_t*)g_rc_data, 100000)",Initialize RC
MW_SetIWDGPrescaler(IWDG_PRESCALER_16); MW_SetIWDGReload(250); MW_IWDGInit(),Initialize IWDG
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI | RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.LSIState = RCC_LSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; HAL_RCC_OscConfig(&RCC_OscInitStruct),Configure RCC oscillators
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)",Configure system clock
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure ADC peripheral clock
MW_SetGPIOPin(GPIO_PIN_13); MW_SetGPIOMode(GPIO_MODE_INPUT); MW_SetGPIOPull(GPIO_NOPULL); MW_GPIOInit(GPIOCID);,Configure GPIO pin : PC13
MW_SetGPIOPin(GPIO_PIN_5); MW_SetGPIOMode(GPIO_MODE_OUTPUT_PP); MW_SetGPIOSpeed(GPIO_SPEED_FREQ_LOW); MW_GPIOInit(GPIOAID);,Configure GPIO pin : PA5
MW_SetGPIOPin(GPIO_PIN_4); MW_SetGPIOMode(GPIO_MODE_IT_RISING); MW_SetGPIOPull(GPIO_NOPULL); MW_GPIOInit(GPIOCID);,Configure GPIO pin : PC4
"MW_GPIOWrite(GPIOAID, GPIO_PIN_5, 0);",Configure GPIO pin Output Level
"HAL_UART_RxCpltCallback(UART_HandleTypeDef *UartHandle) { if(DD_RCTask(rc_rcv, (uint8_t*)g_rc_data)!=0) message(""err"",""rc err""); count_for_rc = 0; }",Handle UART receive complete callback
HAL_UART_TxCpltCallback(UART_HandleTypeDef *UartHandle) { MW_messageTransitionCompletedCallBack(); },Handle UART transmit complete callback
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_I2C1; PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure I2C1 peripheral clock
hi2c1.Instance = I2C1; hi2c1.Init.Timing = 0x2000090E; hi2c1.Init.OwnAddress1 = 0; hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; hi2c1.Init.OwnAddress2 = 0; hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK; hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; HAL_I2C_Init(&hi2c1),Configure I2C1 peripheral
"HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE)",Configure Analogue filter
hspi1.Instance = SPI1; hspi1.Init.Mode = SPI_MODE_MASTER; hspi1.Init.Direction = SPI_DIRECTION_2LINES; hspi1.Init.DataSize = SPI_DATASIZE_4BIT; hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; hspi1.Init.NSS = SPI_NSS_SOFT; hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2; hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi1.Init.TIMode = SPI_TIMODE_DISABLE; hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi1.Init.CRCPolynomial = 7; hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE; hspi1.Init.NSSPMode = SPI_NSS_PULSE_ENABLE; HAL_SPI_Init(&hspi1),SPI1 parameter configuration
"GPIO_InitStruct.Pin = REL1_Pin|REL3_Pin|ROT_A_Pin|ROT_B_Pin|ROT_S_Pin|FSELECT_Pin|SDATA_Pin|FSYNC_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : REL1_Pin REL3_Pin ROT_A_Pin ROT_B_Pin ROT_S_Pin FSELECT_Pin SDATA_Pin FSYNC_Pin
"GPIO_InitStruct.Pin = SCLK_Pin|DATAEN_Pin|TXEN_Pin|DIGITAL_OUT_1_Pin|PSEL1_Pin|PSEL0_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : SCLK_Pin DATAEN_Pin TXEN_Pin DIGITAL_OUT_1_Pin PSEL1_Pin PSEL0_Pin
__HAL_RCC_PWR_CLK_ENABLE(),Enable Power Control clock
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1),The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency (see datasheet).
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct),Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5)","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"dhcp_client_notify(uint32_t if_num, dhcpClientOption opt, const uint8_t *val, uint32_t len) { if (opt == dhcpClientIPaddress) { sprintf(lcd_text[0],""IP address:""); sprintf(lcd_text[1],""%s"", ip4_ntoa(val)); LCDupdate = true; } }",IP address change notification
TIM2_IRQHandler() { if((TIM2->SR & TIM_FLAG_UPDATE) != 0 && (TIM2->DIER & TIM_FLAG_UPDATE)!=0) { TIM2->SR &= ~TIM_FLAG_UPDATE; ++sec; } if((TIM2->SR & TIM_FLAG_CC1) != 0 && (TIM2->DIER & TIM_IT_CC1)!=0) { TIM2->SR &= ~TIM_FLAG_CC1; TIM2->CCR1 += HZ_TICK; ++ticks; } },Handle TIM2 interrupt
"CaculatePrescale(uint32_t freq) { RCC_ClkInitTypeDef clkconfig; uint32_t pFLatency; HAL_RCC_GetClockConfig(&clkconfig, &pFLatency); uint32_t uwTimclock = HAL_RCC_GetPCLK1Freq(); if(clkconfig.APB1CLKDivider != RCC_HCLK_DIV1) uwTimclock *= 2; return (uint32_t) ((uwTimclock / freq) - 1U); }",Compute the prescaler value to have TIM2 counter clock equal to 1MHz
"timer_init(int freq) { tim2_prescaler = CaculatePrescale(1000000U); HAL_NVIC_SetPriority(TIM2_IRQn, 0U, 0U); HAL_NVIC_EnableIRQ(TIM2_IRQn); __HAL_RCC_TIM2_CLK_ENABLE(); TIM2->PSC = tim2_prescaler; TIM2->ARR = UINT32_MAX; TIM2->CCR1 = HZ_TICK; TIM2->CCMR1 |= TIM_CCMR1_OC1PE; TIM3->CCER |= TIM_CCER_CC1E; TIM2->DIER |= TIM_IT_UPDATE | TIM_IT_CC1; TIM2->CR1 |= TIM_CR1_CEN; }",Initialize timer (ticker)
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_TIM1; PeriphClkInit.Tim1ClockSelection = RCC_TIM1CLK_HCLK; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure TIM1 peripheral clock
htim1.Instance = TIM1; htim1.Init.Prescaler = 72-1; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 1000; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; HAL_TIM_PWM_Init(&htim1),Configure TIM1 peripheral for PWM
"sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = 0; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCNPolarity = TIM_OCNPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; sConfigOC.OCIdleState = TIM_OCIDLESTATE_RESET; sConfigOC.OCNIdleState = TIM_OCNIDLESTATE_RESET; HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_1); HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_2); HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_3); HAL_TIM_PWM_ConfigChannel(&htim1, &sConfigOC, TIM_CHANNEL_4)",Configure PWM channels for TIM1
huart2.Instance = USART2; huart2.Init.BaudRate = 38400; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; HAL_UART_Init(&huart2),Configure USART2 peripheral
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable GPIOA Clock (to be able to program the configuration registers)
"GPIO_InitStruct.Pin = GPIO_PIN_5; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FAST; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure PA05 IO in output push-pull mode to drive external LED
"HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);",Toggle PA05 IO
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet."
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 400; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct),Enable HSI Oscillator and activate PLL with HSI as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3)","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
Luos_Init();,Initialize Luos framework
Led_Init();,Initialize LED
Luos_Loop();,Run Luos framework loop
Led_Loop();,Run LED loop
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1; HAL_RCC_OscConfig(&RCC_OscInitStruct),Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Configure USART1 peripheral clock
dacInit(),Initialize DAC
dacSetup(uint32_t hz),Setup DAC with specified frequency
dacStart(),Start DAC
dacStop(),Stop DAC
dacInitTimer(uint32_t hz),Initialize timer for DAC
dacPutch(uint8_t data),Write 8-bit data to DAC buffer
dacPut16(uint16_t data),Write 16-bit data to DAC buffer
"dacWrite(uint8_t *p_data, uint32_t length)",Write multiple 8-bit data to DAC buffer
"dacWrite16(uint16_t *p_data, uint32_t length)",Write multiple 16-bit data to DAC buffer
HAL_DAC_Init(&DacHandle),Initialize DAC peripheral
"HAL_DAC_ConfigChannel(&DacHandle, &dac_tbl[0].sConfig, dac_tbl[0].channel)",Configure DAC channel
"HAL_DAC_Start_DMA(&DacHandle, dac_tbl[0].channel, (uint32_t *)dac_tbl[0].buffer, DAC_BUFFER_MAX, DAC_ALIGN_12B_R)",Start DAC with DMA
htim.Init.Period = 10-1; htim.Init.Prescaler = (uint32_t)((SystemCoreClock / 2) / (hz*10)) - 1; htim.Init.ClockDivision = 0; htim.Init.CounterMode = TIM_COUNTERMODE_UP; htim.Init.RepetitionCounter = 0; HAL_TIM_Base_Init(&htim),Configure timer for DAC
HAL_DAC_ConvHalfCpltCallbackCh1(DAC_HandleTypeDef* hdac) { dac_isr_count++; },Handle DAC half conversion complete callback
"HAL_DAC_MspInit(DAC_HandleTypeDef *hdac) { GPIO_InitTypeDef GPIO_InitStruct; __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_DAC12_CLK_ENABLE(); __HAL_RCC_DMA2_CLK_ENABLE(); GPIO_InitStruct.Pin = GPIO_PIN_4; GPIO_InitStruct.Mode = GPIO_MODE_ANALOG; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); hdma_dac1.Instance = DMA2_Stream6; hdma_dac1.Init.Request = DMA_REQUEST_DAC1; hdma_dac1.Init.Direction = DMA_MEMORY_TO_PERIPH; hdma_dac1.Init.PeriphInc = DMA_PINC_DISABLE; hdma_dac1.Init.MemInc = DMA_MINC_ENABLE; hdma_dac1.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD; hdma_dac1.Init.MemDataAlignment = DMA_PDATAALIGN_HALFWORD; hdma_dac1.Init.Mode = DMA_CIRCULAR; hdma_dac1.Init.Priority = DMA_PRIORITY_LOW; hdma_dac1.Init.FIFOMode = DMA_FIFOMODE_DISABLE; HAL_DMA_DeInit(&hdma_dac1); HAL_DMA_Init(&hdma_dac1); __HAL_LINKDMA(hdac, DMA_Handle1, hdma_dac1); }","Configure DAC MSP (clocks, GPIO, DMA)"
MX_USART1_UART_Init(),USART1 init function
MX_USART2_UART_Init(),USART2 init function
huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&huart1),Configure USART1 peripheral
HAL_UART_MspInit(UART_HandleTypeDef* uartHandle),"Configure UART MSP (clocks, GPIO, interrupts)"
HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle),Deinitialize UART MSP
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the USART.
BSP_LED_Init(LED_RED);,Configure LED_RED
BSP_LED_Toggle(LED_RED);,Toggle LED_RED
BSP_LED_Init(LED_GREEN);,Configure LED_GREEN
BSP_LED_Toggle(LED_GREEN);,Toggle LED_GREEN
HAL_NVIC_SystemReset();,Perform system reboot
static void CPU_CACHE_Enable(void) { SCB_EnableICache(); SCB_EnableDCache(); },CPU L1-Cache enable
BSP_LED_Init(LED5);,Configure LED5
if (HAL_DAC_DeInit(&DacHandle) != HAL_OK) { Error_Handler(); },DeInit the DAC peripheral
if (HAL_DAC_Init(&DacHandle) != HAL_OK) { Error_Handler(); },Configure the DAC peripheral
"if (HAL_DAC_ConfigChannel(&DacHandle, &sConfig, DACx_CHANNEL) != HAL_OK) { Error_Handler(); }",Configure DAC channel1
"if (HAL_DAC_SetValue(&DacHandle, DACx_CHANNEL, DAC_ALIGN_8B_R, 0xFF) != HAL_OK) { Error_Handler(); }",Set DAC Channel1 DHR register
"if (HAL_DAC_Start(&DacHandle, DACx_CHANNEL) != HAL_OK) { Error_Handler(); }",Enable DAC Channel1
static void Error_Handler(void) { BSP_LED_On(LED5); while(1) { } },This function is executed in case of error occurrence
static void MPU_Config(void) { MPU_Region_InitTypeDef MPU_InitStruct; HAL_MPU_Disable(); MPU_InitStruct.Enable = MPU_REGION_ENABLE; MPU_InitStruct.BaseAddress = 0x00; MPU_InitStruct.Size = MPU_REGION_SIZE_4GB; MPU_InitStruct.AccessPermission = MPU_REGION_NO_ACCESS; MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE; MPU_InitStruct.IsCacheable = MPU_ACCESS_NOT_CACHEABLE; MPU_InitStruct.IsShareable = MPU_ACCESS_SHAREABLE; MPU_InitStruct.Number = MPU_REGION_NUMBER0; MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0; MPU_InitStruct.SubRegionDisable = 0x87; MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_DISABLE; HAL_MPU_ConfigRegion(&MPU_InitStruct); HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT); },Configure the MPU attributes
"HAL_UART_Transmit(&huart1,(uint8_t *)&ch,100,0xFFFF);",Transmit data over UART
"static void MX_USART1_UART_Init(void) { huart1.Instance = USART1; huart1.Init.BaudRate = 9600; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart1) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } }",USART1 init function
MPU_RegionConfig();,Set MPU regions
BSP_LED_Init(LED3);,Configure LED3
HAL_MspInit();,Initialize MSP (MCU Support Package)
MX_CRC_Init();,Initialize CRC module
void HAL_CRC_MspInit(CRC_HandleTypeDef* hcrc1) { if(hcrc1->Instance !=CRC) return; __HAL_RCC_CRC_CLK_ENABLE(); },Enable CRC clock
void HAL_CRC_MspDeInit(CRC_HandleTypeDef* hcrc1) { if(hcrc1->Instance != CRC) return; __HAL_RCC_CRC_CLK_DISABLE(); },Disable CRC clock
void SysTick_Handler(void) { HAL_IncTick(); HAL_SYSTICK_IRQHandler(); },Handle SysTick interrupt
BSP_LED_Init(LED2);,Initialize LED2
HAL_FLASH_Unlock();,Unlock the Flash to enable the flash control register access
"if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK) { while (1) { BSP_LED_On(LED2); HAL_Delay(100); BSP_LED_Off(LED2); HAL_Delay(2000); } }",Erase the user Flash area (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR)
HAL_FLASH_Lock();,Lock the Flash to disable the flash control register access (recommended to protect the FLASH memory against possible unwanted operation)
if (MemoryProgramStatus == 0) { BSP_LED_On(LED2); },No error detected. Switch on LED2
"HAL_ADC_Start_DMA(&hadc_bsp3,ConvertedValue,1);",Start ADC3 with DMA
ConvertedValue = HAL_ADC_GetValue(&hadc_bsp3);,Get ADC converted value
SystemClockConfig();,Configure system clock
"GpioInit( &Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );",Initialize LED1 GPIO
"GpioInit( &Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );",Initialize LED2 GPIO
"GpioInit( &Led3, LED_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1 );",Initialize LED3 GPIO
"SX9500Write( SX9500_REG_IRQMSK, 0x10 );",Configure SAR interrupt mask
"SX9500Read( SX9500_REG_OFFSETMSB, ( uint8_t* )&regValue );",Read 1st sensor offset (MSB)
"SX9500Read( SX9500_REG_OFFSETLSB, ( uint8_t* )&regValue );",Read 1st sensor offset (LSB)
if( ( ( *( volatile uint32_t* )USBD_DFU_APP_DEFAULT_ADD ) & 0x2FFE0000 ) == 0x20000000 ) { JumpAddress = *( volatile uint32_t* ) ( USBD_DFU_APP_DEFAULT_ADD + 4 ); JumpToApplication = ( pFunction ) JumpAddress; __set_MSP( *( volatile uint32_t* ) USBD_DFU_APP_DEFAULT_ADD ); JumpToApplication(); },Jump to user application
"USBD_DFU_RegisterMedia( &USBD_Device, &USBD_DFU_Flash_fops );",Add DFU Media interface
"GpioWrite( &Led1, 0 );",Turn off LED1
"GpioWrite( &Led2, 0 );",Turn off LED2
"GpioWrite( &Led3, 0 );",Turn off LED3
"GpioWrite( &Led1, 1 );",Turn on LED1
"GpioWrite( &Led2, 1 );",Turn on LED2
"GpioWrite( &Led3, 1 );",Turn on LED3
BSP_LED_Init(LED6);,Configure LED6
"BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_EXTI);",Configure Tamper push-button
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == WAKEUP_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback
static void Error_Handler(void) { BSP_LED_On(LED3); while (1) { } },This function is executed in case of error occurrence
CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk; DWT->LAR = 0xC5ACCE55; DWT->CYCCNT = 0; DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;,start DWT counter also when not in Debug mode to count clock ticks
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1); HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2); HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_3); HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_4);",Start PWM on timer 2
IMU_init_ok = IMU_Init();,Initialize IMU
HAL_TIM_Base_Start_IT(&htim4);,start IMU trigger
IMU_calcAngle();,Calculate IMU angle
looptime = (stop - start)/216000000.0;,Calculate loop time based on DWT counter
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RTC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C3|RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48; PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1; PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL; PeriphClkInitStruct.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_CLK48; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);,Configure peripheral clocks
"BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_GPIO);",Configure Key Button
if(((*(__IO uint32_t*)USBD_DFU_APP_DEFAULT_ADD) & 0x2FF80000 ) == 0x20000000) { JumpAddress = *(__IO uint32_t*) (USBD_DFU_APP_DEFAULT_ADD + 4); JumpToApplication = (pFunction) JumpAddress; __set_MSP(*(__IO uint32_t*) USBD_DFU_APP_DEFAULT_ADD); JumpToApplication(); },Test if user code is programmed starting from USBD_DFU_APP_DEFAULT_ADD address and jump to user application
HAL_Delay(__IO uint32_t Delay) { while(Delay) { if (SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) { Delay--; } } },This function provides accurate delay (in milliseconds) based on SysTick counter flag
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
PeriphClkInitStruct.PLLI2S.PLLI2SM = 8; PeriphClkInitStruct.PLLI2S.PLLI2SQ = 4; PeriphClkInitStruct.PLLI2S.PLLI2SN = 192; PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48; PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLI2SQ; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);,Select PLLSAI output as USB clock source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; HAL_UART_Init(&huart2);,USART2 Initialization Function
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 8; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);,Configure peripheral clock for USART2
"void MainThread(void *argument) { UNUSED(argument); for (;;) { KERNEL_DBG(""MainThread is Running...""); osDelay(250); } }",Function implementing the Start thread
HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM3) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode - called when TIM3 interrupt took place to increment a global variable ""uwTick"" used as application time base"
"void LED_Thread1(void const *argument) { (void) argument; osEvent event; for(;;) { event = osSignalWait(BIT_0, osWaitForever); if(event.value.signals == BIT_0) { BSP_LED_Toggle(LED1); } } }",Thread (LED_Thread1) used to toggle a LED when getting the appropriate signal
"void LED_Thread2(void const *argument) { (void) argument; osEvent event; for(;;) { event = osSignalWait(BIT_1 | BIT_2, osWaitForever); if(event.value.signals == (BIT_1 | BIT_2)) { BSP_LED_Toggle(LED2); } } }",Thread (LED_Thread2) used to toggle a LED when getting the appropriate signal
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 20; RCC_OscInitStruct.PLL.PLLR = 2; RCC_OscInitStruct.PLL.PLLP = 7; RCC_OscInitStruct.PLL.PLLQ = 4; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 15; RCC_OscInitStruct.PLL.PLLR = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSI Oscillator and activate PLL with HSI as source
"nrf24l01_write_tx_payload(&data, 1U, true);",transmit a byte over rf
nrf24l01_irq_clear_all();,clear rf module interrupts
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);","Initializes the CPU, AHB and APB buses clocks"
hspi2.Instance = SPI2; hspi2.Init.Mode = SPI_MODE_MASTER; hspi2.Init.Direction = SPI_DIRECTION_2LINES; hspi2.Init.DataSize = SPI_DATASIZE_8BIT; hspi2.Init.CLKPolarity = SPI_POLARITY_LOW; hspi2.Init.CLKPhase = SPI_PHASE_1EDGE; hspi2.Init.NSS = SPI_NSS_SOFT; hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi2.Init.TIMode = SPI_TIMODE_DISABLE; hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi2.Init.CRCPolynomial = 10; HAL_SPI_Init(&hspi2);,SPI2 parameter configuration
"GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : PB12 PB9
SystemClock_Config_HSE(SYS_CLOCK_FREQ_50_MHZ);,Config. the clock
TIMER2_Init();,Init Timer 2
"void HAL_TIM_OC_DelayElapsedCallback(TIM_HandleTypeDef *htim) { uint32_t ccr_content; if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) { ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1, ccr_content + timer_pulse_500hz); } if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2) { ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, ccr_content + timer_pulse_1000hz); } if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3) { ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_3, ccr_content + timer_pulse_2000hz); } if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_4) { ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_4, ccr_content + timer_pulse_4000hz); } }","TIM2_CH1 Toggling with frequency = 500 Hz, 1000 Hz, 2000 Hz, 4000 Hz for respective channels"
"void TIMER2_Init(void) { timer2_handle.Instance = TIM2; timer2_handle.Init.CounterMode = TIM_COUNTERMODE_UP; timer2_handle.Init.Period = 0xFFFFFFFF; timer2_handle.Init.Prescaler = 1; HAL_TIM_OC_Init(&timer2_handle); TIM_OC_InitTypeDef timer2OC_Config; timer2OC_Config.OCMode = TIM_OCMODE_TOGGLE; timer2OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH; timer2OC_Config.Pulse = timer_pulse_500hz; HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_1); timer2OC_Config.Pulse = timer_pulse_1000hz; HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_2); timer2OC_Config.Pulse = timer_pulse_2000hz; HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_3); timer2OC_Config.Pulse = timer_pulse_4000hz; HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_4); }",Initialize the TIMER Output Compare Time base and configure Output Channels of the Timer
"void SystemClock_Config_HSE(uint8_t clock_freq) { RCC_OscInitTypeDef osc_init; RCC_ClkInitTypeDef clk_init; uint32_t FLatency; osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE; osc_init.HSEState = RCC_HSE_ON; osc_init.PLL.PLLState = RCC_PLL_ON; osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE; osc_init.PLL.PLLQ = 2; clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1; clk_init.APB1CLKDivider = RCC_HCLK_DIV2; clk_init.APB2CLKDivider = RCC_HCLK_DIV2; switch(clock_freq) { case SYS_CLOCK_FREQ_50_MHZ: osc_init.PLL.PLLM = 8; osc_init.PLL.PLLN = 100; osc_init.PLL.PLLP = RCC_PLLP_DIV2; FLatency = FLASH_LATENCY_1; break; case SYS_CLOCK_FREQ_84_MHZ: osc_init.PLL.PLLM = 8; osc_init.PLL.PLLN = 168; osc_init.PLL.PLLP = RCC_PLLP_DIV2; FLatency = FLASH_LATENCY_2; break; case SYS_CLOCK_FREQ_120_MHZ: osc_init.PLL.PLLM = 8; osc_init.PLL.PLLN = 240; osc_init.PLL.PLLP = RCC_PLLP_DIV2; clk_init.APB1CLKDivider = RCC_HCLK_DIV4; FLatency = FLASH_LATENCY_3; break; default: return; } HAL_RCC_OscConfig(&osc_init); HAL_RCC_ClockConfig(&clk_init, FLatency); HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000); HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); }","Initialize the oscillator and clock for specified frequency (50 MHz, 84 MHz, or 120 MHz)"
HW_Init();,Configure the hardware
ketCube_terminal_Init();,Init Terminal
ketCube_modules_Init();,Init KETCube modules
"TimerInit(&KETCube_PeriodTimer, KETCube_PeriodElapsed);",Initialize periodic timer
"TimerSetValue(&KETCube_PeriodTimer, ketCube_coreCfg.startDelay); TimerStart(&KETCube_PeriodTimer);",Configure the periodic timer
ketCube_terminal_ProcessCMD();,process pending commands
ketCube_remoteTerminal_ProcessCMD();,process pending remote terminal commands
ketCube_modules_ExecutePeriodic();,execute periodic function for enabled modules
ketCube_modules_ProcessMsgs();,process inter/module messages
ketCube_modules_SleepEnter();,execute module preSleep module functions
LowPower_Handler();,Handle low power mode
void KETCube_getResetFlags(void) { if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) == TRUE) { KETCube_wasResetPOR = TRUE; } else { KETCube_wasResetPOR = FALSE; } __HAL_RCC_CLEAR_RESET_FLAGS(); },Check if reset was caused by power-on reset and clear reset flags
"void KETCube_PeriodElapsed(void* context) { TimerStop(&KETCube_PeriodTimer); KETCube_PeriodTimerElapsed = TRUE; TimerSetValue(&KETCube_PeriodTimer, ketCube_coreCfg.basePeriod); TimerStart(&KETCube_PeriodTimer); }",Function executed on TxNextPacket Timeout event
SystemClock_Config_HSE(SYS_CLOCK_FREQ_180MHZ);,Configure system clock to 180 MHz
UART2_Init();,Initialize UART2
"sprintf(msg, ""SYSCLK: %ld\r\n"", HAL_RCC_GetSysClockFreq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Print system clock frequency via UART
"sprintf(msg, ""HCLCK: %ld\r\n"", HAL_RCC_GetHCLKFreq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Print HCLK frequency via UART
"sprintf(msg, ""PCLK1: %ld\r\n"", HAL_RCC_GetPCLK1Freq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Print PCLK1 frequency via UART
"sprintf(msg, ""PCLK2: %ld\r\n"", HAL_RCC_GetPCLK2Freq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Print PCLK2 frequency via UART
"void SystemClock_Config_HSE(uint32_t clock_freq) { RCC_OscInitTypeDef osc_init; RCC_ClkInitTypeDef clk_init; uint32_t fLatency; osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSE; osc_init.HSEState = RCC_HSE_ON; osc_init.PLL.PLLSource = RCC_PLLSOURCE_HSE; clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; clk_init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; switch (clock_freq) { case SYS_CLOCK_FREQ_50_MHZ: osc_init.PLL.PLLM = 8; osc_init.PLL.PLLN = 100; osc_init.PLL.PLLP = RCC_PLLP_DIV2; osc_init.PLL.PLLState = RCC_PLL_ON; clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1; clk_init.APB1CLKDivider = RCC_HCLK_DIV1; clk_init.APB2CLKDivider = RCC_HCLK_DIV2; fLatency = FLASH_LATENCY_1; break; case SYS_CLOCK_FREQ_84_MHZ: osc_init.PLL.PLLM = 4; osc_init.PLL.PLLN = 84; osc_init.PLL.PLLP = RCC_PLLP_DIV2; osc_init.PLL.PLLState = RCC_PLL_ON; clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1; clk_init.APB1CLKDivider = RCC_HCLK_DIV2; clk_init.APB2CLKDivider = RCC_HCLK_DIV1; fLatency = FLASH_LATENCY_2; break; case SYS_CLOCK_FREQ_120MHZ: osc_init.PLL.PLLM = 4; osc_init.PLL.PLLN = 120; osc_init.PLL.PLLP = RCC_PLLP_DIV2; osc_init.PLL.PLLState = RCC_PLL_ON; clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1; clk_init.APB1CLKDivider = RCC_HCLK_DIV4; clk_init.APB2CLKDivider = RCC_HCLK_DIV2; fLatency = FLASH_LATENCY_3; break; case SYS_CLOCK_FREQ_180MHZ: osc_init.PLL.PLLM = 4; osc_init.PLL.PLLN = 180; osc_init.PLL.PLLP = RCC_PLLP_DIV2; osc_init.PLL.PLLState = RCC_PLL_ON; clk_init.AHBCLKDivider = RCC_SYSCLK_DIV1; clk_init.APB1CLKDivider = RCC_HCLK_DIV4; clk_init.APB2CLKDivider = RCC_HCLK_DIV2; fLatency = FLASH_LATENCY_5; break; } HAL_RCC_OscConfig(&osc_init); HAL_RCC_ClockConfig(&clk_init, fLatency); HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000); HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK); }","Configure system clock for specified frequency (50 MHz, 84 MHz, 120 MHz, or 180 MHz)"
void UART2_Init(void) { uart_2.Instance = USART2; uart_2.Init.BaudRate = 9600; uart_2.Init.WordLength = UART_WORDLENGTH_8B; uart_2.Init.HwFlowCtl = UART_HWCONTROL_NONE; uart_2.Init.StopBits = UART_STOPBITS_1; uart_2.Init.Parity = UART_PARITY_NONE; uart_2.Init.Mode = UART_MODE_TX_RX; HAL_UART_Init(&uart_2); },Initialize UART2
"void HAL_UART_MspInit(UART_HandleTypeDef *huart) { if(huart->Instance == USART2) { __HAL_RCC_USART2_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); GPIO_InitTypeDef gpioUsart2; gpioUsart2.Pin = GPIO_PIN_2; gpioUsart2.Mode = GPIO_MODE_AF_PP; gpioUsart2.Pull = GPIO_PULLUP; gpioUsart2.Speed = GPIO_SPEED_FREQ_LOW; gpioUsart2.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &gpioUsart2); gpioUsart2.Pin = GPIO_PIN_3; HAL_GPIO_Init(GPIOA, &gpioUsart2); HAL_NVIC_EnableIRQ(USART2_IRQn); HAL_NVIC_SetPriority(USART2_IRQn, 15, 0); } }","Configure UART MSP (clocks, GPIO, interrupts)"
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5);",Toggle LED pin
LOS_TaskDelay(1000);,Delay task execution for 1000 ms
"STATIC UINT32 LedTask(void) { UINT32 ret = LOS_OK; while (1) { HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5); LOS_TaskDelay(1000); } return ret; }",LED task to toggle LED every 1000 ms
"__HAL_UART_ENABLE_IT(&huart3, UART_IT_RXNE);",Enable the UART interrupt handler
"HAL_UART_Transmit(&huart3, send_msg, sizeof(send_msg), 100);",Transmit message via UART
HAL_Delay(1000);,Insert 1-second delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3; PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1;,Configure USART3 clock source
static void MX_USART3_UART_Init(void),USART3 Initialization Function
huart3.Instance = USART3; huart3.Init.BaudRate = 115200; huart3.Init.WordLength = UART_WORDLENGTH_8B; huart3.Init.StopBits = UART_STOPBITS_1; huart3.Init.Parity = UART_PARITY_NONE; huart3.Init.Mode = UART_MODE_TX_RX; huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart3.Init.OverSampling = UART_OVERSAMPLING_16; huart3.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart3.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;,Configure USART3 parameters
__HAL_RCC_USART3_CLK_ENABLE();,Enable USART3 clock
"GPIO_InitTypeDef txInit = { .Pin = GPIO_PIN_8, .Mode = GPIO_MODE_AF_PP, .Pull = GPIO_NOPULL, .Speed = GPIO_SPEED_FREQ_HIGH, .Alternate = GPIO_AF7_USART3 };",Configure TX pin (PD8) for USART3
"GPIO_InitTypeDef rxInit = { .Pin = GPIO_PIN_9, .Mode = GPIO_MODE_AF_PP, .Pull = GPIO_NOPULL, .Speed = GPIO_SPEED_FREQ_HIGH, .Alternate = GPIO_AF7_USART3 };",Configure RX pin (PD9) for USART3
"HAL_GPIO_Init(((GPIO_TypeDef *)(GPIOD_BASE)), &txInit);",Initialize TX GPIO pin
"HAL_GPIO_Init(((GPIO_TypeDef *)(GPIOD_BASE)), &rxInit);",Initialize RX GPIO pin
hUART.Instance = USART3; hUART.Init.BaudRate = 115200; hUART.Init.WordLength = UART_WORDLENGTH_8B; hUART.Init.StopBits = UART_STOPBITS_1; hUART.Init.Parity = UART_PARITY_NONE; hUART.Init.HwFlowCtl = UART_HWCONTROL_NONE; hUART.Init.Mode = UART_MODE_TX_RX; hUART.Init.OverSampling = UART_OVERSAMPLING_16;,Configure USART3 parameters
HAL_UART_Init(&hUART);,Initialize USART3
"__HAL_UART_ENABLE_IT(&hUART, UART_IT_RXNE);",Enable UART receive interrupt
"HAL_NVIC_SetPriority(USART3_IRQn, 0, 1); HAL_NVIC_EnableIRQ(USART3_IRQn);",Configure and enable USART3 interrupt
void USART3_IRQHandler(void),Handle USART3 interrupt
"int _write(int file, char const *ptr, int len)",Writes characters to specified file
"while (__HAL_UART_GET_FLAG(&hUART, UART_FLAG_TXE) != SET) { }",Wait for UART transmit buffer to be empty
hUART.Instance->TDR = ((uint32_t)((*ptr++)));,Write character to UART transmit data register
MX_FSMC_Init();,Initialize FSMC peripheral
while (!MY_USB_OK) ;,Wait for USB to be ready
"if (bsp_TestExtSRAM() == 0) { printf(""SRAM Test success\r\n""); } else { printf(""SRAM Test fail\r\n""); }",Perform SRAM test and report result
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
err = 0; pSRAM = (uint32_t *)EXT_SRAM_ADDR; for (i = 0; i < EXT_SRAM_SIZE / 4; i++) { if (*pSRAM++ != i) { err++; } },Read SRAM and count errors
pSRAM = (uint32_t *)EXT_SRAM_ADDR; for (i = 0; i < EXT_SRAM_SIZE / 4; i++) { *pSRAM = ~*pSRAM; pSRAM++; },Invert SRAM data and write back
GPIO_Init();,Initialize GPIO peripherals
SystemClock_Config_HSE(SYS_CLOCK_FREQ_50_MHZ);,Configure system clock to 50 MHz using HSE
UART2_Init();,Initialize UART2 peripheral
RTC_Init();,Initialize RTC peripheral
"printmsg(""This is RTC Alarm Test program\r\n"");",Print test program message
Osc_Init.OscillatorType = RCC_OSCILLATORTYPE_HSE; Osc_Init.HSEState = RCC_HSE_ON; Osc_Init.PLL.PLLState = RCC_PLL_ON; Osc_Init.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Configure HSE oscillator and PLL
case SYS_CLOCK_FREQ_50_MHZ: Osc_Init.PLL.PLLM = 4; Osc_Init.PLL.PLLN = 50; Osc_Init.PLL.PLLP = RCC_PLLP_DIV2; Osc_Init.PLL.PLLQ = 2; Osc_Init.PLL.PLLR = 2; Clock_Init.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; Clock_Init.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; Clock_Init.AHBCLKDivider = RCC_SYSCLK_DIV1; Clock_Init.APB1CLKDivider = RCC_HCLK_DIV2; Clock_Init.APB2CLKDivider = RCC_HCLK_DIV1; flash_latency = 1;,Configure for 50 MHz system clock
HAL_SYSTICK_Config(hclk_freq / 1000);,Configure the systick timer interrupt frequency (for every 1 ms)
void RTC_Init(void),Initialize RTC
hrtc.Instance = RTC; hrtc.Init.HourFormat = RTC_HOURFORMAT_12; hrtc.Init.AsynchPrediv = 0x7F; hrtc.Init.SynchPrediv = 0xFF; hrtc.Init.OutPut = RTC_OUTPUT_DISABLE; hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_LOW; hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;,Configure RTC parameters
void RTC_CalendarConfig(void),Configure RTC calendar
"RTC_TimeInit.Hours = 12; RTC_TimeInit.Minutes = 00; RTC_TimeInit.Seconds = 00; RTC_TimeInit.TimeFormat = RTC_HOURFORMAT12_PM; HAL_RTC_SetTime(&hrtc, &RTC_TimeInit, RTC_FORMAT_BIN);",Set time to 12:00:00 PM
"RTC_DateInit.Date = 04; RTC_DateInit.Month = RTC_MONTH_JULY; RTC_DateInit.Year = 20; RTC_DateInit.WeekDay = RTC_WEEKDAY_SATURDAY; HAL_RTC_SetDate(&hrtc, &RTC_DateInit, RTC_FORMAT_BIN);","Set date to 04 July 2020, Saturday"
__HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE();,Enable GPIOA and GPIOC clocks
"ledgpio.Pin = GPIO_PIN_5; ledgpio.Mode = GPIO_MODE_OUTPUT_PP; ledgpio.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &ledgpio);",Configure PA5 for buzzer
"ledgpio.Pin = GPIO_PIN_8; ledgpio.Mode = GPIO_MODE_OUTPUT_PP; ledgpio.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &ledgpio);",Configure PA8 for warning LED
"buttongpio.Pin = GPIO_PIN_13; buttongpio.Mode = GPIO_MODE_IT_FALLING; buttongpio.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOC, &buttongpio);",Configure PC13 for button with falling edge interrupt
"HAL_NVIC_SetPriority(EXTI15_10_IRQn, 15, 0); HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);",Configure and enable EXTI interrupt
void UART2_Init(void),Initialize UART2
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.Mode = UART_MODE_TX;,Configure UART2 parameters
void RTC_AlarmConfig(void),Configure RTC alarm
AlarmA_Set.Alarm = RTC_ALARM_A; AlarmA_Set.AlarmTime.Hours = 12; AlarmA_Set.AlarmTime.Minutes = 00; AlarmA_Set.AlarmTime.Seconds = 15; AlarmA_Set.AlarmTime.TimeFormat = RTC_HOURFORMAT12_PM; AlarmA_Set.AlarmMask = RTC_ALARMMASK_DATEWEEKDAY; AlarmA_Set.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_NONE;,Set alarm for 12:00:15 PM every day
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),EXTI line detection callback
"HAL_RTC_GetTime(&hrtc, &RTC_TimeRead, RTC_FORMAT_BIN); HAL_RTC_GetDate(&hrtc, &RTC_DateRead, RTC_FORMAT_BIN);",Get current time and date
void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc),Handle RTC Alarm A event
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);",Turn buzzer on
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);",Turn LED on
HAL_Delay(2000);,2 seconds of delay
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);",Turn buzzer off
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_RESET);",Turn LED off
if (BSP_JOY_Init(JOY_MODE_GPIO) == 0) { JoyButtonInitialized = 1; },Initialize Joystick
"BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);",Configure Key button for remote wakeup
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSIState = RCC_HSI_OFF; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9; RCC_OscInitStruct.PLL.PLLR = 7;,Enable HSE Oscillator and activate PLL with HSE as source
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CLK48; PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLLSAIP; PeriphClkInitStruct.PLLSAI.PLLSAIN = 384; PeriphClkInitStruct.PLLSAI.PLLSAIQ = 7; PeriphClkInitStruct.PLLSAI.PLLSAIP = RCC_PLLSAIP_DIV8;,Select PLLSAI output as USB clock source
void CPU_CACHE_Enable(void),CPU L1-Cache enable
void Toggle_Leds(void),Toggle LEDs to show user input state
BSP_LED_Toggle(LED1); BSP_LED_Toggle(LED3);,Toggle LED1 and LED3
void MPU_Config(void),Configure the MPU
HAL_MPU_ConfigRegion(&MPU_InitStruct);,Configure MPU region
void Error_Handler(void),This function is executed in case of error occurrence
USART2_Init();,Initialize USART2 peripheral
LCD_init();,Initialize LCD
"xTaskCreate(lcdTask, ""lcdTask"", 800, NULL, 2, NULL);",Create lcdTask with priority 2
vTaskStartScheduler();,Start FreeRTOS Scheduler
LCD_sendCMD(CLEAR_LCD);,Clear LCD
LCD_sendCMD(LCD_ON);,Turn LCD on
"LCD_gotoxy(pos, 1); LCD_write(&text_top[last_char]);",Write top text to LCD at specified position
"LCD_gotoxy(pos, 2); LCD_write(&text_bot[last_char]);",Write bottom text to LCD at specified position
vTaskDelay(pdMS_TO_TICKS(3000));,Stop to show message on LCD for 3 seconds
vTaskDelay(pdMS_TO_TICKS(scroll_delay));,Delay for scrolling effect
"transmit_USART2(""Hello from task\r\n"");",Transmit message via USART2
vTaskDelay(pdMS_TO_TICKS(2000));,Delay 2 seconds between transmissions
void ledBlink(void *pvParams),Task to blink LED
LED1_On();,Turn LED1 on
LED1_Off();,Turn LED1 off
vTaskDelay(pdMS_TO_TICKS(1000));,Delay 1 second for LED blink
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim),Period elapsed callback in non-blocking mode
if (htim->Instance == TIM2) { HAL_IncTick(); },Increment tick when TIM2 interrupt occurs
MX_TIM7_Init();,Initialize TIM7 peripheral
MX_TIM6_Init();,Initialize TIM6 peripheral
MB_Init();,Initialize Modbus slave
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;,Configure USART2 clock source
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL2; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;,Configure USART2 parameters
"HAL_GPIO_WritePin(GPIOA, STEP_Pin|DIR_Pin|MS0_Pin|ENA_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(MS2_GPIO_Port, MS2_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(MS1_GPIO_Port, MS1_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = STEP_Pin|DIR_Pin|MS0_Pin|ENA_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins: STEP_Pin DIR_Pin MS0_Pin ENA_Pin
"GPIO_InitStruct.Pin = MS2_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(MS2_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin: MS2_Pin
"GPIO_InitStruct.Pin = MS1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(MS1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin: MS1_Pin
"GPIO_InitStruct.Pin = END_STOP_REVERSE_Pin|END_STOP_FORWARD_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_PULLUP; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins: END_STOP_REVERSE_Pin END_STOP_FORWARD_Pin
MX_TIM1_Init();,Initialize TIM1 peripheral
static void MX_TIM1_Init(void),TIM1 Initialization Function
htim1.Instance = TIM1; htim1.Init.Prescaler = 0; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 65535; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;,Configure TIM1 parameters
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;,Configure TIM1 master mode
static void MX_USART1_UART_Init(void),USART1 Initialization Function
"HAL_UART_Receive_IT(&huart2, &rxBuffer, 1);",Enable UART receive interrupt
"printf(""Hello, World!\n"");",Print message via UART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;,"Initializes the CPU, AHB and APB buses clocks"
"HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF);",Transmit character via UART
"GPIO_InitStruct.Pin = B1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin: B1_Pin
"GPIO_InitStruct.Pin = LD2_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin: LD2_Pin
BSP_LED_Init(LED3); BSP_LED_Init(LED4);,Initialize LEDs
osSemaphoreDef(SEM);,Define used semaphore
"osSemaphore = osSemaphoreCreate(osSemaphore(SEM) , 1);",Create the semaphore used by the two threads
"static void SemaphoreThread2(void const *argument) { uint32_t count = 0; osSemaphoreId semaphore = (osSemaphoreId) argument; for (;;) { if (semaphore != NULL) { if (osSemaphoreWait(semaphore , 0) == osOK) { osThreadResume(SemThread1Handle); count = osKernelSysTick() + 5000; while (count >= osKernelSysTick()) { BSP_LED_Toggle(LED4); osDelay(200); } BSP_LED_Off(LED4); osSemaphoreRelease(semaphore); } } } }",Semaphore Thread 2 function
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5; RCC_OscInitStruct.MSICalibrationValue=0x00; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable MSI Oscillator
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"I2cInit(&I2c, I2C_SCL, I2C_SDA);",Initialize I2C
"GpioInit(&UsbDetect, USB_ON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0);",Initialize USB detect pin
"GpioInit(&DcDcEnable, DC_DC_EN, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize DC-DC enable pin
"GpioInit(&RadioPushButton, RADIO_PUSH_BUTTON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize radio push button
"GpioInit(&Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1); GpioInit(&Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1); GpioInit(&Led3, LED_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1); GpioInit(&Led4, LED_4, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize LED pins
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSI Oscillator and Activate PLL with HSI as source
"RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
LCD_Init();,Initialize LCD
LCD_Clear(BLACK);,Clear LCD display
"LCD_ShowString(10, 50, 240, 24, 24, ""Welcome to BearPi!"");",Display welcome message on LCD
LOS_KernelInit();,Initialize LiteOS kernel
shell_uart_init(115200);,Initialize UART for shell
LOS_Start();,Start LiteOS scheduler
"LCD1602_Begin4BIT(RS_GPIO_Port, RS_Pin, E_Pin, D4_GPIO_Port, D4_Pin, D5_Pin, D6_Pin, D7_Pin);",Initialize LCD1602 in 4-bit mode
LCD1602_clear();,Clear LCD1602 display
"LCD1602_print(""I'm hungry!!"");",Print message on LCD1602 first line
LCD1602_2ndLine();,Move to second line of LCD1602
"LCD1602_print(""I wanna go home!"");",Print message on LCD1602 second line
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 180; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4; HAL_RCC_OscConfig(&RCC_OscInitStruct);,"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Initializes the CPU, AHB and APB buses clocks"
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);",Start PWM on Timer 2 Channel 1
htim2.Instance->CCR1 = i;,Set PWM compare value for Timer 2 Channel 1
HAL_Delay(100);,Delay for 100 ms
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 96; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3; PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);,Configure peripheral clock for USART3
"HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET);",Initialize the LEDs
ledReset();,Initialize the LEDs
"void ledIndicatePairInProgress(bool on) { ledStatePair = on; ledStatePairBeganTime = on ? NoteTimeST() : 0; ledStatePairTimeWasValid = NoteTimeValidST(); HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, on ? GPIO_PIN_SET : GPIO_PIN_RESET); APP_PRINTF(""%s\r\n"", on ? ""pairing mode ON"" : ""pairing mode OFF""); }",Indicate that a pairing is in progress
"void ledIndicateTransmitInProgress(bool on) { ledStateTransmit = on; if (ledDisabled()) { HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_RESET); } else { HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, on ? GPIO_PIN_SET : GPIO_PIN_RESET); } }",Indicate that a transmit is in progress
void ledIndicateAck(int flashes) { for (int i=0; i<flashes; i++) { ledSet(); HAL_Delay(250); ledReset(); HAL_Delay(250); } },Indicate OK
"bool noteInit() { NoteSetFn(malloc, free, noteDelay, noteMillis); NoteSetFnMutex(NULL, NULL, noteBeginTransaction, noteEndTransaction); NoteSetFnI2C(NOTE_I2C_ADDR_DEFAULT, NOTE_I2C_MAX_DEFAULT, noteI2CReset, noteI2CTransmit, noteI2CReceive); if (!NoteReset()) { NoteSetFnMutex(NULL, NULL, NULL, NULL); NoteSetFnDisabled(); MX_I2C2_DeInit(); return false; } return true; }",Initialize the note subsystem
void noteEndTransaction() { MX_I2C2_DeInit(); },End a notecard transaction
void noteDelay(uint32_t ms) { HAL_Delay(ms); },Arduino-like delay function
bool noteI2CReset(uint16_t DevAddress) { MX_I2C2_DeInit(); MX_I2C2_Init(); return true; },"I2C reset procedure, called before any I/O and called again upon I/O error"
void CALENDAR_Init(CALENDAR_InfoStruct *pInfoStruct) { RTC_DateTypeDef sdatestructure; RTC_TimeTypeDef stimestructure; RtcHandle.Instance = RTC; RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24; RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV; RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV; RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE; RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH; RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN; __HAL_RTC_RESET_HANDLE_STATE(&RtcHandle); if (HAL_RTC_Init(&RtcHandle) != HAL_OK) { Error_Handler(); } ... },Configure the RTC peripheral
"void CALENDAR_setDateTime(CALENDAR_InfoStruct *pInfoStruct) { RTC_DateTypeDef sdatestructure; RTC_TimeTypeDef stimestructure; sdatestructure.Year = pInfoStruct->year; sdatestructure.Month = pInfoStruct->month; sdatestructure.Date = pInfoStruct->day; sdatestructure.WeekDay = pInfoStruct->weekday; stimestructure.Hours = pInfoStruct->hours; stimestructure.Minutes = pInfoStruct->minutes; stimestructure.Seconds = pInfoStruct->seconds; stimestructure.TimeFormat = RTC_HOURFORMAT12_AM; stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; stimestructure.StoreOperation = RTC_STOREOPERATION_RESET; configure_calendar(&sdatestructure, &stimestructure); }",Configure RTC Calendar with date and time
"void CALENDAR_getDate(char *pDateString) { RTC_DateTypeDef sdatestructureget; HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN); sprintf((char *)pDateString, ""%2d-%2d-%2d"", sdatestructureget.Date, sdatestructureget.Month, 2000 + sdatestructureget.Year); }",Get the RTC current Date
"void CALENDAR_getTime(char *pTimeString) { RTC_TimeTypeDef stimestructureget; HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN); sprintf((char *)pTimeString, ""%2d:%2d:%2d"", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds); }",Get the RTC current Time
void HAL_RTC_MspInit(RTC_HandleTypeDef* hrtc) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInitStruct; __HAL_RCC_PWR_CLK_ENABLE(); HAL_PWR_EnableBkUpAccess(); RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; RCC_OscInitStruct.LSIState = RCC_LSI_ON; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); } PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI; if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { Error_Handler(); } __HAL_RCC_RTC_ENABLE(); },"Configure RTC MSP (clocks, power, backup domain)"
"static void configure_calendar(RTC_DateTypeDef *pDateStruct, RTC_TimeTypeDef *pTimeStruct) { if(HAL_RTC_SetDate(&RtcHandle, pDateStruct, RTC_FORMAT_BCD) != HAL_OK) { Error_Handler(); } if (HAL_RTC_SetTime(&RtcHandle, pTimeStruct, RTC_FORMAT_BCD) != HAL_OK) { Error_Handler(); } HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2); }",Configure the Date and Time
initialise_monitor_handles();,Initialize monitor handles for debugging
imu_init();,Initialize IMU
imu_read();,Read IMU data
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 216; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 3; HAL_RCC_OscConfig(&RCC_OscInitStruct);,"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_I2C1; PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);,Configure peripheral clocks for USART3 and I2C1
"static int app_collect_task_entry() { Init_E53_SC2(); while (1) { E53_SC2_Read_Data(); printf(""\r\n******************************Temperature      is  %d\r\n"", (int)E53_SC2_Data.Temperature); printf(""\r\n******************************Accel[0]         is  %d\r\n"", (int)E53_SC2_Data.Accel[0]); printf(""\r\n******************************Accel[1]         is  %d\r\n"", (int)E53_SC2_Data.Accel[1]); printf(""\r\n******************************Accel[2]         is  %d\r\n"", (int)E53_SC2_Data.Accel[2]); ... LCD_ShowString(10, 135, 200, 16, 16, ""Temperature:""); LCD_ShowNum(140, 135, (int)E53_SC2_Data.Temperature, 5, 16); ... } return 0; }",Task to collect and display sensor data
StateMachineHandle();,Handle state machine operations
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;,Configure USART2 and I2C1 clock sources
"Fill_Buffer(aTable, 1024, 0);",Fill the buffer in the SRAM device
uwTabAddr = (uint32_t)aTable;,Read address of the buffer
MSPValue = __get_MSP();,Get main stack pointer value
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 6;,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 180 MHz Frequency
"static void Fill_Buffer(uint32_t *pBuffer, uint32_t uwBufferLength, uint16_t uwOffset)",Fills buffer with user predefined data
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET);",Ligar o LED D1 (turn on LED D1)
"mn_led1 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_15);",Read state of LED D1
HAL_Delay(DT_D1);,Delay DT_D1 ms
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET);",Desliga o LED (turn off LED D1)
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);",Ligar o LED D2 (turn on LED D2)
"mn_led2 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_14);",Read state of LED D2
HAL_Delay(DT_D2);,Delay DT_D2 ms
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);",Desliga o LED (turn off LED D2)
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET);",Ligar o LED D3 (turn on LED D3)
"mn_led3 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_13);",Read state of LED D3
HAL_Delay(DT_D3);,Delay DT_D3 ms
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET);",Desliga o LED (turn off LED D3)
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET);",Ligar o LED D4 (turn on LED D4)
"mn_led4 = HAL_GPIO_ReadPin(GPIOB, GPIO_PIN_12);",Read state of LED D4
HAL_Delay(DT_D4);,Delay DT_D4 ms
"GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins: PB12 PB13 PB14 PB15
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
static void MX_USB_OTG_FS_HCD_Init(void),USB_OTG_FS Initialization Function
hhcd_USB_OTG_FS.Instance = USB_OTG_FS; hhcd_USB_OTG_FS.Init.Host_channels = 8; hhcd_USB_OTG_FS.Init.speed = HCD_SPEED_FULL; hhcd_USB_OTG_FS.Init.dma_enable = DISABLE; hhcd_USB_OTG_FS.Init.phy_itface = HCD_PHY_EMBEDDED; hhcd_USB_OTG_FS.Init.Sof_enable = DISABLE;,Configure USB OTG FS parameters
"HAL_UART_Transmit(&huart1, test, sizeof(test), 1000);",Transmit test data via UART
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Configure BUTTON_USER
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; oscinitstruct.HSEState = RCC_HSE_ON; oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV2; oscinitstruct.PLL.PLLState = RCC_PLL_ON; oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL6;,Enable HSE Oscillator and activate PLL with HSE as source
clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); clkinitstruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; clkinitstruct.AHBCLKDivider = RCC_SYSCLK_DIV1; clkinitstruct.APB2CLKDivider = RCC_HCLK_DIV1; clkinitstruct.APB1CLKDivider = RCC_HCLK_DIV1;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
for (i = 0; i < 48; i++) { VectorTable[i] = *(__IO uint32_t *)(0x0800C800 + (i << 2)); },Copy the vector table from the Flash (mapped at the base of the application load address 0x0800C800) to the base address of the SRAM at 0x20000000.
__HAL_RCC_SYSCFG_CLK_ENABLE();,Enable the SYSCFG peripheral clock
__HAL_SYSCFG_REMAPMEMORY_SRAM();,Remap SRAM at 0x00000000
Button_Init();,Initialize button
Luos_Loop();,Run Luos main loop
Button_Loop();,Run button handling loop
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK1;,Configure USART1 clock source
MX_FREERTOS_Init();,FreeRTOS initialization
"osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 4096); defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);",Definition and creation of defaultTask
"printf(""????1: UDP??????\r\n"");",Print entry message for Task 1: UDP data loopback test
do_udp();,UDP data loopback test
osDelay(200);,Delay 200 ms
"HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin);",Toggle LED0
osDelay(300);,Delay 300 ms
MX_MEMS_Init();,Initialize the peripherals and the MEMS components
MX_IKS01A3_LIS2DW12_6DOrientation_Init();,Initialize the LIS2DW12 6D Orientation application
MX_IKS01A3_LIS2DW12_6DOrientation_Process();,Process of the LIS2DW12 6D Orientation application
PushButtonState = (BSP_PB_GetState(BUTTON_KEY)) ? 0 : 1;,Check what is the Push Button State when the button is not pressed
set_mems_int_pin_a_exti();,Set EXTI settings for Interrupt A
BSP_COM_Init(COM1);,Initialize Virtual COM Port
"IKS01A3_MOTION_SENSOR_Init(IKS01A3_LIS2DW12_0, MOTION_ACCELERO);",Initialize motion sensor
"IKS01A3_MOTION_SENSOR_Enable_6D_Orientation(IKS01A3_LIS2DW12_0, IKS01A3_MOTION_SENSOR_INT1_PIN);",Enable 6D orientation for LIS2DW12
while ((BSP_PB_GetState( BUTTON_KEY ) == PushButtonState));,Wait until the button is released
"IKS01A3_MOTION_SENSOR_Get_Event_Status(IKS01A3_LIS2DW12_0, &status);",Get event status for motion sensor
Send_Orientation();,Send actual 6D orientation
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_XL(IKS01A3_LIS2DW12_0, &xl);",Get 6D orientation XL axis
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_XH(IKS01A3_LIS2DW12_0, &xh);",Get 6D orientation XH axis
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_YL(IKS01A3_LIS2DW12_0, &yl);",Get 6D orientation YL axis
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_YH(IKS01A3_LIS2DW12_0, &yh);",Get 6D orientation YH axis
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_ZL(IKS01A3_LIS2DW12_0, &zl);",Get 6D orientation ZL axis
"IKS01A3_MOTION_SENSOR_Get_6D_Orientation_ZH(IKS01A3_LIS2DW12_0, &zh);",Get 6D orientation ZH axis
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = 0; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_5; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;,Configure USART1 clock source
huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;,Configure USART1 parameters
"bool i2cBegin(uint8_t ch, uint32_t freq_khz) { I2C_HandleTypeDef *p_handle = i2c_tbl[ch].p_hi2c; if (ch >= I2C_MAX_CH) { return false; } switch(ch) { case _DEF_I2C1: case _DEF_I2C2: i2c_freq[ch] = freq_khz; p_handle->Init.ClockSpeed = freq_khz * 1000; p_handle->Init.OwnAddress1 = 0x00; p_handle->Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT; p_handle->Init.DualAddressMode = I2C_DUALADDRESS_DISABLE; p_handle->Init.OwnAddress2 = 0xFF; p_handle->Init.GeneralCallMode = I2C_GENERALCALL_DISABLE; p_handle->Init.NoStretchMode = I2C_NOSTRETCH_DISABLE; HAL_I2C_DeInit(p_handle); if(HAL_I2C_Init(p_handle) != HAL_OK) { } HAL_I2CEx_ConfigAnalogFilter(p_handle,I2C_ANALOGFILTER_ENABLE); return true; is_init[ch] = true; break; } return false; }",Start I2C communication on specified channel with given frequency
"void i2cReset(uint8_t ch) { GPIO_InitTypeDef GPIO_InitStruct; i2c_tbl_t *p_pin = &i2c_tbl[ch]; GPIO_InitStruct.Pin = p_pin->scl_pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; HAL_GPIO_Init(p_pin->scl_port, &GPIO_InitStruct); GPIO_InitStruct.Pin = p_pin->sda_pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_OD; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(p_pin->sda_port, &GPIO_InitStruct); HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET); HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET); delayUs(5); for (int i = 0; i < 9; i++) { HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET); delayUs(5); HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET); delayUs(5); } HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_RESET); delayUs(5); HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_RESET); delayUs(5); HAL_GPIO_WritePin(p_pin->scl_port, p_pin->scl_pin, GPIO_PIN_SET); delayUs(5); HAL_GPIO_WritePin(p_pin->sda_port, p_pin->sda_pin, GPIO_PIN_SET); }",Reset I2C bus by toggling SCL and SDA pins
"bool i2cRecovery(uint8_t ch) { i2cReset(ch); return i2cBegin(ch, i2c_freq[ch]); }",Recover I2C bus by resetting and reinitializing
"bool i2cReadByte(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t timeout) { return i2cReadBytes(ch, dev_addr, reg_addr, p_data, 1, timeout); }",Read a single byte from I2C device
"void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin); }",Toggle LED on EXTI interrupt
"int link_test() { int ret = -1; UINT32 uwRet = LOS_OK; UINT32 handle; TSK_INIT_PARAM_S task_init_param; memset(&task_init_param, 0, sizeof(TSK_INIT_PARAM_S)); task_init_param.uwArg = (unsigned int)NULL; task_init_param.usTaskPrio = 2; task_init_param.pcName = (char *)""link_main""; task_init_param.pfnTaskEntry = (TSK_ENTRY_FUNC)link_main; task_init_param.uwStackSize = 0x1000; uwRet = LOS_TaskCreate(&handle, &task_init_param); if(LOS_OK == uwRet) { ret = 0; } return ret; }",Create a task for link_main
int main(void) { UINT32 uwRet = LOS_OK; HardWare_Init(); uwRet = LOS_KernelInit(); if (uwRet != LOS_OK) { return LOS_NOK; } link_test(); (void)LOS_Start(); return 0; },Main application entry with LiteOS kernel initialization
float max6675Temp(uint16_t reg) { return reg * 0.25; },Convert MAX6675 register value to temperature
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM2) { HAL_IncTick(); } },Period elapsed callback in non blocking mode
static void CPU_CACHE_Enable(void) { SCB_EnableICache(); SCB_EnableDCache(); },Enable the CPU Cache
"static void EXTI15_10_IRQHandler_Config(void) { GPIO_InitTypeDef GPIO_InitStructure; __HAL_RCC_GPIOC_CLK_ENABLE(); GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Pin = GPIO_PIN_13; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure); HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0); HAL_NVIC_EnableIRQ(EXTI15_10_IRQn); }",Configures EXTI line 15_10 (connected to PC.13 pin) in interrupt mode
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if (GPIO_Pin == GPIO_PIN_13) { BSP_LED_Toggle(LED1); } },Toggle LED1 on EXTI interrupt
BSP_LED_Init(LED1);,Initialize LEDs mounted on STM32F722ZE-Nucleo board
"static void init_filesystem(void) { int32_t retv; retv = finit(""M0:""); if (retv == fsOK) { retv = fmount(""M0:""); if (retv == fsOK) { printf(""Drive M0 ready!\n""); } else { printf(""Drive M0 mount failed(%d)!\n"", retv); } } else { printf(""Drive M0 initialization failed!\n""); } }",Initialize a Flash Memory Card
main_NVM();,Initialize non-volatile memory operations
"bool gpioInit(void) { bool ret = true; __HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); for (int i=0; i<GPIO_MAX_CH; i++) { gpioPinMode(i, gpio_tbl[i].mode); gpioPinWrite(i, gpio_tbl[i].init_value); } #ifdef _USE_HW_CLI cliAdd(""gpio"", cliGpio); #endif return ret; }",Initialize GPIO pins based on configuration table
"bool gpioPinMode(uint8_t ch, uint8_t mode) { bool ret = true; GPIO_InitTypeDef GPIO_InitStruct = {0}; if (ch >= GPIO_MAX_CH) { return false; } switch(mode) { case _DEF_INPUT: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_INPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_INPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; case _DEF_OUTPUT: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_OUTPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_OUTPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; } GPIO_InitStruct.Pin = gpio_tbl[ch].pin; HAL_GPIO_Init(gpio_tbl[ch].port, &GPIO_InitStruct); return ret; }","Configure GPIO pin mode (input/output, pull-up/down)"
"void gpioPinWrite(uint8_t ch, bool value) { if (ch >= GPIO_MAX_CH) { return; } if (value) { HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].on_state); } else { HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].off_state); } }",Write value to GPIO pin (on/off state)
"void gpioPinToggle(uint8_t ch) { if (ch >= GPIO_MAX_CH) { return; } HAL_GPIO_TogglePin(gpio_tbl[ch].port, gpio_tbl[ch].pin); }",Toggle GPIO pin state
BSP_LED_Init(LED1); BSP_LED_Init(LED2); BSP_LED_Init(LED3);,Initialize LEDs
BSP_LED_On(LED1); BSP_LED_On(LED3);,Turn on LED1 and LED3
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
LED1_OFF(); LED2_OFF(); CARD_RESET_ON(); CARD_SWITCH_OFF();,Turn off LEDs and configure card reset/switch
MX_FREERTOS_Init();,Call init function for freertos objects
"HAL_NVIC_SetPriority(SysTick_IRQn, 15, 0);",SysTick_IRQn interrupt configuration
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },Increment tick on TIM6 interrupt for application time base
app_periodic();,Run periodic application tasks
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLLMUL_6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLLDIV_3; HAL_RCC_OscConfig(&RCC_OscInitStruct);,"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);,Configure peripheral clock for USART1
MPU_Config();,Configure the MPU
init_filesystem();,Initialize a Flash Memory Card
net_initialize();,Initialize network
"osThreadCreate(osThread(net_loop), NULL);",Create network loop thread
echoclient_test(&args);,Run echo client test
osDelay(1000);,Delay for 1000 ms
setTime((RTC_YEAR-1970)*365*24*60*60 + RTC_MONTH*30*24*60*60 + RTC_DAY*24*60*60);,Set system time for certificate validation
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Initializes the CPU, AHB and APB buses clocks"
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim) { if (htim->Instance == TIM1) { HAL_IncTick(); } else { CUSTOM_TIM_PeriodElapsedCallback(htim); } },Increment tick on TIM1 interrupt or call custom callback for other timers
"osThreadDef(toggleGreen, toggleGreenHook, osPriorityNormal, 0, 128); toggleGreenHandle = osThreadCreate(osThread(toggleGreen), NULL);",Create thread to toggle green LED
"osThreadDef(toggleRed, toggleRedHook, osPriorityNormal, 0, 128); toggleRedHandle = osThreadCreate(osThread(toggleRed), NULL);",Create thread to toggle red LED
"osThreadDef(toggleBlue, toggleBlueHook, osPriorityNormal, 0, 128); toggleBlueHandle = osThreadCreate(osThread(toggleBlue), NULL);",Create thread to toggle blue LED
"void toggle(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, uint32_t frequency, int duration) { TickType_t start = xTaskGetTickCount(); do { HAL_GPIO_TogglePin(GPIOx, GPIO_Pin); HAL_Delay(frequency); } while((xTaskGetTickCount() - start) <= duration); }",Toggle GPIO pin at specified frequency for a duration
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);","Initializes the CPU, AHB and APB buses clocks"
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM1) { HAL_IncTick(); } },Increment tick on TIM1 interrupt for application time base
MX_TIM1_Init();,Initialize Timer 1
BTNS_CONTROL_init();,Initialize button controls
uart2_dbg_init();,Initialize UART2 for debugging
HAL_Delay(500);,Delay for 500 ms
STEPPER_CONTROLS_ST2_DISABLE(); STEPPER_CONTROLS_ST1_DISABLE();,Disable stepper motors
uart2_dbg_handler();,Handle UART2 debug communication
uart2_dbg_cmd_handler();,Handle UART2 debug commands
STEPPER_CONTROLS_handler();,Handle stepper motor control
void system_tick_1khz(void) { cnt_event++; if (cnt_event>=500) { cnt_event=0; } cnt_100hz++; if (cnt_100hz>=10) { cnt_100hz=0; BTNS_CONTROL_handler_100Hz(); } },Handle 1kHz system tick and 100Hz button control events
htim1.Instance = TIM1; htim1.Init.Prescaler = 639; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 19; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; HAL_TIM_Base_Init(&htim1);,Configure Timer 1 for 5kHz interrupts
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { STEPPER_CONTROLS_handler_5kHz(); counter_a++; if (counter_a>5000) { counter_a=0; } },Handle 5kHz stepper control on Timer 1 interrupt
btstack_tx_hdma.Instance = pdata->tx_dma; btstack_tx_hdma.Init.Channel = pdata->tx_dma_ch; btstack_tx_hdma.Init.Direction = DMA_MEMORY_TO_PERIPH; btstack_tx_hdma.Init.PeriphInc = DMA_PINC_DISABLE; btstack_tx_hdma.Init.MemInc = DMA_MINC_ENABLE; btstack_tx_hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; btstack_tx_hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; btstack_tx_hdma.Init.Mode = DMA_NORMAL; btstack_tx_hdma.Init.Priority = DMA_PRIORITY_VERY_HIGH; btstack_tx_hdma.Init.FIFOMode = DMA_FIFOMODE_DISABLE; btstack_tx_hdma.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL; btstack_tx_hdma.Init.MemBurst = DMA_MBURST_SINGLE; btstack_tx_hdma.Init.PeriphBurst = DMA_PBURST_SINGLE; HAL_DMA_Init(&btstack_tx_hdma);,Configure DMA for UART TX
btstack_rx_hdma.Instance = pdata->rx_dma; btstack_rx_hdma.Init.Channel = pdata->rx_dma_ch; btstack_rx_hdma.Init.Direction = DMA_PERIPH_TO_MEMORY; btstack_rx_hdma.Init.PeriphInc = DMA_PINC_DISABLE; btstack_rx_hdma.Init.MemInc = DMA_MINC_ENABLE; btstack_rx_hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; btstack_rx_hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; btstack_rx_hdma.Init.Mode = DMA_NORMAL; btstack_rx_hdma.Init.Priority = DMA_PRIORITY_VERY_HIGH; btstack_rx_hdma.Init.FIFOMode = DMA_FIFOMODE_DISABLE; btstack_rx_hdma.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL; btstack_rx_hdma.Init.MemBurst = DMA_MBURST_SINGLE; btstack_rx_hdma.Init.PeriphBurst = DMA_PBURST_SINGLE; HAL_DMA_Init(&btstack_rx_hdma);,Configure DMA for UART RX
btstack_huart.Instance = pdata->uart; btstack_huart.Init.BaudRate = config->baudrate; btstack_huart.Init.WordLength = UART_WORDLENGTH_8B; btstack_huart.Init.StopBits = UART_STOPBITS_1; btstack_huart.Init.Parity = UART_PARITY_NONE; btstack_huart.Init.Mode = UART_MODE_TX_RX; btstack_huart.Init.HwFlowCtl = config->flowcontrol ? UART_HWCONTROL_RTS_CTS : UART_HWCONTROL_NONE; btstack_huart.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&btstack_huart);,Configure UART for BTStack
"HAL_UART_Receive_DMA(&btstack_huart, buffer, len);",Start UART receive with DMA
"HAL_UART_Transmit_DMA(&btstack_huart, (uint8_t *)data, size);",Start UART transmit with DMA
void HAL_UART_TxCpltCallback(UART_HandleTypeDef *huart) { send_complete = true; pbdrv_bluetooth_btstack_run_loop_contiki_trigger(); },Handle UART transmit complete callback
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { receive_complete = true; pbdrv_bluetooth_btstack_run_loop_contiki_trigger(); },Handle UART receive complete callback
void MX_FRAM_Init() { fram_init(); },Initialize FRAM driver
"void fram_init() { if (HAL_I2C_GetState(&hi2c1) == HAL_I2C_STATE_RESET) { oprintf(""I2C1 must be initialised. \r\n""); } if(resetFlag == 0) system_init(); memset(&status, 0x00, sizeof(fram_sys)); #if FRAM_CLEAR_ON_INIT == 1 memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); #endif memError |= !fram_read_private(0, 0, &status, sizeof(fram_sys)); if(!status.flags.intialized) { status.flags.intialized = 1; memcpy(&(status.name), MODULE_NAME, strlen(MODULE_NAME)); memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); memset(&status, 0x00, sizeof(fram_sys)); } memError |= !fram_read_private(0, 0, &status, sizeof(fram_sys)); status.totalReset_cycles++; switch(getResetFlag()) { case RCC_FLAG_BORRST: status.borResets++; break; case RCC_FLAG_PINRST: status.pinResets++; break; case RCC_FLAG_PORRST: status.porResets++; break; case RCC_FLAG_SFTRST: status.softwareResets++; break; case RCC_FLAG_IWDGRST: status.independendWatchdogResets++; break; case RCC_FLAG_WWDGRST: status.windowedWatchdogResets++; break; case RCC_FLAG_LPWRRST: status.lowPowerResets++; break; default: break; } memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); }",Initialize FRAM and track system reset causes
"int fram_write(uint8_t page, uint16_t address, void* data, size_t dataLength) { if(memError) return 0; return fram_write_private(page + 1, address, data, dataLength); }",Write data to FRAM
int fram_busy() { return hi2c1.State != HAL_I2C_STATE_READY; },Check if FRAM is busy
void system_init() { if(__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST)) resetFlag = RCC_FLAG_BORRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST)) resetFlag = RCC_FLAG_PINRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST)) resetFlag = RCC_FLAG_PORRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST)) resetFlag = RCC_FLAG_SFTRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST)) resetFlag = RCC_FLAG_IWDGRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST)) resetFlag = RCC_FLAG_WWDGRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST)) resetFlag = RCC_FLAG_LPWRRST; else resetFlag = 0; __HAL_RCC_CLEAR_RESET_FLAGS(); },Initialize system and determine reset cause
"int getSystemID(char* buffer, uint32_t bufferSize) { if(bufferSize < SYSTEM_ID_STRING_SIZE) { return 0; } return sprintf(buffer,""%s: %lX%lX%lX"",SYSTEM_NAME,STM32_UUID[0],STM32_UUID[1],STM32_UUID[2]); }",Get system ID based on STM32 UUID
Distance_Init();,Initialize distance module
Distance_Loop();,Run distance handling loop
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
"if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_8) == GPIO_PIN_SET){ HAL_Delay(10); if(HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_8) == GPIO_PIN_SET){ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET); } else{ HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_SET); } }",Read GPIOA PIN_8 and control GPIOB PIN_0 based on debounced input
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
"HAL_NVIC_SetPriority(PendSV_IRQn, 0x0f, 0);",PendSV_IRQn interrupt configuration
stduart_init();,Default UART initialization
aos_msleep(50);,"Sufficient time to make the initial GPIO level works, especially wifi reset"
hal_gpio_output_high(&brd_gpio_table[GPIO_WIFI_RST]);,Set WiFi reset GPIO high
MX_ADC3_Init();,Initialize ADC3
MX_DCMI_Init();,Initialize DCMI
MX_SAI2_Init();,Initialize SAI2
MX_USB_OTG_FS_USB_Init();,Initialize USB OTG FS
MX_TIM1_Init();,Initialize TIM1
MX_TIM17_Init();,Initialize TIM17
MX_TIM16_Init();,Initialize TIM16
MX_IRTIM_Init();,Initialize IRTIM
irda_init();,Initialize IRDA (conditional)
uart_0.port = 0; uart_0.config.baud_rate = 115200; uart_0.config.data_width = DATA_WIDTH_8BIT; uart_0.config.flow_control = FLOW_CONTROL_DISABLED; uart_0.config.mode = MODE_TX_RX; uart_0.config.parity = NO_PARITY; uart_0.config.stop_bits = STOP_BITS_1;,Configure UART0 parameters
hal_uart_init(&uart_0);,Initialize UART0
for (i = 0; i < gpcfg_num; ++i) { hal_gpio_init(&brd_gpio_table[i]); },Initialize all GPIOs in board GPIO table
hal_i2c_init(&brd_i2c2_dev); hal_i2c_init(&brd_i2c3_dev); hal_i2c_init(&brd_i2c4_dev);,"Initialize I2C2, I2C3, and I2C4"
void SysTick_Handler(void),This function handles System tick timer.
krhino_tick_proc();,Process Rhino kernel tick
lv_tick_inc(1);,Increment LittlevGL tick (conditional)
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 2; RCC_OscInitStruct.PLL.PLLN = 25; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1; PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_HSI;,Configure LPUART1 clock source
hlpuart1.Instance = LPUART1; hlpuart1.Init.BaudRate = 209700; hlpuart1.Init.WordLength = UART_WORDLENGTH_7B; hlpuart1.Init.StopBits = UART_STOPBITS_1; hlpuart1.Init.Parity = UART_PARITY_NONE; hlpuart1.Init.Mode = UART_MODE_TX_RX; hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1; hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; hlpuart1.FifoMode = UART_FIFOMODE_DISABLE;,Configure LPUART1 parameters
"if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK)",Set LPUART1 TX FIFO threshold
"if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK)",Set LPUART1 RX FIFO threshold
"data = ""AT+CIPCLOSE\r\n""; HAL_UART_Transmit(&huart1, data, strlen(data), 100);",Close TCP connection
ADS1292_Init();,Initialize ADS1292
"data = ""AT+CIPMODE=1\r\n""; HAL_UART_Transmit(&huart1, data, strlen(data), 100);",Set WiFi to pass-through mode
"data = ""AT+CIPSEND\r\n""; HAL_UART_Transmit(&huart1, data, strlen(data), 100);",Enable data sending
ADS1292_DRDYEXTI_ENABLE();,Enable DRDY interrupt
ADS1292_StreamData();,Start streaming data from ADS1292
LED_TOGGLE;,Toggle LED
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL8;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
static void MX_NVIC_Init(void),NVIC Configuration
"HAL_NVIC_SetPriority(SPI1_IRQn, 1, 1); HAL_NVIC_EnableIRQ(SPI1_IRQn);",SPI1_IRQn interrupt configuration
"HAL_NVIC_SetPriority(EXTI0_IRQn, 1, 0); HAL_NVIC_EnableIRQ(EXTI0_IRQn);",EXTI0_IRQn interrupt configuration
htim3.Instance = TIM3; htim3.Init.Prescaler = TIMER3_PRESCALER - 1; htim3.Init.CounterMode = TIM_COUNTERMODE_UP; htim3.Init.Period = TIMER3_RELOAD - 1; htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;,Configure TIM3 parameters
sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET; sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;,Configure TIM3 master output trigger and slave mode
if (HAL_TIM_Base_Start_IT(&htim3) != HAL_OK),Start TIM3 with interrupts
__HAL_RCC_TIM3_CLK_ENABLE();,TIM3 clock enable
__HAL_RCC_TIM3_CLK_DISABLE();,Peripheral clock disable
void TIM3_IRQHandler(void),This function handles TIM3 global interrupt.
HAL_TIM_IRQHandler(&htim3);,Handle TIM3 interrupt
"ret = LOS_HwiCreate(TIM_IRQ, 0, 0, TIM3_IRQHandler, 0);",Create TIM3 interrupt with LOS
UINT64 GetTimerCycles(VOID),Get timer cycle count
void Error_Handler(),Error handler function
"defaultTaskHandle = osThreadNew(StartDefaultTask, NULL, &defaultTask_attributes);",Create defaultTask thread
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
void StartDefaultTask(void *argument),Function implementing the defaultTask thread.
osDelay(1);,Delay 1 ms in default task
if (htim->Instance == TIM2) { HAL_IncTick(); },Increment tick if TIM2 interrupt occurs
HAL_MSPInit();,Initialize MSP (MCU Support Package)
GPIO_Init();,Initialize GPIO
HAL_PWR_EnableSleepOnExit();,Enable sleep-on-exit mode
__WFI();,Wait for interrupt
void SetupGPIOsForPowerSave(void),Configure GPIOs for power saving
void SetupGPIOAForPowerSave(void),Configure GPIOA for power saving
gpioA.Pin = GPIO_PIN_1 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12; gpioA.Mode = GPIO_MODE_ANALOG;,Set specified GPIOA pins to analog mode
"HAL_GPIO_Init(GPIOA, &gpioA);",Initialize GPIOA pins
void SetupGPIODForPowerSave(void),Configure GPIOD for power saving
gpioD.Pin = GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2 | GPIO_PIN_3 | GPIO_PIN_4 | GPIO_PIN_5 | GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15; gpioD.Mode = GPIO_MODE_ANALOG;,Set specified GPIOD pins to analog mode
"HAL_GPIO_Init(GPIOD, &gpioD);",Initialize GPIOD pins
"HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0); HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0); HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);",Set priorities for system fault interrupts
uart_2.Instance = USART2; uart_2.Init.BaudRate = 9600; uart_2.Init.WordLength = UART_WORDLENGTH_8B; uart_2.Init.HwFlowCtl = UART_HWCONTROL_NONE; uart_2.Init.StopBits = UART_STOPBITS_1; uart_2.Init.Parity = UART_PARITY_NONE; uart_2.Init.Mode = UART_MODE_TX;,Configure UART2 parameters
void Button_Init(),Initialize button
led_gpio.Mode = GPIO_MODE_IT_FALLING; led_gpio.Pin = GPIO_PIN_0; led_gpio.Pull = GPIO_PULLDOWN; led_gpio.Speed = GPIO_SPEED_LOW;,Configure button GPIO (GPIOA PIN_0) for interrupt on falling edge
"__NVIC_SetPriority(EXTI0_IRQn, 15); __NVIC_EnableIRQ(EXTI0_IRQn);",Configure EXTI0 interrupt
__HAL_RCC_GPIOA_CLK_SLEEP_DISABLE();,Disable GPIOA clock in sleep mode
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),Handle GPIO EXTI callback
"char *msg = ""Button pressed.\r\n""; HAL_UART_Transmit(&uart_2, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);",Transmit button press message via UART2
led_gpio.Pin = GPIO_PIN_12; led_gpio.Mode = GPIO_MODE_OUTPUT_PP; led_gpio.Pull = GPIO_NOPULL; led_gpio.Speed = GPIO_SPEED_LOW;,Configure GPIOD PIN_12 as output
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim),Handle timer period elapsed callback
"HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_SET);",Set GPIOD PIN_12 high
"char *msg = ""SLEEP ON EXIT testing\r\n""; HAL_UART_Transmit(&uart_2, (uint8_t *)msg, strlen(msg), HAL_MAX_DELAY);",Transmit sleep test message via UART2
"HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);",Set GPIOD PIN_12 low
__HAL_RCC_GPIOD_CLK_DISABLE();,Disable GPIOD clock
void Error_Handler(void),Error handler function
"f_mount(&fs, SD_Path, 1)",Mount FATFS on SD card
f_closedir(&dp);,Close directory
"setReg(SCI_MODE, 0x4804);",Set SCI_MODE register
"setReg(SCI_CLOCKF, 0x8BE8);",Set SCI_CLOCKF register
"while (HAL_GPIO_ReadPin(DREQ_GPIO_Port, DREQ_Pin)==GPIO_PIN_RESET)",Wait for DREQ signal
"HAL_GPIO_WritePin(XDCS_GPIO_Port, XDCS_Pin, GPIO_PIN_RESET); HAL_SPI_Transmit(&hspi2, data, br, 100); HAL_GPIO_WritePin(XDCS_GPIO_Port, XDCS_Pin, GPIO_PIN_SET);",Transmit data via SPI2
getReg(SCI_DECODE_TIME);,Read SCI_DECODE_TIME register
"HAL_GPIO_WritePin(D2_GPIO_Port, D2_Pin, GPIO_PIN_SET); HAL_Delay(50); HAL_GPIO_WritePin(D2_GPIO_Port, D2_Pin, GPIO_PIN_RESET);",Blink LED
f_close(&fp);,Close file
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;,"Initializes the CPU, AHB and APB buses clocks"
HAL_RCC_EnableCSS();,Enables the Clock Security System
BSP_LED_Off(LED1);,Turn off LED1
osThreadSuspend(NULL);,Suspend Thread 1
osThreadResume(LEDThread2Handle);,Resume Thread 2
osDelay(500);,Delay 500 ms
BSP_LED_Off(LED3);,Turn off LED3
osThreadResume(LEDThread1Handle);,Resume Thread 1
osThreadSuspend(NULL);,Suspend Thread 2
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2 |RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C3 |RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48; PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c3ClockSelection = RCC_I2C3CLKSOURCE_PCLK1; PeriphClkInitStruct.Clk48ClockSelection = RCC_CLK48SOURCE_PLL; PeriphClkInitStruct.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_CLK48;,"Configure peripheral clocks for USART1, USART2, I2C1, I2C3, SDMMC1, and CLK48"
if(BSP_PB_GetState(BUTTON_WAKEUP) == 0x00) { if(((*(__IO uint32_t*)USBD_DFU_APP_DEFAULT_ADD) & 0x2FF80000 ) == 0x20000000) { JumpAddress = *(__IO uint32_t*) (USBD_DFU_APP_DEFAULT_ADD + 4); JumpToApplication = (pFunction) JumpAddress; __set_MSP(*(__IO uint32_t*) USBD_DFU_APP_DEFAULT_ADD); JumpToApplication(); } },Check if the KEY Button is pressed ... Test if user code is programmed starting from USBD_DFU_APP_DEFAULT_ADD address ... Jump to user application ... Initialize user application's Stack Pointer
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2;,Enable HSE Oscillator and activate PLL with HSE as source
PeriphClkInitStruct.PLLI2S.PLLI2SM = 8; PeriphClkInitStruct.PLLI2S.PLLI2SQ = 4; PeriphClkInitStruct.PLLI2S.PLLI2SN = 192; PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48; PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLI2SQ;,Select PLLSAI output as USB clock source
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 8; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;,Configure peripheral clock for USART2
if (htim->Instance == TIM3) { HAL_IncTick(); },"Period elapsed callback in non blocking mode ... This function is called when TIM3 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 20; RCC_OscInitStruct.PLL.PLLR = 2; RCC_OscInitStruct.PLL.PLLP = 7; RCC_OscInitStruct.PLL.PLLQ = 4;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 15; RCC_OscInitStruct.PLL.PLLR = 7;,Enable HSI Oscillator and activate PLL with HSI as source
hspi2.Instance = SPI2; hspi2.Init.Mode = SPI_MODE_MASTER; hspi2.Init.Direction = SPI_DIRECTION_2LINES; hspi2.Init.DataSize = SPI_DATASIZE_8BIT; hspi2.Init.CLKPolarity = SPI_POLARITY_LOW; hspi2.Init.CLKPhase = SPI_PHASE_1EDGE; hspi2.Init.NSS = SPI_NSS_SOFT; hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256; hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi2.Init.TIMode = SPI_TIMODE_DISABLE; hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi2.Init.CRCPolynomial = 10;,SPI2 parameter configuration
"if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1){ ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_1, ccr_content + timer_pulse_500hz); }",TIM2_CH1 Toggling with frequency = 500 Hz
"if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_2){ ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_2); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_2, ccr_content + timer_pulse_1000hz); }",TIM2_CH1 Toggling with frequency = 1000 Hz
"if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_3){ ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_3); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_3, ccr_content + timer_pulse_2000hz); }",TIM2_CH1 Toggling with frequency = 2000 Hz
"if(htim->Channel == HAL_TIM_ACTIVE_CHANNEL_4){ ccr_content = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_4); __HAL_TIM_SET_COMPARE(htim, TIM_CHANNEL_4, ccr_content + timer_pulse_4000hz); }",TIM2_CH1 Toggling with frequency = 4000 Hz
timer2_handle.Instance = TIM2; timer2_handle.Init.CounterMode = TIM_COUNTERMODE_UP; timer2_handle.Init.Period = 0xFFFFFFFF; timer2_handle.Init.Prescaler = 1;,Initialize the TIMER Output Compare Time base
timer2OC_Config.OCMode = TIM_OCMODE_TOGGLE; timer2OC_Config.OCPolarity = TIM_OCPOLARITY_HIGH;,Configure Output Channels of the Timer
"timer2OC_Config.Pulse = timer_pulse_500hz; if(HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_1) != HAL_OK) Error_handler();",500hz - channel 1
"timer2OC_Config.Pulse = timer_pulse_2000hz; if(HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_3) != HAL_OK) Error_handler();",2000hz - channel 3
"timer2OC_Config.Pulse = timer_pulse_4000hz; if(HAL_TIM_OC_ConfigChannel(&timer2_handle, &timer2OC_Config, TIM_CHANNEL_4) != HAL_OK) Error_handler();",4000hz - channel 4
"if (KETCube_wasResetPOR == TRUE) { ketCube_terminal_CoreSeverityPrintln(KETCUBE_CFG_SEVERITY_INFO, ""POR detected - reseting!""); NVIC_SystemReset(); }",A hot fix for non-operational RTC after POR - this should be removed in the future ... perform SW reset
if (ketCube_modules_Init() != KETCUBE_CFG_OK) { KETCube_ErrorHandler(); },Init KETCube modules
ketCube_terminal_ProcessCMD();,process pendig commands
"if (KETCube_PeriodTimerElapsed == TRUE) { KETCube_PeriodTimerElapsed = FALSE; ketCube_terminal_CoreSeverityPrintln (KETCUBE_CFG_SEVERITY_DEBUG, ""--- KETCube base period # %d ---"", basePeriodCnt++); ketCube_modules_ExecutePeriodic(); }",execute periodic function for enabled modules
if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) == TRUE) { KETCube_wasResetPOR = TRUE; } else { KETCube_wasResetPOR = FALSE; } __HAL_RCC_CLEAR_RESET_FLAGS();,KETCube_getResetFlags
"sprintf(msg, ""SYSCLK: %ld\r\n"", HAL_RCC_GetSysClockFreq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Report system clock frequency
"sprintf(msg, ""HCLCK: %ld\r\n"", HAL_RCC_GetHCLKFreq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Report HCLK frequency
"sprintf(msg, ""PCLK1: %ld\r\n"", HAL_RCC_GetPCLK1Freq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Report PCLK1 frequency
"sprintf(msg, ""PCLK2: %ld\r\n"", HAL_RCC_GetPCLK2Freq()); HAL_UART_Transmit(&uart_2, (uint8_t *)msg, sizeof(msg), HAL_MAX_DELAY);",Report PCLK2 frequency
uart_2.Instance = USART2; uart_2.Init.BaudRate = 9600; uart_2.Init.WordLength = UART_WORDLENGTH_8B; uart_2.Init.HwFlowCtl = UART_HWCONTROL_NONE; uart_2.Init.StopBits = UART_STOPBITS_1; uart_2.Init.Parity = UART_PARITY_NONE; uart_2.Init.Mode = UART_MODE_TX_RX;,Configure USART2 parameters
__HAL_RCC_USART2_CLK_ENABLE();,Enable Clock for USART2 periph.
__HAL_RCC_GPIOA_CLK_ENABLE();,Configure GPIO
"gpioUsart2.Pin = GPIO_PIN_2; gpioUsart2.Mode = GPIO_MODE_AF_PP; gpioUsart2.Pull = GPIO_PULLUP; gpioUsart2.Speed = GPIO_SPEED_FREQ_LOW; gpioUsart2.Alternate = GPIO_AF7_USART2; HAL_GPIO_Init(GPIOA, &gpioUsart2);",GPIOA::PIN2 (TX)
"gpioUsart2.Pin = GPIO_PIN_3; HAL_GPIO_Init(GPIOA, &gpioUsart2);",GPIOA::PIN3 (RX)
"HAL_NVIC_EnableIRQ(USART2_IRQn); HAL_NVIC_SetPriority(USART2_IRQn, 15, 0);",Enable IRQ/Set Priority
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_5); LOS_TaskDelay(1000);",Toggle LED and delay in LED task
LedTaskCreate();,Create LED task
DemoEntry();,Run demo entry function
i2cInit(),Initialize I2C module
"i2cBegin(uint8_t ch, uint32_t freq_khz)",Begin I2C communication on specified channel with given frequency
i2cRecovery(uint8_t ch),Recover I2C channel by resetting and reinitializing
"i2cReadByte(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t timeout)",Read a single byte from I2C device
"i2cReadBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)",Read multiple bytes from I2C device
"i2cWriteByte(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t data, uint32_t timeout)",Write a single byte to I2C device
"i2cWriteBytes(uint8_t ch, uint16_t dev_addr, uint16_t reg_addr, uint8_t *p_data, uint32_t length, uint32_t timeout)",Write multiple bytes to I2C device
"i2cSetTimeout(uint8_t ch, uint32_t timeout)",Set timeout for I2C channel
i2cGetTimeout(uint8_t ch),Get timeout for I2C channel
i2cClearErrCount(uint8_t ch),Clear error count for I2C channel
i2cGetErrCount(uint8_t ch),Get error count for I2C channel
i2cCmdifInit(),Initialize command interface for I2C
i2cCmdif(),Handle I2C commands via command interface
"HAL_I2CEx_ConfigAnalogFilter(p_handle, I2C_ANALOGFILTER_ENABLE)",Enable the Analog I2C Filter
HAL_Init(),"Reset of all peripherals, Initializes the Flash interface and the Systick."
SystemClock_Config(),Configure the system clock
HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),Toggle LED on EXTI interrupt
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL12; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"HAL_GPIO_WritePin(LED_GPIO_Port, LED_Pin, GPIO_PIN_RESET)",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = BUTTON_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(BUTTON_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : BUTTON_Pin
"GPIO_InitStruct.Pin = LED_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LED_Pin
max6675ReadReg(uint16_t *reg),Read register from MAX6675 thermocouple sensor
max6675Temp(uint16_t reg),Convert MAX6675 register value to temperature
"HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13)",Toggle LED pin
"HAL_UART_Transmit(&huart1, string, sizeof(string), 100)",Transmit temperature data over UART
MAX6675_CS_SET(),Set chip select for MAX6675
MAX6675_CS_RESET(),Reset chip select for MAX6675
"HAL_SPI_Receive(MAX6675_SPI, temp_buf, 2, 100)",Receive data from MAX6675 via SPI
HAL_Init(),"STM32F7xx HAL library initialization: Configure the Flash prefetch, Set NVIC Group Priority to 4, Low Level Initialization"
SystemClock_Config(),Configure the system clock to 216 MHz
BSP_LED_Init(LED1),Initialize LEDs mounted on STM32F722ZE-Nucleo board
EXTI15_10_IRQHandler_Config(),Configure EXTI_Line15_10 (connected to PC.13 pin) in interrupt mode
HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),Toggle LED1 on EXTI interrupt for GPIO_PIN_13
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.HSIState = RCC_HSI_OFF; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9;,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive(),Activate the OverDrive to reach the 216 MHz Frequency
__HAL_RCC_GPIOC_CLK_ENABLE(),Enable GPIOC clock
"GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Pin = GPIO_PIN_13; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);",Configure PC.13 pin as input floating
"HAL_NVIC_SetPriority(EXTI15_10_IRQn, 2, 0); HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);",Enable and set EXTI line 15_10 Interrupt to the lowest priority
SCB_EnableICache(),Enable I-Cache
SCB_EnableDCache(),Enable D-Cache
HAL_Init(),Initialize the HAL Library
SystemClock_Config(),Configure the System Clock
setTime((RTC_YEAR-1970)*365*24*60*60 + RTC_MONTH*30*24*60*60 + RTC_DAY*24*60*60),Set system time based on RTC values
benchmark_test(arg),Run cryptographic benchmark test
main_NVM(),Initialize Non-Volatile Memory operations
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;,Configure peripheral clocks for USART2 and I2C1
coap_basic_thread(),Start CoAP protocol thread
tos_task_delay(1000),Delay task execution for 1000ms
static void DelayLoop( volatile uint32_t nCount ) { volatile uint32_t index = 0; for( index = ( 5000 * nCount ); index != 0; index-- ) { } },Delay function
USBD_Start( &USBD_Device );,Start Device Process
uwRet = LOS_KernelInit();,Initialize LiteOS kernel
(void)LOS_Start();,Start LiteOS scheduler
"LCD1602_Begin4BIT(RS_GPIO_Port, RS_Pin, E_Pin, D4_GPIO_Port, D4_Pin, D5_Pin, D6_Pin, D7_Pin); LCD1602_clear(); LCD1602_print(""I'm hungry!!""); LCD1602_2ndLine(); LCD1602_print(""I wanna go home!"");",Initialize and display text on LCD1602
for (; i <= 2000; i += 50) { htim2.Instance->CCR1 = i; HAL_Delay(100); },Increase PWM duty cycle
"void ledSet() { HAL_GPIO_WritePin(LED_BLUE_GPIO_Port, LED_BLUE_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin, GPIO_PIN_SET); HAL_GPIO_WritePin(LED_RED_GPIO_Port, LED_RED_Pin, GPIO_PIN_SET); }",Initialize the LEDs
"void CALENDAR_Init( CALENDAR_InfoStruct *pInfoStruct ) { RTC_DateTypeDef sdatestructure; RTC_TimeTypeDef stimestructure; RtcHandle.Instance = RTC; RtcHandle.Init.HourFormat = RTC_HOURFORMAT_24; RtcHandle.Init.AsynchPrediv = RTC_ASYNCH_PREDIV; RtcHandle.Init.SynchPrediv = RTC_SYNCH_PREDIV; RtcHandle.Init.OutPut = RTC_OUTPUT_DISABLE; RtcHandle.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH; RtcHandle.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN; __HAL_RTC_RESET_HANDLE_STATE(&RtcHandle); if (HAL_RTC_Init(&RtcHandle) != HAL_OK) { Error_Handler(); } HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13); if( pInfoStruct != NULL ) { sdatestructure.Year = pInfoStruct->year; sdatestructure.Month = pInfoStruct->month; sdatestructure.Date = pInfoStruct->day; sdatestructure.WeekDay = pInfoStruct->weekday; stimestructure.Hours = pInfoStruct->hours; stimestructure.Minutes = pInfoStruct->minutes; stimestructure.Seconds = pInfoStruct->seconds; stimestructure.SubSeconds = 0; stimestructure.SecondFraction = 0; stimestructure.TimeFormat = RTC_HOURFORMAT12_AM; stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; stimestructure.StoreOperation = RTC_STOREOPERATION_RESET; configure_calendar(&sdatestructure, &stimestructure); } else { if (HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1) != 0x32F2) { sdatestructure.Year = 0x18; sdatestructure.Month = RTC_MONTH_MAY; sdatestructure.Date = 0x12; sdatestructure.WeekDay = RTC_WEEKDAY_SATURDAY; stimestructure.Hours = 0x02; stimestructure.Minutes = 0x00; stimestructure.Seconds = 0x00; stimestructure.SubSeconds = 0; stimestructure.SecondFraction = 0; stimestructure.TimeFormat = RTC_HOURFORMAT12_AM; stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; stimestructure.StoreOperation = RTC_STOREOPERATION_RESET; configure_calendar(&sdatestructure, &stimestructure); } else { if (__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST) != RESET) { HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12); } if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST) != RESET) { HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_13); } __HAL_RCC_CLEAR_RESET_FLAGS(); } } }",Configure the RTC peripheral
"void CALENDAR_setDateTime( CALENDAR_InfoStruct *pInfoStruct ) { RTC_DateTypeDef sdatestructure; RTC_TimeTypeDef stimestructure; sdatestructure.Year = pInfoStruct->year; sdatestructure.Month = pInfoStruct->month; sdatestructure.Date = pInfoStruct->day; sdatestructure.WeekDay = pInfoStruct->weekday; stimestructure.Hours = pInfoStruct->hours; stimestructure.Minutes = pInfoStruct->minutes; stimestructure.Seconds = pInfoStruct->seconds; stimestructure.TimeFormat = RTC_HOURFORMAT12_AM; stimestructure.DayLightSaving = RTC_DAYLIGHTSAVING_NONE; stimestructure.StoreOperation = RTC_STOREOPERATION_RESET; configure_calendar(&sdatestructure, &stimestructure); }",Set date and time for RTC
"void CALENDAR_getDate( char *pDateString ) { RTC_DateTypeDef sdatestructureget; HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN); sprintf((char *)pDateString, ""%2d-%2d-%2d"", sdatestructureget.Date, sdatestructureget.Month, 2000 + sdatestructureget.Year); }",Get the RTC current Date
"void CALENDAR_getTime( char *pTimeString ) { RTC_TimeTypeDef stimestructureget; HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN); sprintf((char *)pTimeString, ""%2d:%2d:%2d"", stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds); }",Get the RTC current Time
"static void configure_calendar( RTC_DateTypeDef *pDateStruct, RTC_TimeTypeDef *pTimeStruct) { if(HAL_RTC_SetDate(&RtcHandle, pDateStruct, RTC_FORMAT_BCD) != HAL_OK) { Error_Handler(); } if (HAL_RTC_SetTime(&RtcHandle, pTimeStruct, RTC_FORMAT_BCD) != HAL_OK) { Error_Handler(); } HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, 0x32F2); }",Configure RTC Calendar
initialise_monitor_handles();,Initialize semihosting for printf
"imu_read(); ax=imu.acc.x*1000; ay=imu.acc.y*1000; az=imu.acc.z*1000; gx=imu.gyr.x*1000; gy=imu.gyr.y*1000; gz=imu.gyr.z*1000; printf(""L'accelerazione lungo x e': %f\n\r"",ax); printf(""L'accelerazione lungo y e': %f\n\r"",ay); printf(""L'accelerazione lungo z e': %f\n\r"",az); printf(""Il rollio     (roll)  e': %f \n\r"",gx); printf(""Il beccheggio (pitch) e': %f \n\r"",gy); printf(""L' imbardata  (yaw)   e': %f \n\r"",gz);",Read and print IMU data
"static int app_collect_task_entry() { Init_E53_SC2(); while (1) { E53_SC2_Read_Data(); printf(""\r\n******************************Temperature      is  %d\r\n"", (int)E53_SC2_Data.Temperature); printf(""\r\n******************************Accel[0]         is  %d\r\n"", (int)E53_SC2_Data.Accel[0]); printf(""\r\n******************************Accel[1]         is  %d\r\n"", (int)E53_SC2_Data.Accel[1]); printf(""\r\n******************************Accel[2]         is  %d\r\n"", (int)E53_SC2_Data.Accel[2]); if( X == 0 && Y == 0 && Z == 0) { X = (int)E53_SC2_Data.Accel[0]; Y = (int)E53_SC2_Data.Accel[1]; Z = (int)E53_SC2_Data.Accel[2]; } else { if(X+100<E53_SC2_Data.Accel[0]||X-100>E53_SC2_Data.Accel[0]||Y+100<E53_SC2_Data.Accel[1]||Y-100>E53_SC2_Data.Accel[1]||Z+100<E53_SC2_Data.Accel[2]||Z-100>E53_SC2_Data.Accel[2]) { HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9,GPIO_PIN_RESET); Manhole_Cover.Status[0] = ' '; Manhole_Cover.Status[1] = 'T'; Manhole_Cover.Status[2] = 'i'; Manhole_Cover.Status[3] = 'l'; Manhole_Cover.Status[4] = 't'; } else { HAL_GPIO_WritePin(GPIOB,GPIO_PIN_8,GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB,GPIO_PIN_9,GPIO_PIN_SET); Manhole_Cover.Status[0] = 'L'; Manhole_Cover.Status[1] = 'e'; Manhole_Cover.Status[2] = 'v'; Manhole_Cover.Status[3] = 'e'; Manhole_Cover.Status[4] = 'l'; } } LCD_ShowString(10, 135, 200, 16, 16, ""Temperature:""); LCD_ShowNum(140, 135, (int)E53_SC2_Data.Temperature, 5, 16); LCD_ShowString(10, 160, 200, 16, 16, ""Acce_X:""); LCD_ShowNum(140, 160, (int)E53_SC2_Data.Accel[0], 5, 16); LCD_ShowString(10, 185, 200, 16, 16, ""Acce_Y:""); LCD_ShowNum(140, 185, (int)E53_SC2_Data.Accel[1], 5, 16); LCD_ShowString(10, 210, 200, 16, 16, ""Acce_Z:""); LCD_ShowNum(140, 210, (int)E53_SC2_Data.Accel[2], 5, 16); osal_task_sleep(2*1000); } return 0; }",Task to collect and display sensor data
uartInit(),Initialize UART module
"uartOpen(uint8_t ch, uint32_t baud)",Open UART channel with specified baud rate
uartClose(uint8_t ch),Close UART channel
uartRead(uint8_t ch),Read a single byte from UART receive buffer
"uartWrite(uint8_t ch, uint8_t *p_data, uint32_t length)",Write data to UART transmit buffer
"uartPrintf(uint8_t ch, char *fmt, ...)",Write formatted string to UART
uartGetBaud(uint8_t ch),Get baud rate of UART channel
HAL_UART_MspInit(UART_HandleTypeDef* uartHandle),Initialize UART MSP (MCU Support Package)
HAL_Init(),"Reset of all peripherals, Initializes the Flash interface and the Systick"
StateMachineHandle(),Handle state machine operations
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PREDIV = RCC_PREDIV_DIV1;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
HAL_Init(),"Configure the Flash prefetch, instruction and Data caches, Systick timer, Set NVIC Group Priority to 4, Low Level Initialization"
SystemClock_Config(),Configure the system clock to 180 MHz
"Fill_Buffer(aTable, 1024, 0)",Fill the buffer in the SRAM device
HAL_PWREx_EnableOverDrive(),Activate the OverDrive to reach the 180 MHz Frequency
MX_GPIO_Init(),Initialize GPIO pins
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET);",Ensure all LEDs start off
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_RESET); HAL_Delay(DT_D1); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15, GPIO_PIN_SET); HAL_Delay(DT_D1);",Blink LED D1 with specified delay
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET); HAL_Delay(DT_D2); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET); HAL_Delay(DT_D2);",Blink LED D2 with specified delay
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_RESET); HAL_Delay(DT_D3); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, GPIO_PIN_SET); HAL_Delay(DT_D3);",Blink LED D3 with specified delay
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_RESET); HAL_Delay(DT_D4); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, GPIO_PIN_SET); HAL_Delay(DT_D4);",Blink LED D4 with specified delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : PB12 PB13 PB14 PB15
MX_USART1_UART_Init(),Initialize USART1 for UART communication
MX_USB_OTG_FS_HCD_Init(),Initialize USB OTG FS as host controller
vsf_core_init(),Initialize core system clock for VSF framework
vsf_uart_init(),Initialize UART and transmit test data
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
"HAL_UART_Transmit(&huart1, test, sizeof(test), 1000)",Transmit test data over UART
BSP_LED_Init(LED3),Configure LED3
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI)",Configure BUTTON_USER
HAL_Delay(500); BSP_LED_Toggle(LED3);,Toggle LED3 every 500ms
HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),"Handle EXTI interrupt for user button, suspend or resume tick"
HAL_SuspendTick(),Suspend tick increment
HAL_ResumeTick(),Resume tick increment
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV2; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
MX_GPIO_Init(); MX_USART1_UART_Init();,Initialize GPIO and USART1 peripherals
Luos_Init(); Button_Init();,Initialize Luos framework and button module
Luos_Loop(); Button_Loop();,Run Luos and button handling loops
for (i = 0; i < 48; i++) { VectorTable[i] = *(__IO uint32_t *)(0x0800C800 + (i << 2)); },Copy the vector table from Flash to SRAM
__HAL_RCC_SYSCFG_CLK_ENABLE(); __HAL_SYSCFG_REMAPMEMORY_SRAM();,Enable SYSCFG peripheral clock and remap SRAM to 0x00000000
MX_FREERTOS_Init(),Initialize FreeRTOS
StartDefaultTask(void const * argument),Implement the default task thread for UDP data loopback test
"HAL_GPIO_TogglePin(LED0_GPIO_Port, LED0_Pin)",Toggle LED0 pin
osDelay(200),Delay task execution for 200ms in default task
osDelay(300),Delay task execution for 300ms in second task
"osThreadDef(defaultTask, StartDefaultTask, osPriorityNormal, 0, 4096); defaultTaskHandle = osThreadCreate(osThread(defaultTask), NULL);",Define and create default task thread
"osThreadDef(myTask02, StartTask02, osPriorityIdle, 0, 2048); myTask02Handle = osThreadCreate(osThread(myTask02), NULL);",Define and create second task thread
MX_MEMS_Init(),Initialize the peripherals and the MEMS components
MX_MEMS_Process(),Run MEMS background task
MX_IKS01A3_LIS2DW12_6DOrientation_Init(),Initialize the LIS2DW12 6D Orientation application
MX_IKS01A3_LIS2DW12_6DOrientation_Process(),Process the LIS2DW12 6D Orientation application
BSP_LED_Init(LED2),Initialize LED2
"IKS01A3_MOTION_SENSOR_Init(IKS01A3_LIS2DW12_0, MOTION_ACCELERO)",Initialize LIS2DW12 accelerometer
"IKS01A3_MOTION_SENSOR_Enable_6D_Orientation(IKS01A3_LIS2DW12_0, IKS01A3_MOTION_SENSOR_INT1_PIN)",Enable 6D orientation detection on LIS2DW12
set_mems_int_pin_a_exti(),Set EXTI settings for Interrupt A
Send_Orientation(),Send actual 6D orientation to UART
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;,Configure peripheral clock for USART1
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1),Configure the main internal regulator output voltage
"void gpioPinWrite(uint8_t ch, bool value) { if (ch >= GPIO_MAX_CH) { return; } if (value) { HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].on_state); } else { HAL_GPIO_WritePin(gpio_tbl[ch].port, gpio_tbl[ch].pin, gpio_tbl[ch].off_state); } }",Write to GPIO pin
"void cliGpio(cli_args_t *args) { bool ret = false; if (args->argc == 1 && args->isStr(0, ""show"") == true) { while(cliKeepLoop()) { for (int i=0; i<GPIO_MAX_CH; i++) { cliPrintf(""%d"", gpioPinRead(i)); } cliPrintf(""\n""); delay(100); } ret = true; } if (args->argc == 2 && args->isStr(0, ""read"") == true) { uint8_t ch; ch = (uint8_t)args->getData(1); while(cliKeepLoop()) { cliPrintf(""gpio read %d : %d\n"", ch, gpioPinRead(ch)); delay(100); } ret = true; } if (args->argc == 3 && args->isStr(0, ""write"") == true) { uint8_t ch; uint8_t data; ch = (uint8_t)args->getData(1); data = (uint8_t)args->getData(2); gpioPinWrite(ch, data); cliPrintf(""gpio write %d : %d\n"", ch, data); ret = true; } if (ret != true) { cliPrintf(""gpio show\n""); cliPrintf(""gpio read ch[0~%d]\n"", GPIO_MAX_CH-1); cliPrintf(""gpio write ch[0~%d] 0:1\n"", GPIO_MAX_CH-1); } }",Command-line interface for GPIO control
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },Increment tick counter on TIM6 interrupt
"static void init_filesystem (void) { int32_t retv; retv = finit (""M0:""); if (retv == fsOK) { retv = fmount (""M0:""); if (retv == fsOK) { printf (""Drive M0 ready!\n""); } else { printf (""Drive M0 mount failed(%d)!\n"", retv); } } else { printf (""Drive M0 initialization failed!\n""); } }",Initialize a Flash Memory Card
void net_loop(void const *arg) { while(1) { net_main (); osThreadYield (); } },Network main loop thread
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef* htim) { if (htim->Instance == TIM1) { HAL_IncTick(); } else { CUSTOM_TIM_PeriodElapsedCallback(htim); } },Handle TIM1 interrupt for tick increment and custom timer callback
"void toggle(GPIO_TypeDef*  GPIOx, uint16_t GPIO_Pin, uint32_t frequency, int duration) { TickType_t start = xTaskGetTickCount(); do { HAL_GPIO_TogglePin(GPIOx, GPIO_Pin); HAL_Delay(frequency); } while((xTaskGetTickCount() - start) <= duration); }",Toggle GPIO pin at specified frequency for a duration
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM1) { HAL_IncTick(); } },Increment tick counter on TIM1 interrupt
"static void MX_TIM1_Init(void) { TIM_ClockConfigTypeDef sClockSourceConfig = {0}; TIM_SlaveConfigTypeDef sSlaveConfig = {0}; TIM_MasterConfigTypeDef sMasterConfig = {0}; htim1.Instance = TIM1; htim1.Init.Prescaler = 639; htim1.Init.CounterMode = TIM_COUNTERMODE_UP; htim1.Init.Period = 19; htim1.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim1.Init.RepetitionCounter = 0; htim1.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_Base_Init(&htim1) != HAL_OK) { Error_Handler(); } sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL; if (HAL_TIM_ConfigClockSource(&htim1, &sClockSourceConfig) != HAL_OK) { Error_Handler(); } if (HAL_TIM_Base_Start_IT(&htim1) != HAL_OK) { Error_Handler(); } }",TIM1 Initialization Function
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { STEPPER_CONTROLS_handler_5kHz(); counter_a++; if (counter_a>5000) { counter_a=0; } },Handle TIM1 interrupt for 5kHz stepper control
"static int btstack_uart_block_stm32_hal_init(const btstack_uart_config_t *config) { const pbdrv_bluetooth_btstack_uart_block_stm32_platform_data_t *pdata = &pbdrv_bluetooth_btstack_uart_block_stm32_platform_data; uart_config = config; btstack_tx_hdma.Instance = pdata->tx_dma; btstack_tx_hdma.Init.Channel = pdata->tx_dma_ch; btstack_tx_hdma.Init.Direction = DMA_MEMORY_TO_PERIPH; btstack_tx_hdma.Init.PeriphInc = DMA_PINC_DISABLE; btstack_tx_hdma.Init.MemInc = DMA_MINC_ENABLE; btstack_tx_hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; btstack_tx_hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; btstack_tx_hdma.Init.Mode = DMA_NORMAL; btstack_tx_hdma.Init.Priority = DMA_PRIORITY_VERY_HIGH; btstack_tx_hdma.Init.FIFOMode = DMA_FIFOMODE_DISABLE; btstack_tx_hdma.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL; btstack_tx_hdma.Init.MemBurst = DMA_MBURST_SINGLE; btstack_tx_hdma.Init.PeriphBurst = DMA_PBURST_SINGLE; HAL_DMA_Init(&btstack_tx_hdma); btstack_rx_hdma.Instance = pdata->rx_dma; btstack_rx_hdma.Init.Channel = pdata->rx_dma_ch; btstack_rx_hdma.Init.Direction = DMA_PERIPH_TO_MEMORY; btstack_rx_hdma.Init.PeriphInc = DMA_PINC_DISABLE; btstack_rx_hdma.Init.MemInc = DMA_MINC_ENABLE; btstack_rx_hdma.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE; btstack_rx_hdma.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE; btstack_rx_hdma.Init.Mode = DMA_NORMAL; btstack_rx_hdma.Init.Priority = DMA_PRIORITY_VERY_HIGH; btstack_rx_hdma.Init.FIFOMode = DMA_FIFOMODE_DISABLE; btstack_rx_hdma.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_1QUARTERFULL; btstack_rx_hdma.Init.MemBurst = DMA_MBURST_SINGLE; btstack_rx_hdma.Init.PeriphBurst = DMA_PBURST_SINGLE; HAL_DMA_Init(&btstack_rx_hdma); btstack_huart.Instance = pdata->uart; btstack_huart.Init.BaudRate = config->baudrate; btstack_huart.Init.WordLength = UART_WORDLENGTH_8B; btstack_huart.Init.StopBits = UART_STOPBITS_1; btstack_huart.Init.Parity = UART_PARITY_NONE; btstack_huart.Init.Mode = UART_MODE_TX_RX; btstack_huart.Init.HwFlowCtl = config->flowcontrol ? UART_HWCONTROL_RTS_CTS : UART_HWCONTROL_NONE; btstack_huart.Init.OverSampling = UART_OVERSAMPLING_16; HAL_UART_Init(&btstack_huart); __HAL_LINKDMA(&btstack_huart, hdmatx, btstack_tx_hdma); __HAL_LINKDMA(&btstack_huart, hdmarx, btstack_rx_hdma); HAL_NVIC_SetPriority(pdata->tx_dma_irq, 1, 2); HAL_NVIC_EnableIRQ(pdata->tx_dma_irq); HAL_NVIC_SetPriority(pdata->rx_dma_irq, 1, 1); HAL_NVIC_EnableIRQ(pdata->rx_dma_irq); HAL_NVIC_SetPriority(pdata->uart_irq, 1, 0); HAL_NVIC_EnableIRQ(pdata->uart_irq); return 0; }",Initialize UART with DMA for BTStack
"static void btstack_uart_block_stm32_hal_process(btstack_data_source_t *ds, btstack_data_source_callback_type_t callback_type) { switch (callback_type) { case DATA_SOURCE_CALLBACK_POLL: if (send_complete) { send_complete = false; if (block_sent) { block_sent(); } } if (receive_complete) { receive_complete = false; if (block_received) { block_received(); } } break; default: break; } }",Process UART send/receive callbacks for BTStack
"static int btstack_uart_block_stm32_hal_set_baudrate(uint32_t baud) { USART_TypeDef *usart = btstack_huart.Instance; uint32_t periphclk = LL_RCC_PERIPH_FREQUENCY_NO; LL_RCC_ClocksTypeDef rcc_clocks; LL_RCC_GetSystemClocksFreq(&rcc_clocks); if (usart == USART1 #if defined(USART6) || usart == USART6 #endif #if defined(UART9) || usart == UART9 #endif #if defined(UART10) || usart == UART10 #endif ) { periphclk = rcc_clocks.PCLK2_Frequency; } else { periphclk = rcc_clocks.PCLK1_Frequency; } LL_USART_SetBaudRate(usart, periphclk, LL_USART_OVERSAMPLING_16, baud); return 0; }",Set UART baud rate for BTStack
"static int btstack_uart_block_stm32_hal_open(void) { btstack_uart_block_stm32_hal_set_baudrate(uart_config->baudrate); btstack_run_loop_set_data_source_handler(&transport_data_source, &btstack_uart_block_stm32_hal_process); btstack_run_loop_enable_data_source_callbacks(&transport_data_source, DATA_SOURCE_CALLBACK_POLL); btstack_run_loop_add_data_source(&transport_data_source); return 0; }",Open UART for BTStack communication
"static int btstack_uart_block_stm32_hal_close(void) { btstack_run_loop_disable_data_source_callbacks(&transport_data_source, DATA_SOURCE_CALLBACK_POLL); btstack_run_loop_remove_data_source(&transport_data_source); return 0; }",Close UART for BTStack communication
static void btstack_uart_block_stm32_hal_set_block_received(void (*handler)(void)) { block_received = handler; },Set callback for UART block received
static void btstack_uart_block_stm32_hal_set_block_sent(void (*handler)(void)) { block_sent = handler; },Set callback for UART block sent
"static void btstack_uart_block_stm32_hal_receive_block(uint8_t *buffer, uint16_t len) { HAL_UART_Receive_DMA(&btstack_huart, buffer, len); }",Receive UART block using DMA
"static void btstack_uart_block_stm32_hal_send_block(const uint8_t *data, uint16_t size) { HAL_UART_Transmit_DMA(&btstack_huart, (uint8_t *)data, size); }",Send UART block using DMA
"void fram_init() { if (HAL_I2C_GetState(&hi2c1) == HAL_I2C_STATE_RESET) { oprintf(""I2C1 must be initialised. \r\n""); } if(resetFlag == 0) system_init(); memset(&status, 0x00, sizeof(fram_sys)); #if FRAM_CLEAR_ON_INIT == 1 memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); #endif memError |= !fram_read_private(0, 0, &status, sizeof(fram_sys)); if(!status.flags.intialized) { status.flags.intialized = 1; memcpy(&(status.name), MODULE_NAME, strlen(MODULE_NAME)); memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); memset(&status, 0x00, sizeof(fram_sys)); } memError |= !fram_read_private(0, 0, &status, sizeof(fram_sys)); status.totalReset_cycles++; switch(getResetFlag()) { case RCC_FLAG_BORRST: status.borResets++; break; case RCC_FLAG_PINRST: status.pinResets++; break; case RCC_FLAG_PORRST: status.porResets++; break; case RCC_FLAG_SFTRST: status.softwareResets++; break; case RCC_FLAG_IWDGRST: status.independendWatchdogResets++; break; case RCC_FLAG_WWDGRST: status.windowedWatchdogResets++; break; case RCC_FLAG_LPWRRST: status.lowPowerResets++; break; default: break; } memError |= !fram_write_private(0, 0, &status, sizeof(fram_sys)); }",Initialize FRAM and system status
static uint8_t getI2CAddress(uint8_t page) { return ((MEM_ADDRESS << 3) | (page & 0x07)) << 1; },Calculate I2C address for FRAM page
fram_sys* fram_getSystemStatus() { return &status; },Get FRAM system status
void system_init() { if(__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST)) resetFlag = RCC_FLAG_BORRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST)) resetFlag = RCC_FLAG_PINRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_PORRST)) resetFlag = RCC_FLAG_PORRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST)) resetFlag = RCC_FLAG_SFTRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST)) resetFlag = RCC_FLAG_IWDGRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST)) resetFlag = RCC_FLAG_WWDGRST; else if(__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST)) resetFlag = RCC_FLAG_LPWRRST; else resetFlag = 0; __HAL_RCC_CLEAR_RESET_FLAGS(); },Initialize system and check reset flags
"int getSystemID(char* buffer, uint32_t bufferSize) { if(bufferSize < SYSTEM_ID_STRING_SIZE) { return 0; } return sprintf(buffer,""%s: %lX%lX%lX"",SYSTEM_NAME,STM32_UUID[0],STM32_UUID[1],STM32_UUID[2]); }",Get system ID string
uint8_t getResetFlag() { return resetFlag; },Get reset flag
"PUTCHAR_PROTOTYPE {	HAL_UART_Transmit((UART_HandleTypeDef *)&huart1, (uint8_t*)&ch, 1, 0xFFFF);	return ch;}",Serial output for Debug @ HUART1
"int GPS_decode (void) {	HAL_UART_Receive(&huart2, gps_uart, sizeof(gps_uart), GPS_Delay_Time);	#ifdef SerialGPSdebug		#endif	NMEA_GPGGA_Analysis (&NMEAmsg, (uint8_t*) gps_uart);	if (!NMEAmsg.gpssta) {		LED_GPSRFS_ON();		#ifdef SerialDebug			printf(""** GPS NO SIGNAL **\r\n"");		#endif		return 1;	} else {		LED_GPSRFS_ON();		NMEA_GPRMC_Analysis (&NMEAmsg, (uint8_t*) gps_uart);		NMEA_GPGSA_Analysis (&NMEAmsg, (uint8_t*) gps_uart);		NMEA_GPVTG_Analysis (&NMEAmsg, (uint8_t*) gps_uart);		NMEA_GPRMC_Analysis (&NMEAmsg, (uint8_t*) gps_uart);		NMEA_GPS_DATA_PHRASE(&NMEAmsg, &NMEAdata);		DP.latitude  = NMEAdata.latitude;		DP.longitude = NMEAdata.longitude;		DP.speed     = NMEAdata.speed;		DP.pdop      = NMEAdata.pdop;		#ifdef SerialGPSDebug			printf(""\r\n** GPS Serial Debug **\r\n"");			printf(""GPS status: %s, PDOT: %f\r\n"", NMEAmsg.gpssta^2? ""3D"":""2D"", NMEAdata.pdop);			printf(""UTC time: %02d:%02d:%02d\r\n"", NMEAmsg.utc.hour, NMEAmsg.utc.min, NMEAmsg.utc.sec);			printf(""Lat: %.6f, Log: %.6f, Spd: %.6f\r\n"", NMEAdata.latitude, NMEAdata.longitude, NMEAdata.speed);		#endif		LED_GPSRFS_OFF();		return 0;	}}",GPS decoder
"static void MX_I2C1_Init(void) {	hi2c1.Instance = I2C1;	hi2c1.Init.ClockSpeed = 400000;	hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;	hi2c1.Init.OwnAddress1 = 0;	hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;	hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;	hi2c1.Init.OwnAddress2 = 0;	hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;	hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;	if (HAL_I2C_Init(&hi2c1) != HAL_OK) {		Error_Handler();	}}",I2C1 Initialization Function
"static void MX_USART1_UART_Init(void) {	huart1.Instance = USART1;	huart1.Init.BaudRate = 115200;	huart1.Init.WordLength = UART_WORDLENGTH_8B;	huart1.Init.StopBits = UART_STOPBITS_1;	huart1.Init.Parity = UART_PARITY_NONE;	huart1.Init.Mode = UART_MODE_TX_RX;	huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;	huart1.Init.OverSampling = UART_OVERSAMPLING_16;	if (HAL_UART_Init(&huart1) != HAL_OK)	{		Error_Handler();	}}",USART1 Initialization Function
"static void MX_USART2_UART_Init(void) {	huart2.Instance = USART2;	huart2.Init.BaudRate = 9600;	huart2.Init.WordLength = UART_WORDLENGTH_8B;	huart2.Init.StopBits = UART_STOPBITS_1;	huart2.Init.Parity = UART_PARITY_NONE;	huart2.Init.Mode = UART_MODE_TX_RX;	huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;	huart2.Init.OverSampling = UART_OVERSAMPLING_16;	if (HAL_UART_Init(&huart2) != HAL_OK) {		Error_Handler();	}}",USART2 Initialization Function
"static void MX_USART6_UART_Init(void) {	huart6.Instance = USART6;	huart6.Init.BaudRate = 115200;	huart6.Init.WordLength = UART_WORDLENGTH_8B;	huart6.Init.StopBits = UART_STOPBITS_1;	huart6.Init.Parity = UART_PARITY_NONE;	huart6.Init.Mode = UART_MODE_TX_RX;	huart6.Init.HwFlowCtl = UART_HWCONTROL_NONE;	huart6.Init.OverSampling = UART_OVERSAMPLING_16;	if (HAL_UART_Init(&huart6) != HAL_OK) {		Error_Handler();	}}",USART6 Initialization Function
"static void MX_GPIO_Init(void) {	/* GPIO Ports Clock Enable */	__HAL_RCC_GPIOA_CLK_ENABLE();	__HAL_RCC_GPIOB_CLK_ENABLE();}",GPIO Initialization Function
#define SEND_STEP_COUNT_TIMEOUT  3000U,Send step count to UART after this timeout [ms].
"void MX_MEMS_Init(void) {	MX_IKS01A3_LSM6DSO_Pedometer_Init();}",Initialize the peripherals and the MEMS components
"void BSP_PB_Callback(Button_TypeDef Button) {	PushButtonDetected = 1;}",BSP Push Button callback
"static uint32_t user_currentTimeGetElapsedMS(uint32_t Tick1) {	uint32_t delta;	uint32_t tick2;	tick2 = HAL_GetTick();	delta = tick2 - Tick1;	return delta;}",Provides a SysTick time elapsed from 'Tick1' start value in milliseconds
#if (SWO_OUTPUT == TRUE)    SwoInit();#endif,init SWO as soon as possible to make it available to output ASAP
if (CheckValidCLRImage((uint32_t)&__nanoImage_end__)) {        LaunchCLR((uint32_t)&__nanoImage_end__);},check for valid CLR image
"sduObjectInit(&SERIAL_DRIVER);    sduStart(&SERIAL_DRIVER, &serusbcfg);",Initializes a serial-over-USB CDC driver.
"usbDisconnectBus(serusbcfg.usbp);    chThdSleepMilliseconds(100);    usbStart(serusbcfg.usbp, &usbcfg);    usbConnectBus(serusbcfg.usbp);","Activates the USB driver and then the USB bus pull-up on D+. Note, a delay is inserted in order to not have to disconnect the cable after a reset."
BlockStorageList_Initialize();    BlockStorage_AddDevices();,initialize block storage list and devices
BSP_LED_Init(LED1);    BSP_LED_Init(LED2);    BSP_LED_Init(LED3);,"Configure LED1, LED2 and LED3"
"BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_GPIO);",Configure User push-button (B1) button
while (BSP_PB_GetState(BUTTON_SW1) != GPIO_PIN_RESET) {    BSP_LED_Toggle(LED1);    HAL_Delay(100);}    BSP_LED_Off(LED1);,Wait for User push-button (B1) press before starting the Communication
static void MX_SPI1_Init(void) {  hspi1.Instance = SPI1;  hspi1.Init.Mode = SPI_MODE_MASTER;  hspi1.Init.Direction = SPI_DIRECTION_2LINES;  hspi1.Init.DataSize = SPI_DATASIZE_8BIT;  hspi1.Init.CLKPolarity = SPI_POLARITY_LOW;  hspi1.Init.CLKPhase = SPI_PHASE_1EDGE;  hspi1.Init.NSS = SPI_NSS_SOFT;  hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_256;  hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB;  hspi1.Init.TIMode = SPI_TIMODE_DISABLE;  hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;  hspi1.Init.CRCPolynomial = 7;  hspi1.Init.CRCLength = SPI_CRC_LENGTH_DATASIZE;  hspi1.Init.NSSPMode = SPI_NSS_PULSE_DISABLE;  if (HAL_SPI_Init(&hspi1) != HAL_OK)  {    Error_Handler();  }},SPI1 Initialization Function
static void MX_GPIO_Init(void) {  /* GPIO Ports Clock Enable */  __HAL_RCC_GPIOA_CLK_ENABLE();},GPIO Initialization Function
static void Timeout_Error_Handler(void) {  while (1)  {    BSP_LED_On(LED3);    HAL_Delay(500);    BSP_LED_Off(LED3);    HAL_Delay(500);  }},This function is executed in case of error occurrence.
"static uint16_t Buffercmp(uint8_t *pBuffer1, uint8_t *pBuffer2, uint16_t BufferLength) {  while (BufferLength--)  {    if ((*pBuffer1) != *pBuffer2)    {      return BufferLength;    }    pBuffer1++;    pBuffer2++;  }  return 0;}",Compares two buffers.
void Error_Handler(void) {  BSP_LED_On(LED3);  while (1)  {  }},This function is executed in case of error occurrence.
"void Error_Handler(uint16_t error_code) {	switch (error_code) {	case RCC_CONFIG_FAIL: 		printf(""ERROR: Error in initialising System Clocks \n"");		break;	case TIM_INIT_FAIL: 		printf(""ERROR: Error in initialising Timer base \n"");		break;	case ADC_INIT_FAIL: 		printf(""ERROR: Error in initialising ADC \n"");		break;	case ADC_CH_CONFIG_FAIL: 		printf(""ERROR: Error in initialising ADC Channel Configuration \n"");		break;	case ADC_MULTIMODE_FAIL: 		printf(""ERROR: Error in initialising ADC Multimode\\DMA \n"");		break;	case EXTI_SPI1_FAIL: 		printf(""ERROR: Error in initialising SPI1 \n"");		break;	default: printf(""ERROR: AN ERROR OCCURED \n"");		break;	}}",A function used to relay information (PRINTF) that a specific error has occured and gets the system into infinite loop. User can modify the output error message
"HAL_UART_Receive_IT(&huart1, (uint8_t *)&aRxBuffer, 1);",wakeup uart receive intr
"void StartDefaultTask(void const * argument) {	  sdio_err_t err;	  UartBinarySemHandle = xSemaphoreCreateBinary();    SDIO_LOGI(TAG, ""host ready, start initializing slave..."");	    err = sdio_host_init();    if(err != SDIO_SUCCESS){			printf(""SDIO init error\r\n"");		}		printf(""Sdio init done\r\n"");		HAL_GPIO_WritePin(GPIOB, GPIO_PIN_5, GPIO_PIN_SET);#if (TARGET_ESP32 == 0)    SDIO_LOGI(TAG, ""********** Guide ESP8266 BOOT ***********"");    err = esp_download_fw();    SDIO_ERROR_CHECK(err);#endif	  xTaskCreate(sdio_recv_task, ""sdioRecvTask"", 128, NULL, 5, NULL);		xSemaphoreTake(UartBinarySemHandle,0);	  HAL_UART_Receive_IT(&huart1, (uint8_t *)&aRxBuffer, 1);  for(;;)  {		xSemaphoreTake(UartBinarySemHandle,portMAX_DELAY);				SDIO_LOGD(TAG, ""UART len: %d"", Uart1_Rx_Cnt_Backup);		RxBufferBackup[Uart1_Rx_Cnt_Backup] = '\0';		SDIO_LOGD(TAG, ""UART DATA: %s"", RxBufferBackup);				err = sdio_host_send_packet(RxBufferBackup, Uart1_Rx_Cnt_Backup);		if (err == ERR_TIMEOUT) {				SDIO_LOGW(TAG, ""send timeout"");		}  }	vTaskDelete(NULL);}",Function implementing the defaultTask thread.
static void MX_USART1_UART_Init(void) {  huart1.Instance = USSR1;  huart1.Init.BaudRate = 115200;  huart1.Init.WordLength = UART_WORDLENGTH_8B;  huart1.Init.StopBits = UART_STOPBITS_1;  huart1.Init.Parity = UART_PARITY_NONE;  huart1.Init.Mode = UART_MODE_TX_RX;  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart1.Init.OverSampling = UART_OVERSAMPLING_16;  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;  if (HAL_UART_Init(&huart1) != HAL_OK)  {    Error_Handler();  }},USART1 Initialization Function
"static void MX_DMA_Init(void) {  __HAL_RCC_DMA1_CLK_ENABLE();  HAL_NVIC_SetPriority(DMA1_Channel2_3_IRQn, 0, 0);  HAL_NVIC_EnableIRQ(DMA1_Channel2_3_IRQn);}",Enable DMA controller clock
"while (1) {		if(readFlag){			bufferSize = sprintf(WriteBuffer,""www.makingfun.xyz -> [%d]\r\n"",count);			printf(""Send: %s"",WriteBuffer);			AT24CXX_WriteData(&hi2c1,AT24CXX_ADDRESS,(uint8_t *)WriteBuffer,bufferSize);			WriteFlag = 1;			readFlag = 0;			count++;		}		if(WriteFlag){			AT24CXX_ReadData(&hi2c1,AT24CXX_ADDRESS,(uint8_t *)ReadBuffer,bufferSize);			printf(""Recv: %s"",ReadBuffer);			WriteFlag = 0;			readFlag = 1;		}		HAL_Delay(2000);}",Infinite loop
"sduObjectInit(&SDU1);  sduStart(&SDU1, &serusbcfg);",Initializes a serial-over-USB CDC driver.
"usbDisconnectBus(serusbcfg.usbp);  chThdSleepMilliseconds(100);  usbStart(serusbcfg.usbp, &usbcfg);  usbConnectBus(serusbcfg.usbp);","Activates the USB driver and then the USB bus pull-up on D+. Note, a delay is inserted in order to not have to disconnect the cable after a reset."
BlockStorageList_Initialize();  BlockStorage_AddDevices();,initialize block storage list and devices
"bool initRadio() {    uint8_t initOK = false;    HAL_RCC_MCOConfig(RCC_MCO, RCC_MCO1SOURCE_HSE, RCC_MCODIV_1);    if (SPIInit())    {        if ((initOK = initNRF24L01P()))        {            if (DEBUG_ENABLED())                debug_printf(""RF successfully initialized, configuring...\n"");            initOK &= setChannel(RADIO_CHANNEL);            initOK &= setAutoAck(true);            initOK &= setDataRate(RF24_2MBPS);            initOK &= enableAckPayload();            if (DEBUG_ENABLED() && initOK)            {                debug_printf(""RF Configuration OK!\n"");                printDetails();            }            resetCommunicationWatchdog();            setRobotId(ROBOT_ID);            openReadingPipe(0, DEFAULT_ADDRESS);            openWritingPipe(DEFAULT_ADDRESS);            startListening();            setRobotPipeAddress(DEFAULT_ADDRESS + 12 + ROBOT_ID * 3);            openCommunication();            startListening();            isRadioInitialized = true;        }    }    return initOK;}","initializes the Radio, with the SPI communication first and then the NRF24L01+ chip"
"void sendRadioMessage(Message *msg, uint8_t size) {    writeRadio((uint8_t *)msg, size);}",Send a framed message through radio to the current SwarmBots
void resetCommunicationWatchdog() {    communicationWatchdog = COMMUNICATION_TIMEOUT;},resets the communication watchdog counter
void tickCommunicationWatchdog(uint8_t millis) {    if(communicationWatchdog >= millis)      communicationWatchdog -= millis;    else      communicationWatchdog = 0;},decrements the watchdog counter
uint32_t remainingCommunicationWatchdog() {    return communicationWatchdog;},gives the amount of time before the end of the watchdog counter
void setRobotPipeAddress(uint64_t _pipeAddress) {    myPipeAddress = _pipeAddress;},sets the pipe address to the value in parameter
void setRobotId(uint8_t _id) {      myId = _id;},sets the id to the value in parameter
uint64_t getRobotPipeAddress() {    return myPipeAddress;},return the current pipe address
uint8_t getRobotId() {      return myId;},return the current Id
"void openCommunication() {    openWritingPipe(myPipeAddress);    openReadingPipe(0, myPipeAddress);}",opens the writing and reading pipe for the given robot
"void application_entry(void *arg) {    extern void mqtt_basic_thread(void);#ifdef USE_LWIP    dns_init();    MX_LWIP_Init();#endif#ifdef USE_ESP8266    extern int esp8266_sal_init(hal_uart_port_t uart_port);    extern int esp8266_join_ap(const char *ssid, const char *pwd);    esp8266_sal_init(HAL_UART_PORT_0);    esp8266_join_ap(""SheldonDai"", ""srnr6x9xbhmb0"");#endif#ifdef USE_NB_BC35    extern int bc35_28_95_sal_init(hal_uart_port_t uart_port);    bc35_28_95_sal_init(HAL_UART_PORT_0);#endif    coap_basic_thread();    while (1) {        printf(""This is a coap demo!\r\n"");        tos_task_delay(1000);    }}",Application entry point for communication setup and CoAP demo
void BOOT_Init(void) {    RTC_Time_s currTime;    RTC_Date_s currDate;    main_state.CSR = MCU_SystemResetStatus_Init();    RTC_getTime(&currTime);    RTC_getDate(&currDate);    main_state.boot_rtcdate = currDate;    main_state.boot_rtctime = currTime;    main_state.resetcounter++;    MCU_GetDeviceID(&mcu_unique_deviceID);},"Set boot reset date, time and status"
"void initGPIO() {    GPIO_InitTypeDef GPIO_Config;    GPIO_Config.Mode = GPIO_MODE_AF_PP;    GPIO_Config.Pull = GPIO_NOPULL;    GPIO_Config.Speed = GPIO_SPEED_HIGH;#if defined STM32F1    __GPIOC_CLK_ENABLE();    __AFIO_CLK_ENABLE();    GPIO_Config.Pin = GPIO_PIN_8;    HAL_GPIO_Init(GPIOC, &GPIO_Config);#elif defined STM32F2    __GPIOD_CLK_ENABLE();    GPIO_Config.Alternate = GPIO_AF2_TIM4;    GPIO_Config.Pin = GPIO_PIN_12;    HAL_GPIO_Init(GPIOD, &GPIO_Config);#elif defined STM32F4    __GPIOA_CLK_ENABLE();    GPIO_Config.Alternate = GPIO_AF2_TIM3;    GPIO_Config.Pin = GPIO_PIN_6;    HAL_GPIO_Init(GPIOA, &GPIO_Config);#endif}",Initialize GPIO for different STM32 families
"void initTimers() {    TIM_HandleTypeDef TIM_Handle;#if defined STM32F1    __TIM8_CLK_ENABLE();    TIM_Handle.Instance = TIM8;    TIM_Handle.Init.Prescaler = (uint16_t)(HAL_RCC_GetPCLK2Freq() / 10000) - 1;#elif defined STM32F2    __TIM4_CLK_ENABLE();    TIM_Handle.Instance = TIM4;    TIM_Handle.Init.Prescaler = (uint16_t)(HAL_RCC_GetPCLK2Freq() / 100000) - 1;#elif defined STM32F4    __TIM3_CLK_ENABLE();    TIM_Handle.Instance = TIM3;    TIM_Handle.Init.Prescaler = (uint16_t)(HAL_RCC_GetSysClockFreq() / 10000) - 1;#endif    TIM_Handle.Init.Period = 10000;    TIM_Handle.Init.ClockDivision = 0;    TIM_Handle.Init.CounterMode = TIM_COUNTERMODE_UP;    HAL_TIM_Base_Init(&TIM_Handle);    HAL_TIM_PWM_Init(&TIM_Handle);    TIM_OC_InitTypeDef TIM_OCConfig;    TIM_OCConfig.OCMode = TIM_OCMODE_PWM1;    TIM_OCConfig.Pulse = 4999;    TIM_OCConfig.OCPolarity = TIM_OCPOLARITY_HIGH;    TIM_OCConfig.OCFastMode = TIM_OCFAST_DISABLE;#if defined STM32F1    HAL_TIM_PWM_ConfigChannel(&TIM_Handle, &TIM_OCConfig, TIM_CHANNEL_3);    HAL_TIM_PWM_Start(&TIM_Handle, TIM_CHANNEL_3);#elif defined STM32F2    HAL_TIM_PWM_ConfigChannel(&TIM_Handle, &TIM_OCConfig, TIM_CHANNEL_1);    HAL_TIM_PWM_Start(&TIM_Handle, TIM_CHANNEL_1);#elif defined STM32F4    HAL_TIM_PWM_ConfigChannel(&TIM_Handle, &TIM_OCConfig, TIM_CHANNEL_1);    HAL_TIM_PWM_Start(&TIM_Handle, TIM_CHANNEL_1);#endif}","Initialize timers for PWM output (10 kHz, 50% duty cycle)"
"void initClock(void) {    RCC_ClkInitTypeDef RCC_ClkInitStruct;    RCC_OscInitTypeDef RCC_OscInitStruct;#if defined STM32F1    __HAL_RCC_PWR_CLK_ENABLE();    uint8_t fLatency;    RCC_OscInitStruct.OscillatorType  = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;    RCC_OscInitStruct.LSEState = RCC_LSE_OFF;    RCC_OscInitStruct.HSIState = RCC_HSI_OFF;    RCC_OscInitStruct.HSICalibrationValue = 0;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;# if (defined STM32F100xB) || (defined STM32F100xE)    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL3;    fLatency = FLASH_LATENCY_0;# elif (defined STM32F101x6) || (defined STM32F101xB) || (defined STM32F101xE) || (defined STM32F101xG)    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV2;    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;    fLatency = FLASH_LATENCY_1;# elif (defined STM32F102x6) || (defined STM32F102xB)    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;    fLatency = FLASH_LATENCY_1;# elif (defined STM32F103x6) || (defined STM32F103xB) || (defined STM32F103xE) || (defined STM32F103xG)    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;    fLatency = FLASH_LATENCY_2;# elif (defined STM32F105xC) || (defined STM32F107xC)    RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1;    RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;    fLatency = FLASH_LATENCY_2;# endif    HAL_RCC_OscConfig(&RCC_OscInitStruct);    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, fLatency);#elif defined STM32F2    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;    RCC_OscInitStruct.PLL.PLLM = 25;    RCC_OscInitStruct.PLL.PLLN = 240;    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;    RCC_OscInitStruct.PLL.PLLQ = 5;    HAL_RCC_OscConfig(&RCC_OscInitStruct);    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);#elif defined STM32F4    __HAL_RCC_PWR_CLK_ENABLE();    __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);    RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;    RCC_OscInitStruct.HSEState = RCC_HSE_ON;    RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;    RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;    RCC_OscInitStruct.PLL.PLLM = 8;    RCC_OscInitStruct.PLL.PLLN = 336;    RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;    RCC_OscInitStruct.PLL.PLLQ = 7;    HAL_RCC_OscConfig(&RCC_OscInitStruct);    RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);    RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;    RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;    RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;    RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV4;    HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);    if (HAL_GetREVID() == 0x1001)    {        __HAL_FLASH_PREFETCH_BUFFER_ENABLE();    }#endif}",Configure system clock for different STM32 families
"void init_sysclk_216MHz(void) {  RCC_OscInitTypeDef rcc_oscillator_config;  RCC_ClkInitTypeDef rcc_clock_config;  __HAL_RCC_PWR_CLK_ENABLE();  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);  rcc_oscillator_config.OscillatorType  = RCC_OSCILLATORTYPE_HSE;  rcc_oscillator_config.HSEState        = RCC_HSE_ON;  rcc_oscillator_config.HSIState        = RCC_HSI_OFF;  rcc_oscillator_config.PLL.PLLState    = RCC_PLL_ON;  rcc_oscillator_config.PLL.PLLSource   = RCC_PLLSOURCE_HSE;  rcc_oscillator_config.PLL.PLLM        = 25;  rcc_oscillator_config.PLL.PLLN        = 432;  rcc_oscillator_config.PLL.PLLP        = RCC_PLLP_DIV2;  rcc_oscillator_config.PLL.PLLQ        = 9;  HAL_RCC_OscConfig(&rcc_oscillator_config);  HAL_PWREx_EnableOverDrive();  rcc_clock_config.ClockType            = RCC_CLOCKTYPE_HCLK                                          |RCC_CLOCKTYPE_SYSCLK                                          |RCC_CLOCKTYPE_PCLK1                                          |RCC_CLOCKTYPE_PCLK2;  rcc_clock_config.SYSCLKSource         = RCC_SYSCLKSOURCE_PLLCLK;  rcc_clock_config.AHBCLKDivider        = RCC_SYSCLK_DIV1;  rcc_clock_config.APB1CLKDivider       = RCC_HCLK_DIV4;  rcc_clock_config.APB2CLKDivider       = RCC_HCLK_DIV2;  HAL_RCC_ClockConfig(&rcc_clock_config, FLASH_LATENCY_7);}",Configure the STM32F7 discovery board to operate at 216MHz
"void configure_gpio() {  GPIO_InitTypeDef gpio_init_structure;  LED_CLK_ENABLE();  gpio_init_structure.Pin   = LED_PIN;  gpio_init_structure.Mode  = GPIO_MODE_OUTPUT_PP;  gpio_init_structure.Pull  = GPIO_PULLUP;  gpio_init_structure.Speed = GPIO_SPEED_FAST;  HAL_GPIO_Init(LED_PORT, &gpio_init_structure);  HAL_GPIO_WritePin(LED_PORT, LED_PIN, GPIO_PIN_RESET);}",Configure the GPIO
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {  if (htim->Instance == TIM6) {    HAL_IncTick();  }},Period elapsed callback in non-blocking mode to increment the system tick
static void MX_USART2_UART_Init(void) {  huart2.Instance = USART2;  huart2.Init.BaudRate = 115200;  huart2.Init.WordLength = UART_WORDLENGTH_8B;  huart2.Init.StopBits = UART_STOPBITS_1;  huart2.Init.Parity = UART_PARITY_NONE;  huart2.Init.Mode = UART_MODE_TX_RX;  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart2.Init.OverSampling = UART_OVERSAMPLING_16;  huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;  huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;  if (HAL_UART_Init(&huart2) != HAL_OK)  {    Error_Handler();  }},USART2 Initialization Function
"static void MX_GPIO_Init(void) {  GPIO_InitTypeDef GPIO_InitStruct = {0};  __HAL_RCC_GPIOC_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  HAL_GPIO_WritePin(LD3_GPIO_Port, LD3_Pin, GPIO_PIN_RESET);  GPIO_InitStruct.Pin = LD3_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_NOPULL;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LD3_GPIO_Port, &GPIO_InitStruct);}",GPIO Initialization Function
void Error_Handler(void) {  __disable_irq();  while (1)  {  }},This function is executed in case of error occurrence
"static void MSC_InitApplication(void) {  BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);  BSP_JOY_Init(JOY_MODE_EXTI);  BSP_LCD_Init();  LCD_LOG_Init();#ifdef USE_USB_HS  LCD_LOG_SetHeader((uint8_t *)"" USB OTG HS MSC Host"");#else  LCD_LOG_SetHeader((uint8_t *)"" USB OTG FS MSC Host"");#endif  LCD_UsrLog(""USB Host library started.\n"");  USBH_UsrLog(""Starting MSC Demo"");  Menu_Init();}",MSC application initialization
"static void USBH_UserProcess(USBH_HandleTypeDef *phost, uint8_t id) {  switch(id)  {  case HOST_USER_SELECT_CONFIGURATION:    break;  case HOST_USER_DISCONNECTION:    Appli_state = APPLICATION_DISCONNECT;    if (FATFS_UnLinkDriver(USBDISKPath) == 0)    {      if(f_mount(NULL, """", 0) != FR_OK)      {        LCD_ErrLog(""ERROR : Cannot DeInitialize FatFs! \n"");      }    }    break;  case HOST_USER_CLASS_ACTIVE:    Appli_state = APPLICATION_READY;    break;  case HOST_USER_CONNECTION:    if (FATFS_LinkDriver(&USBH_Driver, USBDISKPath) == 0)    {      if (f_mount(&USBH_fatfs, """", 0) != FR_OK)      {        LCD_ErrLog(""ERROR : Cannot Initialize FatFs! \n"");      }    }    break;  default:    break;  }}",User process for USB host events
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef* htim_base) {    if (htim_base->Instance == TIM2)    {        /* USER CODE BEGIN TIM2_MspInit 0 */        /* USER CODE END TIM2_MspInit 0 */          /* Peripheral clock enable */        __HAL_RCC_TIM2_CLK_ENABLE();        /* USER CODE BEGIN TIM2_MspInit 1 */        /* USER CODE END TIM2_MspInit 1 */    }},"TIM_Base MSP Initialization, configures the hardware resources used in this example"
"void HAL_TIM_MspPostInit(TIM_HandleTypeDef* htim) {    GPIO_InitTypeDef GPIO_InitStruct = { 0 };    if (htim->Instance == TIM2)    {        /* USER CODE BEGIN TIM2_MspPostInit 0 */        /* USER CODE END TIM2_MspPostInit 0 */        __HAL_RCC_GPIOA_CLK_ENABLE();        /**TIM2 GPIO Configuration        PA0     ------> TIM2_CH1        */        GPIO_InitStruct.Pin = GPIO_PIN_0;        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;        GPIO_InitStruct.Pull = GPIO_NOPULL;        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;        GPIO_InitStruct.Alternate = GPIO_AF1_TIM2;        HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);        /* USER CODE BEGIN TIM2_MspPostInit 1 */        /* USER CODE END TIM2_MspPostInit 1 */    }}",Configures GPIO for TIM2 channel 1 (PA0)
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {  /* USER CODE BEGIN Callback 0 */  /* USER CODE END Callback 0 */  if (htim->Instance == TIM6) {    HAL_IncTick();  }  /* USER CODE BEGIN Callback 1 */  else if (htim->Instance == TIM13)  {  }  else if (htim->Instance == TIM14)  {  }  /* USER CODE END Callback 1 */},Period elapsed callback in non-blocking mode to increment the system tick
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET)",Configure GPIO pin Output Level
GPIO_InitStruct.Pin = GPIO_PIN_5,Configure GPIO pin : PA5
"HAL_GPIO_Init(GPIOA, &GPIO_InitStruct)",Configure GPIO pin : PA5
void EXTI2_IRQHandler(void) {    if (__HAL_GPIO_EXTI_GET_FLAG(GPIO_PIN_2) != RESET)    {        __HAL_GPIO_EXTI_CLEAR_IT(GPIO_PIN_2);    }},Handles EXTI interrupt for GPIO pin PB2 (falling edge)
"void _Error_Handler(char * file, int line) {    printf(""Error at file:%s, line:%d\n"", file, line);    while (1);}",Error handler with file and line reporting
"void start_led_sequence(void) {	HAL_TIM_Base_Start(TIMER_HANDLER_PTR);	HAL_TIM_PWM_Start_DMA(TIMER_HANDLER_PTR, PWM_CHANNEL, (uint32_t *)led_table, sizeof(led_table)/2);}",Starts the LED sequence using PWM with DMA
"void stop_led_sequence(void) {	HAL_TIM_PWM_Stop_DMA(TIMER_HANDLER_PTR, PWM_CHANNEL);	HAL_TIM_Base_Stop(TIMER_HANDLER_PTR);	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);	HAL_Delay(10);}",Stops the LED sequence and resets GPIO
"void set_color(uint32_t color_rgb, uint16_t led_id) {	if (led_id >= TOTAL_LEDS) return;	uint8_t red_color   = (color_rgb & 0xff0000)>>16;	uint8_t green_color = (color_rgb & 0x00ff00)>>8;	uint8_t blue_color  = (color_rgb & 0x0000ff);	set_pwm_entry_color(red_color  , &led_table[led_id][8]);	set_pwm_entry_color(green_color, &led_table[led_id][0]);	set_pwm_entry_color(blue_color , &led_table[led_id][16]);}",Sets RGB color for a specific WS2812B LED
"void set_pwm_entry_color(uint8_t color, uint16_t *color_ptr) {	uint8_t bits;	for(bits=0; bits<8;bits++){		if (((color >>(7-bits) & 0x01))){			color_ptr[bits] = W1;		}else{			color_ptr[bits] = W0;		}	}}",Converts color byte to PWM values for WS2812B
"void parse_led_color_input(char *ascii_color, uint32_t *color_out) {	stop_led_sequence();	uint8_t *p_char = 0;	uint8_t led_id = 0;	p_char = (uint8_t *) strchr((char *)ascii_color,' ');	if (p_char == 0)		return;	led_id = (uint8_t)((*ascii_color)-'0');	printf(""Led is [%x] , color [%s]\r\n"",led_id ,(char *)(p_char+1));	led_set_color_ascii((char *)(p_char+1),led_id,0 );	start_led_sequence();}",Parses ASCII color input and sets LED color
"void led_set_color_ascii(char *ascii_color ,uint16_t led_id, uint32_t *color_out) {	uint32_t color_out_local;	color_out_local = ascii_to_to_hex((uint8_t *)ascii_color,'h');	if (color_out_local == INVALID_DIGIT_CONVERTION) return;	set_color(color_out_local, led_id);	if (color_out != 0){		*color_out = color_out_local;	}}",Converts ASCII color to hex and sets LED color
void dsy_system_jumptoqspi() {    __JUMPTOQSPI();    while(1) {}},Jumps to QSPI memory for application execution
uint32_t dsy_system_getnow() {    return HAL_GetTick();},Returns current system tick count
void dsy_system_delay(uint32_t delay_ms) {    HAL_Delay(delay_ms);},Delays execution for specified milliseconds
__HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE),Macro to configure the PLL clock source
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48 | RCC_OSCILLATORTYPE_HSE,Select HSI48 and HSE as oscillator types for clock configuration
HAL_RCC_OscConfig(&RCC_OscInitStruct),Apply oscillator configuration for clock initialization
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 | RCC_CLOCKTYPE_D3PCLK1 | RCC_CLOCKTYPE_D1PCLK1,"Define clock types including system, AHB, and APB clocks"
"HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2)",Finalize clock configuration with specified latency
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1),Configure voltage scaling to optimize power consumption
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE,Enable HSE Oscillator and activate PLL with HSE as source
HAL_RCC_OscConfig(&RCC_OscInitStruct),Configure HSE oscillator and PLL settings
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2),"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI,Enable HSI oscillator and configure PLL settings
HAL_RCC_OscConfig(&RCC_OscInitStruct),Apply HSI oscillator and PLL configuration
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2,"Define system, AHB, and APB clock types"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_TIM34,Select USART2 and TIM34 for peripheral clock configuration
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1,Set USART2 clock source to PCLK1
PeriphClkInit.Tim34ClockSelection = RCC_TIM34CLK_HCLK,Set TIM34 clock source to HCLK
HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit),Apply peripheral clock configuration for USART2 and TIM34
MX_FREERTOS_Init(),Call init function for freertos objects
osKernelStart(),Start scheduler
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 216; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 2;,Initializes the RCC Oscillators
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_UART4|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C2|RCC_PERIPHCLK_I2C4; PeriphClkInitStruct.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2; PeriphClkInitStruct.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; PeriphClkInitStruct.Usart3ClockSelection = RCC_USART3CLKSOURCE_PCLK1; PeriphClkInitStruct.Uart4ClockSelection = RCC_UART4CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1; PeriphClkInitStruct.I2c4ClockSelection = RCC_I2C4CLKSOURCE_PCLK1;,"Configure peripheral clocks for USART, UART, and I2C"
HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim),Period elapsed callback in non blocking mode
Error_Handler(),This function is executed in case of error occurrence
HAL_TIM_Base_MspDeInit(TIM_HandleTypeDef* tim_baseHandle),Peripheral clock disable
TIM3_IRQHandler(),This function handles TIM3 global interrupt
TimInit(),Initialize TIM3 for periodic interrupts
TimerHwiCreate(),Create hardware interrupt for TIM3
GetTimerCycles(),Retrieve current TIM3 cycle count
HAL_TIM_Base_Start_IT(&htim3),Start TIM3 with interrupt
HAL_Init(),"Configure the Flash prefetch, Systick timer, and low-level initialization"
BSP_LED_Init(LED1); BSP_LED_Init(LED3);,Initialize LEDs mounted on STM32F429ZI-Nucleo_144 Rev B board
EXTI15_10_IRQHandler_Config(),Configure EXTI line 15_10 (connected to PC.13 pin) in interrupt mode
HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),EXTI line detection callbacks
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSE and activate PLL with HSE as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Select PLL as system clock source and configure clock dividers
"Calc_LOW_PASS_Coeff(&Filter_Coeff[0], 8, Filter_Points_32);",Calculate coefficients for low-pass filter
"HAL_DAC_Start(&hdac, DAC_CHANNEL_1);",Start DAC on channel 1
"HAL_ADC_Start_DMA(&hadc1, (uint32_t*)&ADC_Data_buff[0], 256);",Start ADC with DMA for data acquisition
HAL_TIM_Base_Start(&htim3);,Start TIM3 base
"FIR_filtr(&ADC_Data[0], &ADC_Data_Filtred[0], 1024, &Filter_Coeff[0], 32);",Apply FIR filter to ADC data
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL3;,Initializes the RCC Oscillators
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2;,Configure ADC peripheral clock
HAL_TIM_Base_Start(&htim2);,Start TIM2 base
"HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1);",Start PWM on TIM1 channel 1
HAL_ADC_Start(&hadc1);,Start ADC conversion
"HAL_ADC_PollForConversion(&hadc1, 1);",Poll for ADC conversion completion
ADCVal = HAL_ADC_GetValue(&hadc1);,Retrieve ADC conversion value
"TIM1->CCR1 = clamp((uint32_t)(999-Kp*DeltaVoltage-Ki*Integral), 0, 999);",Update TIM1 PWM duty cycle based on PID control
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI_DIV2; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL16;,Initializes the RCC Oscillators
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV6;,Configure ADC peripheral clock
MX_TIM2_Init(),TIM2 Initialization Function
MX_GPIO_Init(),GPIO Initialization Function
hal_bsp_init(),"Initialize system clock, UART, I2C, SPI, and timers"
hal_system_clock_start(),Start the system clock
"hal_i2c_init(0, &i2c_cfg0);",Initialize I2C0 peripheral
"hal_timer_init(0, TIM15);",Initialize Timer 0 with TIM15
"hal_timer_init(1, TIM16);",Initialize Timer 1 with TIM16
"hal_timer_init(2, TIM17);",Initialize Timer 2 with TIM17
"hal_spi_init(0, &spi0_cfg, HAL_SPI_TYPE_MASTER);",Initialize SPI0 as master
"hal_spi_init(0, &spi0_cfg, HAL_SPI_TYPE_SLAVE);",Initialize SPI0 as slave
"hal_spi_init(1, &spi1_cfg, HAL_SPI_TYPE_MASTER);",Initialize SPI1 as master
"hal_spi_init(1, &spi1_cfg, HAL_SPI_TYPE_SLAVE);",Initialize SPI1 as slave
os_cputime_init(MYNEWT_VAL(OS_CPUTIME_FREQ));,Initialize CPU time for Mynewt OS
bsp_uart_config(int port),Return UART configuration for specified port
hal_bsp_flash_dev(uint8_t id),Return internal flash device for ID 0
hal_bsp_core_dump(int *area_cnt),Return memory dump configuration
HAL_Init(),Initialize HAL and reset peripherals
GpioAdapter_init(),Initialize GPIO adapter
MX_USB_DEVICE_Init(),Initialize USB device
"HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, LED_ON);",Turn on LED1
"HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, LED_OFF);",Turn off LED1
HAL_NVIC_SystemReset(),Trigger system reset
SCB->VTOR = FLASH_FIRMWARE_ADDRESS;,Set vector table offset to firmware address
__set_MSP(*(__IO uint32_t*) FLASH_FIRMWARE_ADDRESS);,Set main stack pointer for application
JumpToApplication = (pFunction) (*(__IO uint32_t*) (FLASH_FIRMWARE_ADDRESS + 4));,Set function pointer to application entry
JumpToApplication();,Jump to application code
SystemClock_Config(),Configure the system clock to 100 MHz
BSP_LED_Init(LED1);,Initialize LEDs mounted on STM32412G-DISCOVERY board
EXTI0_IRQHandler_Config(),Configure EXTI0 (connected to PA.00 pin) in interrupt mode
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Select PLL as system clock source and configure clock dividers
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure voltage scaling for maximum frequency
"GPIO_InitStructure.Mode = GPIO_MODE_IT_RISING; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Pin = GPIO_PIN_0; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);",Configure PA.00 pin as input floating
"HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0); HAL_NVIC_EnableIRQ(EXTI0_IRQn);",Enable and set EXTI line 0 Interrupt to the lowest priority
SystemClock_Config(),Configure the system clock to 80 MHz
BSP_LED_Init(LED3); BSP_LED_Init(LED1);,Initialize LEDs on board
"BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);",Configure Wkup/Tamper push-button in Interrupt mode
HAL_RNG_DeInit(&RngHandle),DeInitialize the RNG peripheral
HAL_RNG_Init(&RngHandle),Initialize the RNG peripheral
HAL_RNG_GenerateRandomNumber_IT(&RngHandle),Enable RNG peripheral IT
"HAL_RNG_ReadyDataCallback(RNG_HandleTypeDef* hrng, uint32_t random32bit)",Data Ready callback in non-blocking mode
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Select PLL as system clock source and configure clock dividers
uint32_t HAL_GetTick(void) {    return (uint32_t)LOS_TickCountGet();},Returns the current tick count for Huawei LiteOS
"static void EXTILine0_Config(void) {  GPIO_InitTypeDef   GPIO_InitStructure;  /* Enable GPIOA clock */  __HAL_RCC_GPIOA_CLK_ENABLE();    /* Configure PA0 pin as input floating */  GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStructure.Pull = GPIO_NOPULL;  GPIO_InitStructure.Pin = GPIO_PIN_0;  HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);  /* Enable and set EXTI Line0 Interrupt to the lowest priority */  HAL_NVIC_SetPriority(EXTI0_IRQn, 2, 0);  HAL_NVIC_EnableIRQ(EXTI0_IRQn);}",Configures EXTI Line0 (connected to PA0 pin) in interrupt mode
"static void EXTILine15_10_Config(void) {  GPIO_InitTypeDef   GPIO_InitStructure;  /* Enable GPIOG clock */  __HAL_RCC_GPIOG_CLK_ENABLE();    /* Configure PG15 pin as input floating */  GPIO_InitStructure.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStructure.Pull = GPIO_NOPULL;  GPIO_InitStructure.Pin = GPIO_PIN_15;  HAL_GPIO_Init(GPIOG, &GPIO_InitStructure);  /* Enable and set EXTI15_10 Interrupt to the lowest priority */  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 3, 0);  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);}",Configures EXTI Line15 (connected to PG15 pin) in interrupt mode
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) {  if(GPIO_Pin == KEY_BUTTON_PIN)  {    /* Toggle LED2 */    BSP_LED_Toggle(LED2);  }    if(GPIO_Pin == WAKEUP_BUTTON_PIN)  {    /* Toggle LED1 */    BSP_LED_Toggle(LED1);  }},EXTI line detection callbacks
static void MX_USART2_UART_Init(void) {  /* USER CODE BEGIN USART2_Init 0 */  /* USER CODE END USART2_Init 0 */  /* USER CODE BEGIN USART2_Init 1 */  /* USER CODE END USART2_Init 1 */  huart2.Instance = USART2;  huart2.Init.BaudRate = 115200;  huart2.Init.WordLength = UART_WORDLENGTH_8B;  huart2.Init.StopBits = UART_STOPBITS_1;  huart2.Init.Parity = UART_PARITY_NONE;  huart2.Init.Mode = UART_MODE_TX_RX;  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;  huart2.Init.OverSampling = UART_OVERSAMPLING_16;  if (HAL_UART_Init(&huart2) != HAL_OK)  {    Error_Handler();  }  /* USER CODE BEGIN USART2_Init 2 */  /* USER CODE END USART2_Init 2 */},USART2 Initialization Function
"static void MX_GPIO_Init(void) {  GPIO_InitTypeDef GPIO_InitStruct = {0};  /* GPIO Ports Clock Enable */  __HAL_RCC_GPIOC_CLK_ENABLE();  __HAL_RCC_GPIOH_CLK_ENABLE();  __HAL_RCC_GPIOA_CLK_ENABLE();  __HAL_RCC_GPIOB_CLK_ENABLE();  /*Configure GPIO pin Output Level */  HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);  /*Configure GPIO pin : B1_Pin */  GPIO_InitStruct.Pin = B1_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;  GPIO_InitStruct.Pull = GPIO_NOPULL;  HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);  /*Configure GPIO pin : LD2_Pin */  GPIO_InitStruct.Pin = LD2_Pin;  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;  GPIO_InitStruct.Pull = GPIO_NOPULL;  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;  HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);}",GPIO Initialization Function
static void MX_RTC_Init(void) {  /* USER CODE BEGIN RTC_Init 0 */  /* USER CODE END RTC_Init 0 */  /* USER CODE BEGIN RTC_Init 1 */  /* USER CODE END RTC_Init 1 */  /** Initialize RTC Only   */  hrtc.Instance = RTC;  hrtc.Init.AsynchPrediv = RTC_AUTO_1_SECOND;  hrtc.Init.OutPut = RTC_OUTPUTSOURCE_ALARM;  if (HAL_RTC_Init(&hrtc) != HAL_OK)  {    Error_Handler();  }  /* USER CODE BEGIN RTC_Init 2 */  /* USER CODE END RTC_Init 2 */},RTC Initialization Function
HAL_Init(),"Initialize STM32F4xx HAL library, Flash prefetch, SysTick, NVIC, and MSP"
BSP_LED_Init(LED4),Configure LED4
uwPrescalerValue = (uint32_t) ((SystemCoreClock /2) / 10000) - 1,Compute prescaler for TIM3 counter clock at 10 kHz
TimHandle.Instance = TIMx,Set TIM3 instance
TimHandle.Init.Period = 10000 - 1,Initialize TIM3 with 10 kHz period
TimHandle.Init.Prescaler = uwPrescalerValue,Set TIM3 prescaler for 10 kHz counter clock
TimHandle.Init.ClockDivision = 0,Configure TIM3 with no clock division
TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP,Set TIM3 counter to count up
HAL_TIM_Base_Init(&TimHandle),Initialize TIM3 base configuration
HAL_TIM_Base_Start_IT(&TimHandle),Start TIM3 in interrupt mode
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {  BSP_LED_Toggle(LED3);},Period elapsed callback in non blocking mode
uint32_t HAL_GetTick(void) {    #if defined(WOLFSSL_CMSIS_RTOS)        return os_time;    #elif defined(WOLFSSL_CMSIS_RTOSv2)        return osKernelGetTickCount();    #endif},Returns the current tick count for CMSIS RTOS
time_t time(time_t *t) {     return epochTime ;},Returns the current epoch time
void setTime(time_t t) {    epochTime = t;},Sets the epoch time
double current_time(int reset) {    if (reset)        return 0;    #if defined(WOLFSSL_CMSIS_RTOS)        return (double)os_time / 1000.0;    #elif defined(WOLFSSL_CMSIS_RTOSv2)        return (double)osKernelGetTickCount() / 1000.0;    #endif},Returns the current time in seconds
"static void init_filesystem (void) {  int32_t retv;  retv = finit (""M0:"");  if (retv == fsOK) {    retv = fmount (""M0:"");    if (retv == fsOK) {      printf (""Drive M0 ready!\n"");    }    else {      printf (""Drive M0 mount failed(%d)!\n"", retv);    }  }  else {    printf (""Drive M0 initialization failed!\n"");  }}",Initialize a Flash Memory Card
"RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE)",TIM1 clock enable
"RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOE, ENABLE)",GPIOE clock enable
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_11 | GPIO_Pin_13 | GPIO_Pin_14,"TIM1 CH1 (PE9,FMU_CH4), TIM1 CH2 (PE11,FMU_CH3), TIM1 CH3 (PE13,FMU_CH2) and TIM1 CH4 (PE14,FMU_CH1)"
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF,Set GPIOE pins to alternate function mode for TIM1
"GPIO_Init(GPIOE, &GPIO_InitStructure)",Initialize GPIOE pins for TIM1 PWM channels
"GPIO_PinAFConfig(GPIOE, GPIO_PinSource9, GPIO_AF_TIM1)",Connect PE9 to TIM1 alternate function
"GPIO_PinAFConfig(GPIOE, GPIO_PinSource11, GPIO_AF_TIM1)",Connect PE11 to TIM1 alternate function
"GPIO_PinAFConfig(GPIOE, GPIO_PinSource13, GPIO_AF_TIM1)",Connect PE13 to TIM1 alternate function
"GPIO_PinAFConfig(GPIOE, GPIO_PinSource14, GPIO_AF_TIM1)",Connect PE14 to TIM1 alternate function
"RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM4, ENABLE)",TIM4 clock enable
"RCC_AHB1PeriphClockCmd(RCC_AHB1Periph_GPIOD, ENABLE)",GPIOD clock enable
GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13 | GPIO_Pin_14,"TIM4 CH2 (PD13,FMU_CH5), TIM4 CH3 (PD14,FMU_CH6)"
GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF,Set GPIOD pins to alternate function mode for TIM4
"GPIO_Init(GPIOD, &GPIO_InitStructure)",Initialize GPIOD pins for TIM4 PWM channels
"GPIO_PinAFConfig(GPIOD, GPIO_PinSource13, GPIO_AF_TIM4)",Connect PD13 to TIM4 alternate function
"GPIO_PinAFConfig(GPIOD, GPIO_PinSource14, GPIO_AF_TIM4)",Connect PD14 to TIM4 alternate function
RCC_GetClocksFreq(&rcc_clocks),Get system clock frequencies for TIM1 and TIM4
PrescalerValue = (uint16_t)((rcc_clocks.PCLK2_Frequency * 2 / TIMER_FREQUENCY) - 1),Compute prescaler value for TIM1 frequency of 3 MHz
TIM_TimeBaseStructure.TIM_Period = PWM_ARR(_pwm_freq) - 1,Set TIM1 period for 50 Hz PWM frequency
TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue,Set TIM1 prescaler for 3 MHz timer frequency
"TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure)",Configure TIM1 time base for PWM
TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1,Set TIM1 output compare to PWM1 mode
TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable,Enable TIM1 output compare state
"TIM_OC1Init(TIM1, &TIM_OCInitStructure)",Initialize TIM1 channel 1 for PWM
"TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable)",Enable TIM1 channel 1 preload
"TIM_OC2Init(TIM1, &TIM_OCInitStructure)",Initialize TIM1 channel 2 for PWM
"TIM_OC2PreloadConfig(TIM1, TIM_OCPreload_Enable)",Enable TIM1 channel 2 preload
"TIM_OC3Init(TIM1, &TIM_OCInitStructure)",Initialize TIM1 channel 3 for PWM
"TIM_OC3PreloadConfig(TIM1, TIM_OCPreload_Enable)",Enable TIM1 channel 3 preload
"TIM_OC4Init(TIM1, &TIM_OCInitStructure)",Initialize TIM1 channel 4 for PWM
"TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable)",Enable TIM1 channel 4 preload
"TIM_ARRPreloadConfig(TIM1, ENABLE)",Enable TIM1 auto-reload preload
PrescalerValue = (uint16_t)((rcc_clocks.PCLK1_Frequency * 2 / TIMER_FREQUENCY) - 1),Compute prescaler value for TIM4 frequency of 3 MHz
TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue,Set TIM4 prescaler for 3 MHz timer frequency
"TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure)",Configure TIM4 time base for PWM
"TIM_OC2Init(TIM4, &TIM_OCInitStructure)",Initialize TIM4 channel 2 for PWM
"TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Enable)",Enable TIM4 channel 2 preload
"TIM_OC3Init(TIM4, &TIM_OCInitStructure)",Initialize TIM4 channel 3 for PWM
"TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Enable)",Enable TIM4 channel 3 preload
"TIM_ARRPreloadConfig(TIM4, ENABLE)",Enable TIM4 auto-reload preload
,
"rt_inline void _pwm_write(uint8_t chan_id, float duty_cyc) {    _timer_set_compare[chan_id](PWM_TIMER(chan_id), PWM_ARR(_pwm_freq) * duty_cyc);    _pwm_fmu_duty_cyc[chan_id] = duty_cyc;}",Writes PWM duty cycle to specified channel
"rt_inline void _pwm_read(uint8_t chan_id, float* duty_cyc) {    *duty_cyc = _pwm_fmu_duty_cyc[chan_id];}",Reads PWM duty cycle from specified channel
"static rt_err_t motor_configure(motor_dev_t motor, struct motor_configure* cfg) {    motor->config = *cfg;    DRV_DBG(""aux motor configured: min:%d max:%d\n"", motor->config.motor_min_value, motor->config.motor_max_value);    return RT_EOK;}",Configures motor parameters
"static rt_size_t motor_read(motor_dev_t motor, rt_uint16_t chan_mask, rt_uint16_t* chan_val, rt_size_t size) {    rt_uint16_t* index = chan_val;    float dc;    for (uint8_t i = 0; i < MAX_PWM_OUT_CHAN; i++) {        if (chan_mask & (1 << i)) {            _pwm_read(i, &dc);            *index = 1000000 / _pwm_freq * dc;            index++;        }    }    return size;}",Reads motor PWM values for specified channels
"static rt_size_t motor_write(motor_dev_t motor, rt_uint16_t chan_mask, const rt_uint16_t* chan_val, rt_size_t size) {    const rt_uint16_t* index = chan_val;    rt_uint16_t val;    float dc;    DRV_DBG(""aux motor write: "");    for (uint8_t i = 0; i < MAX_PWM_OUT_CHAN; i++) {        if (chan_mask & (1 << i)) {            /* constrain motor value */            val = constrain_uint16(*index, motor->config.motor_min_value, motor->config.motor_max_value);            /* calculate pwm duty cycle */            dc = VAL_TO_DC(val);            /* update pwm signal */            _pwm_write(i, dc);            DRV_DBG(""chan[%d]=%d %.2f "", i + 1, *index, dc);            index++;        }    }    DRV_DBG(""\n"");    return size;}",Writes PWM values to specified motor channels
"rt_err_t pwm_drv_init(void) {    rt_err_t ret;    static struct motor_device motor;    struct motor_configure motor_config = MOTOR_CONFIG_DEFAULT;    _pwm_gpio_init();    _pwm_timer_init();    /* Disable output by default, need ne enabled by uper layer */    TIM_Cmd(TIM1, DISABLE);    TIM_CtrlPWMOutputs(TIM1, DISABLE);    TIM_Cmd(TIM4, DISABLE);    /* register motor hal device */    motor.channel_num = MAX_PWM_OUT_CHAN;    motor.config = motor_config;    motor.ops = &_motor_ops;    ret = hal_motor_register(&motor, ""motor_aux"", RT_DEVICE_FLAG_RDWR, NULL);    return ret;}",Initializes PWM driver for motor control
void SysTick_Handler(void) {      HAL_IncTick();      osSystickHandler();},Handles SysTick interrupt for HAL and RTOS
void ETH_IRQHandler(void) {      HAL_ETH_IRQHandler(&EthHandle);},Handles Ethernet interrupt
"static void MainThread(void const * argument) {       struct netconn *pListeningConnection, *pAcceptedConnection;      err_t err;              tcpip_init(NULL, NULL);      Netif_Config();            gnetif.ip_addr.addr = 0;      gnetif.netmask.addr = 0;      gnetif.gw.addr = 0;      printf(""Waiting for DHCP reply...\n"");      dhcp_start(&gnetif);      while (!*((volatile u32_t *)&gnetif.ip_addr.addr))            asm(""nop"");            printf(""Got IP address: %d.%d.%d.%d\n"",        ip4_addr1_16_val(gnetif.ip_addr),        ip4_addr2_16_val(gnetif.ip_addr),        ip4_addr3_16_val(gnetif.ip_addr),        ip4_addr4_16_val(gnetif.ip_addr));              pListeningConnection = netconn_new(NETCONN_TCP);      if (!pListeningConnection)            asm(""bkpt 255"");      err = netconn_bind(pListeningConnection, NULL, 80);            if (err != ERR_OK)            asm(""bkpt 255"");      netconn_listen(pListeningConnection);        for (;;)      {            err = netconn_accept(pListeningConnection, &pAcceptedConnection);            if (err == ERR_OK)            {                  struct netbuf *inbuf = NULL;                  err = netconn_recv(pAcceptedConnection, &inbuf);                  if (err != ERR_OK)                        asm(""bkpt 255"");                  netbuf_delete(inbuf);                                    static const char HelloWorld[] = ""HTTP/1.0 200 OK\r\nContent-Type: text/html\r\n\r\n<html><body><h1>Hello, World</h1>This message is shown to you by the lwIP example project.</body></html>"";                  netconn_write(pAcceptedConnection,                        (const unsigned char*)HelloWorld,                        sizeof(HelloWorld),                        NETCONN_NOCOPY);                  netconn_delete(pAcceptedConnection);            }      }}",Main thread for TCP/IP server
"static void Netif_Config(void) {      ip_addr_t ipaddr;      ip_addr_t netmask;      ip_addr_t gw;         IP4_ADDR(&ipaddr, IP_ADDR0, IP_ADDR1, IP_ADDR2, IP_ADDR3);      IP4_ADDR(&netmask, NETMASK_ADDR0, NETMASK_ADDR1, NETMASK_ADDR2, NETMASK_ADDR3);      IP4_ADDR(&gw, GW_ADDR0, GW_ADDR1, GW_ADDR2, GW_ADDR3);        netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &tcpip_input);      netif_set_default(&gnetif);        if (netif_is_link_up(&gnetif))            netif_set_up(&gnetif);      else            netif_set_down(&gnetif);}",Configures network interface
static void MPU_Config(void) {      MPU_Region_InitTypeDef MPU_InitStruct;        /* Disable the MPU */      HAL_MPU_Disable();      /* Configure the MPU attributes as WT for SRAM */      MPU_InitStruct.Enable = MPU_REGION_ENABLE;      MPU_InitStruct.BaseAddress = 0x20010000;      MPU_InitStruct.Size = MPU_REGION_SIZE_256KB;      MPU_InitStruct.AccessPermission = MPU_REGION_FULL_ACCESS;      MPU_InitStruct.IsBufferable = MPU_ACCESS_NOT_BUFFERABLE;      MPU_InitStruct.IsCacheable = MPU_ACCESS_CACHEABLE;      MPU_InitStruct.IsShareable = MPU_ACCESS_NOT_SHAREABLE;      MPU_InitStruct.Number = MPU_REGION_NUMBER0;      MPU_InitStruct.TypeExtField = MPU_TEX_LEVEL0;      MPU_InitStruct.SubRegionDisable = 0x00;      MPU_InitStruct.DisableExec = MPU_INSTRUCTION_ACCESS_ENABLE;      HAL_MPU_ConfigRegion(&MPU_InitStruct);      /* Enable the MPU */      HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);},Configure the MPU attributes as Write Through for SRAM1/2
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE;,Initializes the RCC Oscillators
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
CPU_CACHE_Enable(),Enable the CPU Cache
HAL_Init(),STM32F7xx HAL library initialization
SystemClock_Config(),Configure the system clock to 200 MHz
BSP_SDRAM_Init(),Initializes the SDRAM device
__HAL_RCC_CRC_CLK_ENABLE(),Enable the CRC Module
GUI_Init(),Init the STemWin GUI Library
WM_MULTIBUF_Enable(1),Enable Window Manager Multibuffering
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 400; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9;,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive(),Enable OverDrive mode
TM_RCC_InitSystem(),Init system clock for maximum system speed
HAL_Init(),Init HAL layer
TM_DELAY_Init(),Initialize delay module
"TM_USART_Init(USART, TM_USART_PinsPack_1, 921600)",Init USART
"TM_SPI_Init(SPI, SPI_PP)",Init SPI
TM_SPI_DMA_Init(SPI),Init SPI DMA
"TM_SPI_DMA_Transmit(SPI, SPI_TX, SPI_RX, TX_SIZE)",Send via SPI with DMA
TM_DMA_TransferCompleteHandler(DMA_Stream_TypeDef* DMA_Stream),DMA transfer complete callback
LCD_Init(),Initialize LCD
"HAL_UART_Receive_IT(&huart1, (uint8_t*) rxBuffer, 1)",Start UART reception in interrupt mode
HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart),UART receive complete callback
USART1_IRQHandler(),This function handles USART1 interrupt
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9;,Initializes the RCC Oscillators
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
MX_USART1_UART_Init(),USART1 Initialization Function
HAL_UART_MspInit(UART_HandleTypeDef* uartHandle),"Configure USART1 and USART2 GPIO, clock, DMA, and interrupts"
HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle),"Deinitialize USART1 and USART2 GPIO, clock, DMA, and interrupts"
PUTCHAR_PROTOTYPE,Retargets the C library printf function to the USART
UsartReceive_IDLE(UART_HandleTypeDef *huart),This function handles USART1 IDLE interrupt
__HAL_RCC_USART1_CLK_ENABLE(),Peripheral clock enable for USART1
__HAL_RCC_USART2_CLK_ENABLE(),Peripheral clock enable for USART2
"HAL_GPIO_Init(DEV_TX_GPIO_Port, &GPIO_InitStruct)",Configure USART1 TX and RX GPIO pins
HAL_DMA_Init(&hdma_usart1_rx),Peripheral DMA init for USART1
HAL_DMA_Init(&hdma_usart2_rx),Peripheral DMA init for USART2
"HAL_NVIC_SetPriority(USART1_IRQn, 5, 0); HAL_NVIC_EnableIRQ(USART1_IRQn)",Peripheral interrupt init for USART1
"HAL_NVIC_SetPriority(USART2_IRQn, 5, 0); HAL_NVIC_EnableIRQ(USART2_IRQn)",Peripheral interrupt init for USART2
"HAL_UART_Transmit(&huart2, (uint8_t *)&ch, 1, 0xFFFF)",Transmit character via USART2 for printf
"HAL_UART_Receive_DMA(&huart1,UsartType.RX_pData,RX_LEN)",Restart UART DMA reception
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6;,Initializes the RCC Oscillators
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL;,Configure USB peripheral clock
"HAL_GPIO_Init(ON_BOARD_LED_GPIO_Port, &GPIO_InitStruct)",Configure GPIO pin for onboard LED
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 13; RCC_OscInitStruct.PLL.PLLN = 195; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4;,Initializes the RCC Oscillators
MX_USART3_UART_Init(),USART3 Initialization Function
"HAL_GPIO_Init(GPIOB, &GPIO_InitStruct)",Configure GPIO pin for output
"HAL_UART_Transmit_IT(&huart1, tx_data, strlen((const char *)tx_data))",Transmit data via UART in interrupt mode
"HAL_UART_Receive_IT(&huart1, &d, 1 * sizeof(uint8_t))",Receive data via UART in interrupt mode
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; PeriphClkInit.Usart1ClockSelection = RCC_USART1CLKSOURCE_PCLK2;,Configure USART1 peripheral clock
nandFlashInit(),Initialize NAND flash
MX_FMC_Init(),Initialize FMC for NAND flash
HAL_NAND_Reset(&hnand1),Reset NAND flash
"HAL_NVIC_SetPriority(EXTI9_5_IRQn, 15, 15); HAL_NVIC_EnableIRQ(EXTI9_5_IRQn)",Enable and set EXTI interrupt for NAND flash
nandFlashEraseBlock(uint32_t block),Erase a NAND flash block
"nandFlashReadPage(uint32_t block, uint32_t page, void *buffer)",Read a NAND flash page with ECC correction
osMutexCreate(&sMutex),Create mutex for NAND flash access
osMutexLock(&sMutex),Lock mutex for NAND flash access
osMutexUnlock(&sMutex),Unlock mutex for NAND flash access
Stm32_Clock_Init(RCC_PLL_MUL9),Configure the system clock
uart_init(115200),Initialize UART with 115200 baud rate
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);",Configure Key Button
RngHandle.Instance = RNG; if(HAL_RNG_Init(&RngHandle) != HAL_OK) { Error_Handler(); },Configure the RNG peripheral
for(counter = 0; counter < 8; counter++) { aRandom32bit[counter] = HAL_RNG_GetRandomNumber(&RngHandle); },Generate 8 Random 32bit Numbers
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_?????InitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
static void NonSecure_Init(void) {  funcptr_NS NonSecure_ResetHandler;  SCB_NS->VTOR = VTOR_TABLE_NS_START_ADDR;  /* Set non-secure main stack (MSP_NS) */  __TZ_set_MSP_NS((*(uint32_t *)VTOR_TABLE_NS_START_ADDR));  /* Get non-secure reset handler */  NonSecure_ResetHandler = (funcptr_NS)(*((uint32_t *)((VTOR_TABLE_NS_START_ADDR) + 4U)));  /* Start non-secure state software application */  NonSecure_ResetHandler();},Non-secure call function responsible for Non-secure initialization and switch to non-secure state
"int fputc(int ch, FILE *f) {    while (!(CDC_Transmit_FS((uint8_t *)&ch, 1) == USBD_OK))        ;    while (!(CDC_Transmit_FS((uint8_t *)&ch, 1) == USBD_BUSY))        ;    return ch;}",Redirects printf to USB CDC
"int fputc(int ch, FILE *f) {    while (!(CDC_Transmit_FS((uint8_t *)&ch, 1) == USBD_OK))        ;    return ch;}",Redirects printf to USB CDC
MX_USART1_UART_Init(),Initialize USART1
"HAL_GPIO_WritePin(GPIOC, LD3_Pin, GPIO_PIN_SET)",system ready LED
"HAL_NVIC_SetPriority(USART1_IRQn, 1, 0); HAL_NVIC_EnableIRQ(USART1_IRQn)",set USART-1 interrupt preempt priority 1 and enable USART-1 interrupt
"HAL_UART_Transmit(&huart1, serial_data, 3, HAL_MAX_DELAY)",transmit data
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 16; RCC_OscInitStruct.LSIState = RCC_LSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3;,Initializes the RCC Oscillators
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI;,Configure RTC peripheral clock
"HAL_UART_Receive_IT_IDLE(&huart6, UART_RxBuffer, 2048)",Start UART Receive With IDLE Interrupt
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 6; RCC_OscInitStruct.PLL.PLLN = 168; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,"Initializes the CPU, AHB and APB buses clocks"
__HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1),Configure the main internal regulator output voltage
"_Error_Handler(__FILE__, __LINE__)",This function is executed in case of error occurrence
halInit(),"HAL initialization, this also initializes the configured device drivers and performs the board-specific initializations"
SwoInit(),init SWO as soon as possible to make it available to output ASAP
osKernelInitialize(),The kernel is initialized but not started yet
LaunchCLR((uint32_t)&__nanoImage_end__),launch nanoCLR
"sduObjectInit(&SDU1); sduStart(&SDU1, &serusbcfg)",Initializes a serial-over-USB CDC driver
"usbDisconnectBus(serusbcfg.usbp); chThdSleepMilliseconds(100); usbStart(serusbcfg.usbp, &usbcfg); usbConnectBus(serusbcfg.usbp)",Activates the USB driver and then the USB bus pull-up on D+
osKernelStart(),"start kernel, after this main() will behave like a thread with priority osPriorityNormal"
BlockStorageList_Initialize(); BlockStorage_AddDevices(),initialize block storage list and devices
"palSetPad(GPIOA, GPIOA_USER_LED); osDelay(500); palClearPad(GPIOA, GPIOA_USER_LED); osDelay(500)",Toggle user LED with 500ms delay
tos_tf_module_mqtt_conn(init_params),Establish MQTT connection
"tos_tf_module_mqtt_publ(report_topic_name, QOS0, payload)",Publish data to MQTT topic
"tos_mail_q_create(&mail_q, pm2d5_value_pool, 3, sizeof(pm2d5_data_u))",Create mailbox queue for PM2.5 data
pm2d5_parser_init(),Initialize PM2.5 parser
HAL_NVIC_DisableIRQ(USART3_4_IRQn); HAL_NVIC_EnableIRQ(USART3_4_IRQn),Disable and enable USART3/4 interrupt for mailbox operations
HAL_NVIC_SystemReset(),Perform system reset if MQTT publish fails repeatedly
OLED_Init(); OLED_Clear(),Initialize and clear OLED display
MX_TOF_Init(),Initialize the peripherals and the TOF components
MX_TOF_Process(),Run the TOF background task
MX_VL53L3CX_SimpleRanging_Init(),Initialize VL53L3CX for simple ranging
MX_VL53L3CX_SimpleRanging_Process(),Process VL53L3CX ranging data
CUSTOM_RANGING_SENSOR_Init(CUSTOM_VL53L3CX),Initialize VL53L3CX ranging sensor
"CUSTOM_RANGING_SENSOR_ReadID(CUSTOM_VL53L3CX, &Id)",Read VL53L3CX sensor ID
"CUSTOM_RANGING_SENSOR_GetCapabilities(CUSTOM_VL53L3CX, &Cap)",Get VL53L3CX sensor capabilities
"CUSTOM_RANGING_SENSOR_ConfigProfile(CUSTOM_VL53L3CX, &Profile)",Set the profile if different from default one
"CUSTOM_RANGING_SENSOR_Start(CUSTOM_VL53L3CX, RS_MODE_BLOCKING_CONTINUOUS)",Start VL53L3CX in blocking continuous mode
"CUSTOM_RANGING_SENSOR_GetDistance(CUSTOM_VL53L3CX, &Result)",Get distance measurement from VL53L3CX
BSP_COM_Init(COM1),Initialize Virtual COM Port
"HAL_UART_Receive_IT(&huart3, (uint8_t *) msg_str, strlen(""SP:10""))",Receive UART data for setpoint configuration
LCD_Init(&hlcd1),initialize LCD
"arm_pid_init_f32(&pid,1)",initialize PID
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 4; RCC_OscInitStruct.PLL.PLLN = 216; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 3;,Initializes the RCC Oscillators
HAL_MspInit(),Initializes the Global MSP
HAL_CAN_MspInit(CAN_HandleTypeDef* hcan),CAN MSP Initialization
HAL_SPI_MspDeInit(SPI_HandleTypeDef* hspi),SPI MSP De-Initialization
HAL_TIM_OC_MspDeInit(TIM_HandleTypeDef* htim_oc),TIM_OC MSP De-Initialization
HAL_UART_MspInit(UART_HandleTypeDef* huart),UART MSP Initialization
HAL_UART_MspDeInit(UART_HandleTypeDef* huart),UART MSP De-Initialization
__HAL_RCC_AFIO_CLK_ENABLE(); __HAL_RCC_PWR_CLK_ENABLE(),Enable AFIO and PWR clocks
__HAL_AFIO_REMAP_SWJ_NOJTAG(),NOJTAG: JTAG-DP Disabled and SW-DP Enabled
MX_RTC_Init(),Initialize RTC Only
"HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BCD); HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BCD)",Initialize RTC and set the Time and Date
MX_X_CUBE_SUBG2_Process(),Process SubG2 application
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE; RCC_OscInitStruct.LSEState = RCC_LSE_ON; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3;,Initializes the RCC Oscillators
MX_ADC1_Init(),ADC1 init function
"HAL_ADC_ConfigChannel(&hadc1, &sConfig)",Configure for the selected ADC regular channel its corresponding rank in the sequencer and its sample time
"HAL_ADCEx_InjectedConfigChannel(&hadc1, &sConfigInjected)",Configures for the selected ADC injected channel its corresponding rank in the sequencer and its sample time
HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle),Initialize ADC MSP
HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle),Deinitialize ADC MSP
"AdcGetValue(uint32_t *channel1, uint32_t *channel2)",Read ADC values from channels 1 and 2
"HAL_ADC_Start(&hadc1); HAL_ADC_PollForConversion(&hadc1, 5)",Start ADC conversion and poll for completion
osKernelInitialize(),Init scheduler
BSP_LED_Init(LED_OK); BSP_LED_Init(LED_ERROR),Configure LED_OK and LED_ERROR
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6; RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 55; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;,Enable MSI Oscillator and activate PLL with MSI as source
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV2; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;,Select PLL as system clock source with AHB prescaler divider 2 as first step
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0),Enable voltage range 0 for frequency above 80 Mhz
MX_ICACHE_Init(),Enable instruction cache in 1-way (direct mapped cache)
#define FPS2HZ 0x02,Define for 2Hz refresh rate
#define FPS4HZ 0x03,Define for 4Hz refresh rate
#define FPS8HZ 0x04,Define for 8Hz refresh rate
#define FPS16HZ 0x05,Define for 16Hz refresh rate
#define FPS32HZ 0x06,Define for 32Hz refresh rate
#define MLX90640_ADDR 0x33,I2C address for MLX90640 sensor
#define RefreshRate FPS16HZ,Set refresh rate to 16Hz
#define TA_SHIFT 8,Default shift for MLX90640 in open air
float tr = Ta - TA_SHIFT;,Reflected temperature based on the sensor ambient temperature
AdcHandle.Instance = ADCx;,Configure the ADC peripheral
sConfig.Channel = ADCx_CHANNEL;,Configure ADC regular channel
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle) {...},Conversion complete callback in non blocking mode
uhADCxConvertedValue = HAL_ADC_GetValue(AdcHandle);,Get the converted value of regular channel
"HAL_UART_Receive(&huart1, buffer, 32, 1000);",Receive data via UART with a timeout of 1000ms
"HAL_UART_Transmit(&huart1, buffer, sizeof(buffer), 1000);",Transmit received data back via UART
uart_tbl[i].is_open = false;,Initialize UART channel as closed
uart_tbl[i].baud = 57600;,Set default baud rate to 57600
"bool uartOpen(uint8_t ch, uint32_t baud) {...}",Open UART channel with specified baud rate
"uart_init(uart_tbl[ch].p_uart, baud);",Initialize UART with specified baud rate
"gpio_set_function(16, GPIO_FUNC_UART);",Set GPIO pin 16 as UART TX
"gpio_set_function(17, GPIO_FUNC_UART);",Set GPIO pin 17 as UART RX
"uart_set_hw_flow(uart_tbl[ch].p_uart, false, false);","Set UART flow control CTS/RTS, we don't want these, so turn them off"
"uint32_t uartPrintf(uint8_t ch, char *fmt, ...) {...}",Formatted print to UART
uint32_t uartGetBaud(uint8_t ch) {...},Get the baud rate of the UART channel
void StartThreads() {...},"Start the threads, create the message queue, setup the message pool"
MX_USB_DEVICE_Init();,init USB
"osMessageQDef(SocketQ1, 16, T_MSG); SocketQ1Handle = osMessageCreate(osMessageQ(SocketQ1), NULL);",definition and creation of SocketQ1
"osMessageQDef(ResultsQ, 16, T_MSG); ResultsQHandle = osMessageCreate(osMessageQ(ResultsQ), NULL);",definition and creation of ResultsQ
"osMessageQDef(SocketQ2, 16, T_MSG); SocketQ2Handle = osMessageCreate(osMessageQ(SocketQ2), NULL);",definition and creation of SocketQ2
"osMessageQDef(SocketQ3, 16, T_MSG); SocketQ3Handle = osMessageCreate(osMessageQ(SocketQ3), NULL);",definition and creation of SocketQ3
"osMessageQDef(SocketQ4, 16, T_MSG); SocketQ4Handle = osMessageCreate(osMessageQ(SocketQ4), NULL);",definition and creation of SocketQ4
"osThreadDef(TaskMain, StartTaskMain, osPriorityNormal, 0, 2048); TaskMainHandle = osThreadCreate(osThread(TaskMain), NULL);",definition and creation of defaultTask
"osThreadDef(TaskSocket1, StartTaskSocket, osPriorityNormal, 0, 2048); TaskSocket1Handle = osThreadCreate(osThread(TaskSocket1), (void*) 1);",definition and creation of TaskSocket1
"osThreadDef(TaskSocket2, StartTaskSocket, osPriorityNormal, 0, 2048); TaskSocket2Handle = osThreadCreate(osThread(TaskSocket2), (void*) 2);",definition and creation of TaskSocket2
"osThreadDef(TaskSocket3, StartTaskSocket, osPriorityNormal, 0, 2048); TaskSocket3Handle = osThreadCreate(osThread(TaskSocket3), (void*) 3);",definition and creation of TaskSocket3
"osThreadDef(TaskSocket4, StartTaskSocket, osPriorityNormal, 0, 2048); TaskSocket4Handle = osThreadCreate(osThread(TaskSocket4), (void*) 4);",definition and creation of TaskSocket4
void ShowMenu() {...},Display the demo menu
"VCP_write(""MainTask\n\r"", 10);",Write to virtual COM port
T_MSG *pDisableMsg = osPoolAlloc(MsgPool);,get a message buffer from the pool
pDisableMsg->msgType = spdDISABLE;,send disable message -- to active socket
pEnableMsg->msgType = spdENABLE;,send enable message -- to next socket
"while (HAL_GPIO_ReadPin(USER_Btn_GPIO_Port, USER_Btn_Pin) == GPIO_PIN_SET) osDelay(100);",wait for the pin to go back
__IO FlagStatus TamperStatus;,Variable to store tamper status
TamperStatus = RESET;,Clear tamper interrupt flag
"for (uint32_t i = 0; i < RTC_BKP_NUMBER; i++) { HAL_RTCEx_BKUPWrite(&hrtc, i, 0xFFFFFFFF); }",Set all backup registers to 0xFFFFFFFF. Backup registers will be cleared by a tamper detection.
"for (i = 0; i < RTC_BKP_NUMBER; i++) { if (HAL_RTCEx_BKUPRead(&hrtc, i) != 0xFFFFFFFF) { Error_Handler(); } }",Check that Backup registers have been written
while (TamperStatus == RESET);,Wait for tamper detection. User must act as described in the readme.txt
"for (i = 0; i < RTC_BKP_NUMBER; i++) { if (HAL_RTCEx_BKUPRead(&hrtc, i) != 0) { Error_Handler(); } }",Check that Backup registers have been cleared by the tamper detection
BSP_LED_On(LED2);,Test is OK Turn on LED2
void HAL_RTCEx_Tamper1EventCallback(RTC_HandleTypeDef *hrtc) { TamperStatus = SET; },Tamper event callback function
MAX7219_Init(&hspi1);,Initialize MAX7219 display driver
GFX_SetFont(font_7x5);,Set font to 7x5 pixels
GFX_SetFontSize(1);,Set font size to 1
MAX7219_Clear(MAX7219_BLACK);,Clear display with black color
MAX7219_Display();,Update the display
TextSize = strlen(Text);,Calculate the length of the text string
"GFX_DrawString(i,0, Text, MAX7219_WHITE, MAX7219_BLACK);",Draw text string at specified position
"HAL_GPIO_WritePin(TEST_GPIO_Port, TEST_Pin, GPIO_PIN_RESET);",Set test pin low
"HAL_GPIO_WritePin(TEST_GPIO_Port, TEST_Pin, GPIO_PIN_SET);",Set test pin high
void benchmark_test(void *arg);,Main entry for cryptographic benchmark test
setTime((RTC_YEAR-1970)*365*24*60*60 + RTC_MONTH*30*24*60*60 + RTC_DAY*24*60*60);,Set epoch time based on RTC values
lv_init();,Initialize LVGL library
tft_init();,Initialize TFT display
touchpad_init();,Initialize touchpad
lv_demo_widgets();,Run LVGL demo widgets
lv_task_handler();,Handle LVGL tasks
BSP_LED_Init(LED10);,Configure LED10
while(operationComplete == 0);,Wait until the interrupt is triggered
in.hash = SigVer_Hash_Msg_False;,Simulate a wrong hash message verification
if(HAL_PKA_DeInit(&hpka) != HAL_OK) { Error_Handler(); },Deinitialize the PKA
void HAL_PKA_ErrorCallback(PKA_HandleTypeDef *hpka) { Error_Handler(); },Error callback.
void Error_Handler(void) { while (1) { BSP_LED_Toggle(LED10); HAL_Delay(1000); } },This function is executed in case of error occurrence.
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable GPIOs clocks
STM32_HC_PORT_VBUS_CLK_ENABLE();,Enable GPIOs clocks
"GPIO_InitStructure.Pin = GPIO_PIN_11 | GPIO_PIN_12; GPIO_InitStructure.Speed = GPIO_SPEED_HIGH; GPIO_InitStructure.Mode = GPIO_MODE_AF_PP; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Alternate = GPIO_AF10_OTG_FS; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);",USB_DM -----------------------> PA11 USB_DP -----------------------> PA12
"GPIO_InitStructure.Pin = GPIO_PIN_10; GPIO_InitStructure.Mode = GPIO_MODE_AF_OD; GPIO_InitStructure.Pull = GPIO_PULLUP; GPIO_InitStructure.Alternate = GPIO_AF10_OTG_FS; HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);",USB_ID ----------------------> PA10
"GPIO_InitStructure.Pin = STM32_HC_VBUS_PIN; GPIO_InitStructure.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStructure.Pull = GPIO_NOPULL; HAL_GPIO_Init(STM32_HC_VBUS_PORT, &GPIO_InitStructure);",USB_VBUS ---------------------> STM32_HC_VBUS_PIN
__HAL_RCC_USB_OTG_FS_CLK_ENABLE();,Enable USB clock
BSP_LCD_GLASS_Init();,LCD GLASS Initialization
"BSP_LCD_GLASS_ScrollSentence(LCD_String, SCROLL_NUM, SCROLL_SPEED);","Display "" STM32L0 "" string on LCD glass in scrolling mode"
"Standard_Voltage_ADC = Get_Vrefint_ADC_Value(&hadc1,ADC_CHANNEL_VREFINT);",Get 1.2V Standard Voltage ADC
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);",Initialize Key Button mounted on STM32469I-EVAL board
if (BSP_PB_GetState(BUTTON_KEY) == GPIO_PIN_RESET) { IAP_Init(); Main_Menu (); },Test if Key push-button is pressed
if (((*(__IO uint32_t*)APPLICATION_ADDRESS) & 0x2FFE0000 ) == 0x20000000) { JumpAddress = *(__IO uint32_t*) (APPLICATION_ADDRESS + 4); JumpToApplication = (pFunction) JumpAddress; __set_MSP(*(__IO uint32_t*) APPLICATION_ADDRESS); JumpToApplication(); },"Test if user code is programmed starting from address ""APPLICATION_ADDRESS"""
"void IAP_Init(void) { UartHandle.Init.BaudRate = 115200; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_NONE; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_RX | UART_MODE_TX; BSP_COM_Init(COM1, &UartHandle); }",Initialize the IAP: Configure USART.
__TIM14_CLK_ENABLE();,Enable each GPIO Clock (to be able to program the configuration registers)
"GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull  = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_HIGH; GPIO_InitStruct.Pin = GPIO_PIN_3; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure IOs in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Mode  = GPIO_MODE_AF_PP; GPIO_InitStruct.Alternate = GPIO_AF4_TIM14; GPIO_InitStruct.Pin = GPIO_PIN_4; HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure IOs in output push-pull mode to drive external LEDs
"TIM_OC_InitStruct.OCMode = TIM_OCMODE_PWM1; TIM_OC_InitStruct.OCPolarity = TIM_OCPOLARITY_HIGH; TIM_OC_InitStruct.OCFastMode = TIM_OCFAST_DISABLE; TIM_OC_InitStruct.Pulse = Counter; HAL_TIM_PWM_ConfigChannel(&TIM_HandleStruct,&TIM_OC_InitStruct,TIM_CHANNEL_1); HAL_TIM_PWM_Start(&TIM_HandleStruct,TIM_CHANNEL_1);",Configure PWM Functionality of timer
HAL_PWREx_ReleaseCore(PWR_CORE_CPU2);,Boot CPU2
"if (!rcutils_set_default_allocator(&freeRTOS_allocator)) { printf(""Error on default allocators (line %d)\n"", __LINE__); }",Error on default allocators
"osThreadNew(appMain, NULL, &attributes);",Launch app thread when IP configured
vTaskList(ptrTaskList);,Task list display
Stm32_Clock_Init(RCC_PLL_MUL9);,"Set clock, 72M"
OSInit();,UCOS initialization
OSStatInit();,Open statistics task
OS_ENTER_CRITICAL();,Enter critical section (disable interrupts)
"OSTaskCreateExt((void(*)(void *) )led0_task, (void * )0, (OS_STK * )&LED0_TASK_STK[LED0_STK_SIZE - 1], (INT8U )LED0_TASK_PRIO, (INT16U )LED0_TASK_PRIO, (OS_STK * )&LED0_TASK_STK[0], (INT32U )LED0_STK_SIZE, (void * )0, (INT16U )OS_TASK_OPT_STK_CHK | OS_TASK_OPT_STK_CLR | OS_TASK_OPT_SAVE_FP);",LED0 task
OS_EXIT_CRITICAL();,Exit critical section (enable interrupts)
OSTaskSuspend(START_TASK_PRIO);,Suspend start task
LED0 = 0; delay_ms(80); LED0 = 1; delay_ms(920);,LED0 task toggle
LED1 = 0; delay_ms(300); LED1 = 1; delay_ms(300);,LED1 task toggle
if (HAL_TIM_Base_Start(&htim1) != HAL_OK) { Error_Handler(); },Timer1 Start
if (!RF22_DatagramInit(SENSOR_MODULE_ADDRESS)) { Error_Handler(); },Initialize RF22 datagram
"if (RF22_recvfromAckTimeout(respBuf, &len, 1000, &from, NULL, NULL, NULL)) { respVal++; respVal++; }",Receive acknowledgment with timeout
__HAL_RCC_SPI2_CLK_ENABLE();,Enable SPI2 clock
"GPIO_InitStruct.Pin = PI_CLK_RX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF0_SPI2; HAL_GPIO_Init(PI_CLK_RX_GPIO_Port, &GPIO_InitStruct);",Configure SPI2 clock pin
"GPIO_InitStruct.Pin = PI_DATA_RX_Pin; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF1_SPI2; HAL_GPIO_Init(PI_DATA_RX_GPIO_Port, &GPIO_InitStruct);",Configure SPI2 data pin
SPI1->CR1 &= ~SPI_CR1_SPE;,BIT 6 DISABLE SPI
SPI1->CR1 |= SPI_CR1_MSTR;,BIT 2. MASTER MODE ACTIVE
SPI1->CR1 |= SPI_LSBFIRST;,BIT 7. LSB FIRST DURING LED DATA
SPI1->CR1 |= SPI_CR1_SSM;,BIT 9. DISABLE SLAVE MANAGEMENT
SPI1->CR2 |= SPI_CR2_TXDMAEN;,BIT 1 TO 1. ENABLE DMA TX (BIT 0 ENABLES RX DMA)
SPI1->CR2 |= SPI_CR2_SSOE;,BIT 2. ENABLE SS
SPI1->CR2 |= SIZE_8BIT;,"BIT 8,9,10,11. SET TO 0111 FOR 8 BIT"
SPI1->CR2 |= SPI_CR2_FRXTH;,BIT 12. RXNE EVENT IF FIFO >=8BIT
SPI1->CR1 |= SPI_CR1_SPE;,SET 6th BIT TO 1 TO ENABLE SPI
SPI2->CR1 |= SPI_CR1_CPOL;,BIT 1. CPOL = HIGH
SPI2->CR1 |= SPI_CR1_RXONLY;,BIT 10. RX ONLY TURNED ON
SPI2->CR2 |= SPI_CR2_RXDMAEN;,BIT 0. SET TO 1 ACTIVATED RX DMA
SPI1->CR1 |= SPI_SPEED_CLK4;,Set SPI1 clock speed to CLK/4
SPI1->CR1 |= SPI_CR1_CPOL;,BIT 1. CPOL = HIGH
"HAL_RTC_GetTime(&hrtc, &RtcTime, RTC_FORMAT_BIN);",Get RTC time
"HAL_RTC_GetDate(&hrtc, &RtcDate, RTC_FORMAT_BIN);",Get RTC date
"MessageLen = sprintf((char*)Message, ""Date: %02d.%02d.20%02d Time: %02d:%02d:%02d:%02d\n\r"", RtcDate.Date, RtcDate.Month, RtcDate.Year, RtcTime.Hours, RtcTime.Minutes, RtcTime.Seconds, Milliseconds); HAL_UART_Transmit(&huart2, Message, MessageLen, 100);",Format and transmit date/time
"HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR2, ((RtcDate.Date << 8) | (RtcDate.Month)));",Backup date to backup registers
"HAL_RTCEx_BKUPWrite(&hrtc, RTC_BKP_DR3, ((RtcDate.Year << 8) | (RtcDate.WeekDay)));",Backup year and weekday to backup registers
"HAL_SPI_TransmitReceive(&hspi1, &tx_byte, &rx_byte, 1U, 10U);",Transmit and receive SPI data
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE0);,Configure the main internal regulator output voltage
__HAL_RCC_PLL_PLLSOURCE_CONFIG(RCC_PLLSOURCE_HSE);,Macro to configure the PLL clock source
HAL_PWREx_EnableUSBVoltageDetector();,Enable USB Voltage detector
uwPrescalerValue = (uint32_t) ((SystemCoreClock /2) / 10000) - 1;,Compute the prescaler value to have TIM3 counter clock equal to 10 KHz
if(HAL_TIM_Base_Init(&TimHandle) != HAL_OK) { while(1) {} },Initialize TIM3 peripheral
if(HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK) { while(1) {} },Start the TIM Base generation in interrupt mode
BSP_SDRAM_Init();,Initializes the SDRAM device
__HAL_RCC_CRC_CLK_ENABLE();,Enable the CRC Module
GUI_Init();,Init the STemWin GUI Library
GUI_MEMDEV_MULTIBUF_Enable(1);,Set memdev multibuffering
MainTask();,Main GUI task
BSP_Background();,Period elapsed callback in non blocking mode
__HAL_RCC_TIM3_CLK_ENABLE();,TIMx Peripheral clock enable
HAL_NVIC_EnableIRQ(TIM3_IRQn);,Enable the TIMx global Interrupt
HAL_MPU_ConfigRegion(&MPU_InitStruct);,Configure the MPU as Strongly ordered for not defined regions
__HAL_RCC_DCMI_CLK_ENABLE();,DCMI clock enable
__HAL_RCC_GPIOE_CLK_ENABLE();,Enable GPIOE clock
"GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; GPIO_InitStruct.Alternate = GPIO_AF13_DCMI; HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);","DCMI GPIO Configuration for PE4, PE5, PE6"
"__HAL_LINKDMA(dcmiHandle,DMA_Handle,hdma_dcmi_pssi);",Link DMA handle to DCMI
"HAL_NVIC_SetPriority(DCMI_PSSI_IRQn, 0, 0);",Set DCMI interrupt priority
HAL_NVIC_EnableIRQ(DCMI_PSSI_IRQn);,Enable DCMI interrupt
__HAL_RCC_DCMI_CLK_DISABLE();,Peripheral clock disable
"HAL_GPIO_DeInit(GPIOE, GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6);",Deinitialize GPIOE pins
HAL_DMA_DeInit(dcmiHandle->DMA_Handle);,DCMI DMA DeInit
HAL_NVIC_DisableIRQ(DCMI_PSSI_IRQn);,DCMI interrupt Deinit
"if(HAL_DCMI_Start_DMA(&hdcmi, Mode, (uint32_t)pBff, (uint32_t)320*240) != HAL_OK) { return BSP_ERROR_PERIPH_FAILURE; }",Start CAMERA capture with DMA
if(HAL_DCMI_Stop(&hdcmi) != HAL_OK) { ret = BSP_ERROR_PERIPH_FAILURE; },Stop CAMERA capture
if(HAL_DCMI_Suspend(&hdcmi) != HAL_OK) { return BSP_ERROR_PERIPH_FAILURE; },Suspend the CAMERA capture
const gpio_mapping_t gpio_mapping_table[TOTAL_GPIO_NUM] = {...},GPIO mapping table for onboard LEDs
gpio_dev_t brd_gpio_table[] = {...},GPIO device table for onboard LEDs configuration
UART_MAPPING UART_MAPPING_TABLE[] = {...},UART mapping table for standard and AT ports
"void* i2c_mapping_table[] = {I2C1, I2C2, I2C3};",I2C peripheral mapping table
static void stduart_init(void) {...},Initialize standard UART with specified configuration
static void I2C1_init() {...},Initialize I2C bus 1 as master with 100kHz frequency
void stm32_soc_init(void) {...},"Initialize STM32 SoC, including HAL, system clock, SysTick, and GPIO clocks"
void stm32_peripheral_init(void) {...},"Initialize peripherals: UART, GPIO, and I2C"
void SysTick_Handler(void) {...},Handle System tick timer interrupt for kernel interrupt processing
PUTCHAR_PROTOTYPE {...},"Retarget C library printf to UART, adding carriage return before newline"
GETCHAR_PROTOTYPE {...},"Retarget C library scanf to UART, reading a single character"
"int fputc(int ch, FILE *f) {...}","Retarget C library printf to UART1, adding carriage return before newline"
"int _write(int fd, char *ptr, int len) {...}",Retarget write function to transmit data via UART1
void board_init(void) {...},"Initialize board with HAL, system clock, GPIO, and multiple UARTs"
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Configure User push-button
if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET) {...},Check if the system has resumed from IWDG reset
__HAL_RCC_CLEAR_RESET_FLAGS();,Clear reset flags
IwdgHandle.Init.Prescaler = IWDG_PRESCALER_16;,Set IWDG prescaler to 16
IwdgHandle.Init.Reload = (37000 * 762) / (16 * 1000);,Set counter reload value to obtain 762ms IWDG TimeOut
IwdgHandle.Init.Window = (37000 * 400) / (16 * 1000);,Set IWDG window to 400ms
if(HAL_IWDG_Init(&IwdgHandle) != HAL_OK) {...},Initialize IWDG peripheral
if(HAL_IWDG_Refresh(&IwdgHandle) != HAL_OK) {...},Refresh IWDG: reload counter
"LCD_sendCmd(&lcd, 0x80 | (line*0x40 + position));",Change cursor position
"LCD_puts(&lcd, ""Hello World"");",Display text on LCD
ASK25_SPI1_Init();,Initialize SPI
BSP_VCP_Init();,Initialize virtual COM port
ASK25_25AA160A_Write_Status_Reg(0x00);,Write 0x00 to SPI EEPROM status register
ASK25_25AA160A_Read_Status();,Read SPI EEPROM status register
Gate_Init();,Initialize Gate module
Pipe_Init();,Initialize Pipe module
Luos_Loop();,Run Luos framework main loop
Gate_Loop();,Run Gate module main loop
Pipe_Loop();,Run Pipe module main loop
MX_ICACHE_Init();,Initialize instruction cache
MX_LPTIM2_Init();,Initialize LPTIM2 peripheral
if (BSP_LED_Init(LED_RED) != BSP_ERROR_NONE) {...},Configure LED_RED
if (BSP_LED_Init(LED_GREEN) != BSP_ERROR_NONE) {...},Configure LED_GREEN
"if (HAL_LPTIM_Counter_Start_IT(&hlptim2, 1000) != HAL_OK) {...}",Start LPTIM2 counting in interrupt mode with period of 1000
HAL_PWREx_EnterSTOP1Mode(PWR_STOPENTRY_WFI);,Enter Stop mode
void HAL_LPTIM_AutoReloadMatchCallback(LPTIM_HandleTypeDef *hlptim) {...},Autoreload match callback to toggle LED_GREEN
static void MX_ICACHE_Init(void) {...},Enable instruction cache in 1-way (direct mapped cache)
static void MX_LPTIM2_Init(void) {...},"Configure LPTIM2 with APB clock source, no prescaler, and external counter"
MX_CRC_Init();,Initialize CRC peripheral
MX_SPI1_Init();,Initialize SPI1 peripheral
GUI_Init();,Initialize GUI
GUI_SetBkColor(GUI_GREEN);,Set GUI background color to green
GUI_Clear();,Clear GUI display
"exec_calibration(480,272);",Execute touchscreen calibration for 480x272 resolution
X = GUI_TOUCH_GetxPhys();,Get physical X coordinate from touchscreen
Y = GUI_TOUCH_GetyPhys();,Get physical Y coordinate from touchscreen
"GUI_TOUCH_StoreState(X,Y);",Store touchscreen state
value = HAL_ADC_GetValue(&hadc1);,Get ADC conversion value
static void MX_ADC1_Init(void) {...},"Configure ADC1 with continuous conversion mode, 12-bit resolution, and channel 1"
MX_DMA_Init();,Initialize DMA peripheral
MX_SDIO_SD_Init();,Initialize SDIO for SD card
MX_FATFS_Init();,Initialize FATFS for SD card
Keyboard_init();,Initialize keyboard functionality
printf_init();,Initialize printf functionality
"Mount_SD(""/"");",Mount SD card filesystem
Format_SD();,Format SD card
Check_SD_Space();,Check available space on SD card
"Update_File(""FILE1.TXT"", buffer);",Update contents of FILE1.TXT with buffer data
"Unmount_SD(""/"");",Unmount SD card filesystem
UsbClassSwitch_setClass(USB_MSC_CLASS);,Switch USB class to Mass Storage Class
UsbClassSwitch_setClass(USB_HID_CLASS);,Switch USB class to HID Class
"Keyboard_write(""Hello World!\n\r"");",Write string to keyboard output
"PUTCHAR_PROTOTYPE{    HAL_UART_Transmit(&huart1, (uint8_t *) &ch, 1, 0xFFFF);    return ch;}",Retargets the C library printf function to the USART.
"printf(""========== Starting Blitz V2 ==========\r\n"");",Prints startup message for Blitz V2.
init_buzzer();,Initialize buzzer.
//init_motors();,Initialize motors (commented out).
"printf(""\t- Initialization complete\r\n"");",Prints initialization completion message.
"printf(""\t- Hot glue secured\r\n"");",Prints hot glue secured message.
"printf(""\t- BÃP kablar anchored\r\n"");",Prints BÃP cables anchored message.
"printf(""========== Startup COMPLETE ==========\r\n"");",Prints startup completion message.
"printf(""\r\n\r\n========== RUN TESTS ==========\r\n"");",Prints test run start message.
"printf(""\t- Buzzer"");",Prints buzzer test message.
while (1) {    test_buzzer();    //test_motors();},Infinite loop to run buzzer and motor tests (motor test commented out).
__HAL_RCC_PWR_CLK_ENABLE();,Enable Power Control clock.
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage.
void stm32_peripheral_init(void) {    /*default uart init*/    stduart_init();},"Initialize peripherals, specifically default UART."
static void stduart_init(void) {    uart_0.port = PORT_UART_STD;    uart_0.config.baud_rate = STDIO_UART_BUADRATE;    uart_0.config.data_width = DATA_WIDTH_8BIT;    uart_0.config.flow_control = FLOW_CONTROL_DISABLED;    uart_0.config.mode = MODE_TX_RX;    uart_0.config.parity = NO_PARITY;    uart_0.config.stop_bits = STOP_BITS_1;    hal_uart_init(&uart_0);},Initialize standard UART with specified configuration.
"PUTCHAR_PROTOTYPE {    if (ch == '\n') {        hal_uart_send(&uart_0, (void *)""\r"", 1, 30000);    }    hal_uart_send(&uart_0, &ch, 1, 30000);    return ch;}",Retargets the C library printf function to the USART.
MX_FREERTOS_Init();,Call init function for freertos objects (in freertos.c).
osKernelStart();,Start scheduler.
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure the Systick interrupt time.
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Configure the Systick.
"HAL_NVIC_SetPriority(USART1_IRQn, 5, 0);",USART1_IRQn interrupt configuration.
"HAL_NVIC_SetPriority(TIM6_IRQn, 5, 0);",TIM6_IRQn interrupt configuration.
HAL_NVIC_EnableIRQ(TIM6_IRQn);,TIM6_IRQn interrupt configuration.
Luos_Init();,Initialize Luos engine.
Pipe_Init();,Initialize Pipe module.
Gate_Init();,Initialize Gate module.
Button_Init();,Initialize Button module.
while (1) {    Luos_Loop();    Pipe_Loop();    Gate_Loop();    Button_Loop();},"Infinite loop to run Luos, Pipe, Gate, and Button loops."
__HAL_RCC_PWR_CLK_ENABLE();,Configure the main internal regulator output voltage.
"eeprom_write_buf(10U, (uint8_t *)""pete and bert"", 13U);","Write ""pete and bert"" to EEPROM at address 10."
"eeprom_read_buf(10U, buf, 13U);",Read 13 bytes from EEPROM at address 10 into buffer.
hi2c1.Instance = I2C1;    hi2c1.Init.ClockSpeed = 100000;    hi2c1.Init.DutyCycle = I2C_DUTYCYCLE_2;    hi2c1.Init.OwnAddress1 = 0;    hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;    hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;    hi2c1.Init.OwnAddress2 = 0;    hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;    hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;,I2C1 Initialization Function.
shell_uart_init(115200);,Initialize shell UART with 115200 baud rate.
link_test();,Run link test task.
CPU_CACHE_Enable();,Enable the CPU Cache.
BSP_LED_Init(LED1);,Configure LED1.
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Configure User push-button.
while (1) {    HAL_Delay(1000);    BSP_LED_Toggle(LED1);},"Insert a Delay of 1000 ms and toggle LED1, in an infinite loop."
if(GPIO_Pin == USER_BUTTON_PIN) {    if (uwIncrementState == 0) {        HAL_SuspendTick();        uwIncrementState = 1;    } else {        HAL_ResumeTick();        uwIncrementState = 0;    }},EXTI line detection callback for user button to suspend/resume tick increment.
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency.
HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 216 MHz Frequency.
"while (1) {    HAL_GPIO_TogglePin(led_GPIO_Port, led_Pin);    HAL_Delay(250);}",Infinite loop to toggle LED with 250ms delay.
CommsN64Console_Init();,Initialize N64 console communication.
Main_Init();,Initialize main module.
CommsN64Console_SetPullup(N64_PULLUP);,Apply a pullup on n64 data line.
HAL_Delay(100);,Give some delay for initialization.
CommsN64Console_GetContollerInputs();,Poll for n64 controller state.
CommsN64Console_ParseContollerInputs();,Parse inputs from controller.
Main_SetRegisters();,Update registers for BBG control board.
"void Main_SetBlueLed(GPIO_PinState pinState) {    HAL_GPIO_WritePin(BLUE_LED_PORT, BLUE_LED_PIN_HAL, pinState);}",Set blue LED state.
"void Main_Init() {    __HAL_RCC_GPIOH_CLK_ENABLE();    __HAL_RCC_GPIOA_CLK_ENABLE();    GPIO_InitTypeDef GPIO_InitStruct_Main = {0};    GPIO_InitStruct_Main.Pin = GPIO_PIN_8;    GPIO_InitStruct_Main.Mode = GPIO_MODE_AF_PP;    GPIO_InitStruct_Main.Pull = GPIO_NOPULL;    GPIO_InitStruct_Main.Speed = GPIO_SPEED_FREQ_LOW;    GPIO_InitStruct_Main.Alternate = GPIO_AF0_MCO;    /* Only enable below if you want to check the clock * frequency. */    //HAL_GPIO_Init(GPIOA, &GPIO_InitStruct_Main);    __HAL_RCC_GPIOC_CLK_ENABLE();    GPIO_InitStruct_Main.Pin = BLUE_LED_PIN_HAL;    GPIO_InitStruct_Main.Mode = GPIO_MODE_OUTPUT_PP;    GPIO_InitStruct_Main.Pull = GPIO_NOPULL;    GPIO_InitStruct_Main.Speed = GPIO_SPEED_FREQ_LOW;    HAL_GPIO_Init(BLUE_LED_PORT, &GPIO_InitStruct_Main);    Main_SetBlueLed(BLUE_LED_ON);}","Initialize GPIO for clock output and blue LED, keep LED on to indicate program running."
__HAL_RCC_GPIOC_CLK_ENABLE();,Initialize the blue led.
Main_SetBlueLed(BLUE_LED_ON);,Keep the blue LED on to show the program is running.
"trace_printf(""Hello\n"");",Print hello message.
"BSP_DAC_Init(DAC_CHANNEL_2, DAC_TRIGGER_SOFTWARE);",Initialize and Start DAC conversion.
BSP_DAC_TriangularWave(DAC_CHANNEL_2);,Generate triangular wave on DAC channel 2.
hdac_bsp.Instance->SWTRIGR = DAC_SWTRIGR_SWTRIG2;,Trigger DAC conversion for channel 2.
__PWR_CLK_ENABLE();,Enable power control clock.
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure voltage scaling for power optimization.
"static void Init_Light(void) { GPIO_InitTypeDef GPIO_InitStruct; SC1_Light_GPIO_CLK_ENABLE(); HAL_GPIO_WritePin(SC1_Light_GPIO_Port, SC1_Light_Pin, GPIO_PIN_RESET); GPIO_InitStruct.Pin = SC1_Light_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(SC1_Light_GPIO_Port, &GPIO_InitStruct); }",Configure GPIO pin Output Level
BSP_LED_Init(LED1);,Configure LED1 and LED2
while (1) { BSP_LED_Toggle(LED1); HAL_Delay(100); },Toggle LED1
QSPI_Info flashInfo;,to get info about the SPI NOR flash chip
BSP_QSPI_GetInfo(&flashInfo);,display info about the SPI NOR flash chip
BSP_LED_Init(LED_RED);,Initialize BSP Led for LED1 and LED2
BSP_LED_Init(LED_GREEN);,Initialize BSP Led for LED1 and LED2
"osThreadDef(Start, MainThread, osPriorityHigh, 0, configMINIMAL_STACK_SIZE * 2);",Init thread
"osThreadCreate (osThread(Start), NULL);",Init thread
"static void MainThread(void const * argument) { UNUSED(argument); #ifdef USE_LCD LCD_UsrLog(""\r\n Starting Main Thread...\n""); #endif osThreadDef(Client, SSL_Client, osPriorityHigh, 0, configMINIMAL_STACK_SIZE * 20); osThreadCreate (osThread(Client), NULL); for( ;; ) { osThreadTerminate(NULL); } }",Start Thread
"USBD_RegisterClass(&USBD_Device, USBD_AUDIO_CLASS);",Add Supported Class
"USBD_AUDIO_RegisterInterface(&USBD_Device, &USBD_AUDIO_fops);",Add Interface callbacks for AUDIO Class
void Toggle_Leds(void) { static __IO uint32_t ticks; if(ticks++ == 0xfffff) { BSP_LED_Toggle(LED1); BSP_LED_Toggle(LED3); ticks = 0; } },Toggle LEDs to show user input state.
LED2_GPIO_CLK_ENABLE();,Enable GPIO Clock (to be able to program the configuration registers)
"GPIO_InitStruct.Mode  = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull  = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Pin = LED2_PIN; HAL_GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive safe LEDs
"while (1) { HAL_GPIO_TogglePin(LED2_GPIO_PORT, LED2_PIN); HAL_Delay(100); }",Toggle IO in an infinite loop
"bool gpioInit(void) { bool ret = true; __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOC_CLK_ENABLE(); for (int i=0; i<GPIO_MAX_CH; i++) { gpioPinMode(i, gpio_tbl[i].mode); gpioPinWrite(i, gpio_tbl[i].init_value); } #ifdef _USE_HW_CLI cliAdd(""gpio"", cliGpio); #endif return ret; }",Initialize GPIO pins
"bool gpioPinMode(uint8_t ch, uint8_t mode) { bool ret = true; GPIO_InitTypeDef GPIO_InitStruct = {0}; if (ch >= GPIO_MAX_CH) { return false; } switch(mode) { case _DEF_INPUT: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_INPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_INPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; case _DEF_OUTPUT: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; break; case _DEF_OUTPUT_PULLUP: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; break; case _DEF_OUTPUT_PULLDOWN: GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLDOWN; break; } GPIO_InitStruct.Pin = gpio_tbl[ch].pin; HAL_GPIO_Init(gpio_tbl[ch].port, &GPIO_InitStruct); return ret; }",Set GPIO pin mode
"uint8_t gpioPinRead(uint8_t ch) { uint8_t ret = _DEF_LOW; if (ch >= GPIO_MAX_CH) { return false; } if (HAL_GPIO_ReadPin(gpio_tbl[ch].port, gpio_tbl[ch].pin) == gpio_tbl[ch].on_state) { ret = _DEF_HIGH; } return ret; }",Read from GPIO pin
"if (args->argc == 2 && args->isStr(0, ""read"") == true) { uint8_t ch; ch = (uint8_t)args->getData(1); while(cliKeepLoop()) { cliPrintf(""gpio read %d : %d\n"", ch, gpioPinRead(ch)); delay(100); } ret = true; }",Read specific GPIO pin
"if (args->argc == 3 && args->isStr(0, ""write"") == true) { uint8_t ch; uint8_t data; ch = (uint8_t)args->getData(1); data = (uint8_t)args->getData(2); gpioPinWrite(ch, data); cliPrintf(""gpio write %d : %d\n"", ch, data); ret = true; }",Write to specific GPIO pin
in.coefSign =        prime256v1_A_sign;,Set input parameters
in.modulus =         prime256v1_Prime;,Set input parameters
"if (memcmp(out.RSign, SigGen_R, SigGen_R_len) != 0) { Error_Handler(); }",Compare to expected result
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE0) != HAL_OK) { Error_Handler(); },Configure the main internal regulator output voltage
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
static void MX_ICACHE_Init(void) {...},ICACHE Initialization Function
if (HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK) { Error_Handler(); },Enable instruction cache in 1-way (direct mapped cache)
if (HAL_ICACHE_Enable() != HAL_OK) { Error_Handler(); },Enable instruction cache in 1-way (direct mapped cache)
static void MX_PKA_Init(void) {...},PKA Initialization Function
hpka.Instance = PKA; if (HAL_PKA_Init(&hpka) != HAL_OK) { Error_Handler(); },PKA Initialization Function
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_I2C1; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks
ssd1306_Init();,Initialize SSD1306 display
ssd1306_Fill(Black);,Fill display with black
"ssd1306_SetCursor(31, 18);",Set cursor position for text
"ssd1306_WriteString(""YEA"", Font_11x18, White);","Write ""YEA"" to display"
"ssd1306_SetCursor(75, 18);",Set cursor position for text
"ssd1306_WriteString(""!"", Font_16x26, White);","Write ""!"" to display"
ssd1306_UpdateScreen();,Update display with changes
"HAL_GPIO_TogglePin(GPIOB,GPIO_PIN_3);",Toggle GPIO pin PB3
HAL_Delay(500);,Delay for 500ms
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK) { Error_Handler(); },Configure the main internal regulator output voltage
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks
"if (HAL_GPIO_ReadPin(KeyButton_GPIO_Port, KeyButton_Pin) == GPIO_PIN_RESET) { HAL_GPIO_TogglePin(LedBlue_GPIO_Port, LedBlue_Pin); HAL_Delay(100); }",Toggle blue LED when key button is pressed
static void MX_GPIO_Init(void) {...},GPIO Initialization Function
"HAL_GPIO_WritePin(LedBlue_GPIO_Port, LedBlue_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = LedBlue_Pin; ... HAL_GPIO_Init(LedBlue_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LedBlue_Pin
"GPIO_InitStruct.Pin = KeyButton_Pin; ... HAL_GPIO_Init(KeyButton_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : KeyButton_Pin
"HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12|GPIO_PIN_13, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(GPIOE, GPIO_PIN_0|GPIO_PIN_1, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; ... HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : PB0 PB1
"GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13; ... HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);",Configure GPIO pins : PD12 PD13
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1; ... HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);",Configure GPIO pins : PE0 PE1
"if (low_voltage) { HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_7); HAL_Delay(500); }",Toggle LED if low voltage detected
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&rccOscInit) != HAL_OK) { Error_Handler(); },Configure HSE and PLL
"rccClkInit.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if (HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Configure SYSCLK, HCLK, PCLK1, and PCLK2"
void GPIO_Output_Config(void) {...},"GPIO configuration: GPIO = GPIOB, Pin = PB6, PB7, PB8, PB9, Mode = Output push-pull, Speed = Low"
"gpioInit.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9; ... HAL_GPIO_Init(GPIOB, &gpioInit);",Configure GPIO
void PWR_Config(void) {...},"PWR configuration: PVD level = 2.7 V (level 5), PVD mode = Interrupt rising falling"
__HAL_RCC_PWR_CLK_ENABLE();,Configure RCC peripheral
pwrPvdInit.PVDLevel = PWR_PVDLEVEL_5; pwrPvdInit.Mode = PWR_PVD_MODE_IT_RISING_FALLING; HAL_PWR_ConfigPVD(&pwrPvdInit); HAL_PWR_EnablePVD();,Configure PWR
void HAL_PWR_PVDCallback(void) { low_voltage = (low_voltage + 1) % 2; },"Update ""toggle"" global variable so that LED blinks when the voltage is below the target threshold."
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK) { while(1); },Configure PLL: PLLCLK = (HSI / 2) * PLLMUL = (8 / 2) * 16 = 64 MHz
"clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if (HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2)!= HAL_OK) { while(1); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
CAN1_Init();,Init. CAN1 peripheral
CAN_Filter_Config();,Filter config.
"HAL_CAN_ActivateNotification(&hcan1, CAN_IT_TX_MAILBOX_EMPTY | CAN_IT_RX_FIFO0_MSG_PENDING | CAN_IT_BUSOFF);",Enable interrupt from the CAN peripheral side
HAL_CAN_Start(&hcan1);,Move CAN from init. mode to normal mode
void CAN_Filter_Config(void) {...},Configure filter to accept all messages
void SystemClock_Config_HSE(uint8_t clock_freq) {...},Configure system clock with HSE
switch(clock_freq) { case SYS_CLOCK_FREQ_50_MHZ: ... case SYS_CLOCK_FREQ_120_MHZ: ... default: return; },Configurations that depend on clock_freq
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Systick
"PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Configure peripheral clocks
static void MX_USART2_UART_Init(void) {...},USART2 init function
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_8, GPIO_PIN_SET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_8; ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pin : PA8
SEGGER_RTT_Init();,Initialize SEGGER RTT
SEGGER_RTT_SetTerminal(0);,Set RTT terminal
HAL_Delay(10);,Delay 10ms
HAL_TIM_Base_Start_IT(&htim1);,Start TIM1 with interrupts
HAL_Delay(100);,Delay 100ms
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);",Toggle LED pin
"if(HAL_GPIO_ReadPin(SWITCH_GPIO_Port, SWITCH_Pin)) HAL_Delay(100); else HAL_Delay(500);",Change delay based on switch state
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"GPIO_InitStruct.Pin = LED_Pin; ... HAL_GPIO_Init(LED_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LED_Pin
"GPIO_InitStruct.Pin = SWITCH_Pin; ... HAL_GPIO_Init(SWITCH_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : SWITCH_Pin
float nt_sqrt(float x) { float sq = x; for (int i = 0; i < 50; ++i) { sq = (x / sq + sq) / 2; } return sq; },Calculate square root using Newton's method
oled_init();,Initialize OLED display
"oprintf(0, ""sqrt(2)=%.6f"", nt_sqrt(2));",Display square root of 2 on OLED
"oprintf(1, ""sqrt(3)=%.6f"", nt_sqrt(3));",Display square root of 3 on OLED
"oprintf(2, ""sin(60)=%.6f"", arm_sin_f32(PI/3));",Display sine of 60 degrees on OLED
"oprintf(3, ""cos(60)=%.6f"", arm_cos_f32(PI/3));",Display cosine of 60 degrees on OLED
"HAL_GPIO_TogglePin(LED2_GPIO_Port, LED2_Pin); HAL_GPIO_TogglePin(LED3_GPIO_Port, LED3_Pin);",Toggle LED2 and LED3
HAL_Delay(2000);,Delay for 2000ms
__HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
MX_X_CUBE_SUBG2_Process();,Process SUBG2 application tasks
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_4, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_7, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_0; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC0
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_4|GPIO_PIN_8; ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : PA0 PA1 PA4 PA8
"GPIO_InitStruct.Pin = USART_TX_Pin|USART_RX_Pin; ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : USART_TX_Pin USART_RX_Pin
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_4; ... HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : PB0 PB4
"GPIO_InitStruct.Pin = GPIO_PIN_7; ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC7
"HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);",EXTI interrupt init
GPIOA->ODR &= ~(1 << 4);,Clear GPIOA pin 4 (chip select)
"HAL_SPI_TransmitReceive(&hspi1, PSX_TX, PSX_RX, 8, 10);",Transmit and receive SPI data for PSX controller
GPIOA->ODR |= (1 << 4);,Set GPIOA pin 4 (chip select)
__HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE3);,Configure the main internal regulator output voltage
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"HAL_GPIO_WritePin(USB_PowerSwitchOn_GPIO_Port, USB_PowerSwitchOn_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = USER_Btn_Pin; ... HAL_GPIO_Init(USER_Btn_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : USER_Btn_Pin
"GPIO_InitStruct.Pin = USB_PowerSwitchOn_Pin; ... HAL_GPIO_Init(USB_PowerSwitchOn_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : USB_PowerSwitchOn_Pin
"GPIO_InitStruct.Pin = USB_OverCurrent_Pin; ... HAL_GPIO_Init(USB_OverCurrent_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : USB_OverCurrent_Pin
RN4020_Init();,Initialize RN4020 Bluetooth module
RN4020_Process();,Process RN4020 Bluetooth module tasks
"int _write(int file, char *ptr, int len) { HAL_UART_Transmit(&huart2, (uint8_t *) ptr, (uint16_t) len, 0xFFFFFFFF); return len; }",Override _write function to use USART2 for debugging
__HAL_RCC_PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,Configure the main internal regulator output voltage
uart_0.port = STDIO_UART; ... hal_uart_init(&uart_0);,Initialize UART
hal_i2c_init(&brd_i2c1_dev); hal_i2c_init(&brd_i2c2_dev);,Initialize I2C peripherals
void SysTick_Handler(void) { HAL_IncTick(); krhino_intrpt_enter(); krhino_tick_proc(); krhino_intrpt_exit(); },This function handles System tick timer.
"PUTCHAR_PROTOTYPE { if (ch == '\n') { hal_uart_send(&uart_0, (void *)""\r"", 1, 30000); } hal_uart_send(&uart_0, &ch, 1, 30000); return ch; }",Retargets the C library printf function to the USART.
"GETCHAR_PROTOTYPE { uint8_t ch = EOF; int32_t ret = -1; uint32_t recv_size; ret = hal_uart_recv_II(&uart_0, &ch, 1, &recv_size, HAL_WAIT_FOREVER); if (ret == 0) { return ch; } else { return -1; } }",Retargets the C library scanf function to the USART.
"int _write(int file, char *ptr, int len) { int DataIdx; for (DataIdx = 0; DataIdx < len; DataIdx++) { ITM_SendChar( *ptr++ ); } return len; }",Redirect _write to send characters via ITM
"void print_string(char* str) { _write(0, str, strlen(str)); }",Print string via ITM
"print_string(""Test string\r\n"");",Print test string
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1; PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Initializes the peripherals clocks
hlpuart1.Instance = LPUART1; ... if (HAL_UART_Init(&hlpuart1) != HAL_OK) { Error_Handler(); },Initialize LPUART1
"if (HAL_UARTEx_SetTxFifoThreshold(&hlpuart1, UART_TXFIFO_THRESHOLD_1_8) != HAL_OK) { Error_Handler(); }",Set LPUART1 TX FIFO threshold
"if (HAL_UARTEx_SetRxFifoThreshold(&hlpuart1, UART_RXFIFO_THRESHOLD_1_8) != HAL_OK) { Error_Handler(); }",Set LPUART1 RX FIFO threshold
if (HAL_UARTEx_DisableFifoMode(&hlpuart1) != HAL_OK) { Error_Handler(); },Disable LPUART1 FIFO mode
"GPIO_InitStruct.Pin = B1_Pin; ... HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : B1_Pin
"GPIO_InitStruct.Pin = LD2_Pin; ... HAL_GPIO_Init(LD2_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : LD2_Pin
BSP_LED_Init(LED_OK); BSP_LED_Init(LED_ERROR);,Configure LED_OK and LED_ERROR
BSP_SD_Init(0);,Initialize the micro SD Card
ProcessStatus = MX_FATFS_Process();,Call middleware background task
if (ProcessStatus == APP_SD_UNPLUGGED) { BSP_LED_Off(LED_OK); BSP_LED_Toggle(LED_ERROR); HAL_Delay(200); },Handle SD card unplugged state
else if (ProcessStatus == APP_ERROR) { Error_Handler(); },Handle error state
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_SDMMC1; PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLL; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks
hsd->Instance = SDMMC1; ... if(HAL_SD_Init(hsd) != HAL_OK) { return HAL_ERROR; },Initialize SDMMC1
if (HAL_ICACHE_Enable() != HAL_OK) { Error_Handler(); },Enable instruction cache
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
huart2.Instance = USART2; ... if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); },Initialize USART2
"if(HAL_GPIO_ReadPin(LCD_BTN_5_YES_GPIO_Port, LCD_BTN_5_YES_Pin) == GPIO_PIN_RESET) { HAL_GPIO_WritePin(USR_LED_GPIO_Port, USR_LED_Pin, GPIO_PIN_RESET); } else { HAL_GPIO_WritePin(USR_LED_GPIO_Port, USR_LED_Pin, GPIO_PIN_SET); }",Control LED based on button press
HAL_PWR_EnableBkUpAccess(); __HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);,Configure LSE Drive Capability
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_LSE|RCC_OSCILLATORTYPE_HSI48; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USB; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks
MPU_AccessPermConfig();,Configure access permissions for MPU (conditionally compiled)
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { while(1) {}; },"Enable HSE Oscillator and activate PLL with HSE as source Note: Since there is no oscillator on board, HSE clock is derived from STLink"
if(HAL_PWREx_EnableOverDrive() != HAL_OK) { while(1) {}; },Activate the OverDrive to reach the 216 Mhz Frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | ... ); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { while(1) {}; }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
static void CPU_CACHE_Enable(void) { ... },CPU L1-Cache enable
HAL_EnableDBGStopMode();,Enable debug stop mode
RadioShieldLedInit(RADIO_SHIELD_LED);,Initialize radio shield LED
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Initialize user button with EXTI mode
USARTConfig();,Configure USART
RTC_Config();,Initialize RTC
RTC_TimeStampConfig();,Configure RTC timestamp
Stack_6LoWPAN_Init();,Initialize 6LoWPAN stack
while(1) { int r = 0; do { r = process_run(); } while(r > 0); },Run Contiki process loop
#define PeriodValue (uint32_t) (100 -1),Set the Maximum value of the counter (Auto-Reload) that defines the Period
#define PulseValue (uint32_t) (50 -1),Set the Compare value that defines the duty cycle
"if (BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_EXTI) != BSP_ERROR_NONE) { Error_Handler(); }",BUTTON_WAKEUP (External line 13) will be used to wakeup the system from Stop 2 mode
"if (HAL_LPTIM_PWM_Start(&hlptim1, PeriodValue, PulseValue) != HAL_OK) { Error_Handler(); }",Start generating the PWM signal
if (HAL_LPTIM_PWM_Stop(&hlptim1) != HAL_OK) { Error_Handler(); },Stop counting when leaving Stop mode
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) { ... },Callback for timer input capture
if (htim->Channel == HAL_TIM_ACTIVE_CHANNEL_1) { ... },check if this callback is for channel 1
"timer_value = HAL_TIM_ReadCapturedValue(htim, TIM_CHANNEL_1);",read the rimer value at capture
if (!first_value) { ... },if first time round we don't have a previous value so don't do calculation
if (timer_value > previous_timer_value) { difference = timer_value - previous_timer_value; } else { difference = ((0xffff - previous_timer_value) + timer_value) + 1U; },work out difference between 2 subsequent captures; don't know which one will be bigger because of possible rollover
clock_frequency = HAL_RCC_GetPCLK1Freq() / clock_divider;,get the capture clock frequency and apply divider
if (difference != 0U) { pin_frequency = clock_frequency / difference; (void)pin_frequency; },calculate the frequency on capture pin using clock frquenct and captured values difference
previous_timer_value = timer_value; first_value = false;,cache the latest capture value for next time
"HAL_TIM_IC_Start_IT(&htim2, TIM_CHANNEL_1);",Start timer input capture with interrupts
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Configure User push-button
HAL_Delay(1000);,Insert a 1s delay
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { ... },EXTI line detection callback
if(GPIO_Pin == USER_BUTTON_PIN) { ... },Check if the callback is triggered by the user button
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
ret = HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 216 MHz Frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | ... ); ... ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
MPU_InitStruct.Enable = MPU_REGION_ENABLE; ... HAL_MPU_ConfigRegion(&MPU_InitStruct);,Configure the MPU as Strongly ordered for not defined regions
uint8_t rxData[5]={0};,RX data buffer
"printf(""USB CDC Program\n"");",Print program start message
"CDC_Transmit_FS(""Hello\n"", 6);",Send 6 bytes via USB
"printf(""%s\n"", rxData);",Print received USB data
delay_ms(1000);,Delay for 1 second
void delay_ms(unsigned long x) { ... },Delay milliseconds function
MX_USART2_UART_Init();,Initialize USART2
"HAL_TIM_Encoder_Start(&htim1, htim1.Channel);",Start timer encoder
sct_value(__HAL_TIM_GET_COUNTER(&htim1));,Display encoder counter value on segment display
HAL_Delay(50);,Delay for 50ms
"HAL_GPIO_WritePin(GPIOB,GPIO_PIN_5,GPIO_PIN_SET);",Set GPIO pin high
halInit();,Initialize HAL
InitBootClipboard();,Init boot clipboard
if (!IsToRemainInBooter()) { ... },Check if there is a request to remain on nanoBooter
if (CheckValidCLRImage((uint32_t)&__deployment_start__)) { LaunchCLR((uint32_t)&__deployment_start__); },Check for valid CLR image and launch nanoCLR if valid
void tx_application_define(void *first_unused_memory) { ... },ThreadX application definition
"tx_byte_pool_create(&byte_pool_0, ""byte pool 0"", memory_area, DEFAULT_BYTE_POOL_SIZE);",Create a byte memory pool from which to allocate the thread stacks
"sdStart(&SERIAL_DRIVER, NULL);",Starts the serial driver
BlockStorageList_Initialize(); BlockStorage_AddDevices();,Initialize block storage list and devices
ConfigurationManager_Initialize();,Initialize configuration manager
ReportSuccessfullNanoBooter();,Report successful nanoBooter execution
void BlinkThread_entry(uint32_t parameter) { ... },Blink thread entry function
"palTogglePad(GPIOB, GPIOB_LD2);",Toggle LED pin
tx_thread_sleep(TX_TICKS_PER_MILLISEC(500));,Sleep for 500ms
MX_ADC1_Init();,Initialize ADC1
thunderpack_clock_init();,Configure the system clock
gpio_init();,Setup GPIO & Serial/USB
MX_USB_DEVICE_Init();,Setup GPIO & Serial/USB
"buf[0] = btnState + '0'; CDC_Transmit_FS(buf, 3);",Convert to character and output to serial console
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_4; ... HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Button - PB4
"osThreadDef(MailProducer, MailProducerTask, osPriorityNormal, 0, 128); MailProducerHandle = osThreadCreate(osThread(MailProducer), NULL);",definition and creation of MailProducer
"HAL_GPIO_WritePin(GPIOC, P_0_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
hlpuart1.Instance = LPUART1; ... if (HAL_UART_Init(&hlpuart1) != HAL_OK) { Error_Handler(); },LPUART1 Initialization
"HAL_GPIO_WritePin(GPIOA, LD2_Pin|P_3_Pin|P_2_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = LD2_Pin|P_3_Pin|P_2_Pin; ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : LD2_Pin P_3_Pin P_2_Pin
"GPIO_InitStruct.Pin = P_1_Pin|P_0_Pin; ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pins : P_1_Pin P_0_Pin
SystemClockConfig();,Configure the system clock to 180 MHz
UART2_Init();,High level initialization
"sConfig.Channel = ADC_CHANNEL_1; ... if(HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK) { Error_Handler(); }",Configure for the selected ADC regular channel its corresponding rank in the sequence and its sample time
rawValue = HAL_ADC_GetValue(&hadc1);,Get ADC raw value after conversion
"sprintf(msg, ""rawValue: %hu\r\n"", rawValue); HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);",Print raw value in UART
"sprintf(msg, ""Temperature: %.2f\r\n"", temp); HAL_UART_Transmit(&huart2, (uint8_t*) msg, strlen(msg), HAL_MAX_DELAY);",Print temperature value in UART
huart2.Instance = USART2; ... if(HAL_UART_Init(&huart2) != HAL_OK){ Error_Handler(); },Initialize USART2
LL_FLASH_SetLatency(LL_FLASH_LATENCY_3);,Set Flash latency
LL_PWR_SetRegulVoltageScaling(LL_PWR_REGU_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage
LL_RCC_HSI_Enable();,Enable HSI oscillator
"LL_RCC_PLL_ConfigDomain_SYS(LL_RCC_PLLSOURCE_HSI, LL_RCC_PLLM_DIV_16, 192, LL_RCC_PLLP_DIV_2);",Configure PLL for system clock
LL_RCC_SetSysClkSource(LL_RCC_SYS_CLKSOURCE_PLL);,Set PLL as system clock source
LL_Init1msTick(96000000);,Initialize 1ms tick
LL_SetSystemCoreClock(96000000);,Set system core clock
LL_RCC_SetTIMPrescaler(LL_RCC_TIM_PRESCALER_TWICE);,Set TIM prescaler
"NVIC_SetPriority(SysTick_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),15, 0));",SysTick_IRQn interrupt configuration
CrcHandle.Instance = CRC; if(HAL_CRC_Init(&CrcHandle) != HAL_OK) { Error_Handler(); },Configure the CRC peripheral
if(uwCRCValue != uwExpectedCRCValue) { Error_Handler(); } else { BSP_LED_On(LED1); },Compare the CRC value to the Expected one
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
HAL_IncTick();,System tick timer
"tos_knl_irq_enter(); ... HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1); ... res_sd = f_mount(&fs, ""0:"", 1); ... if (screen_shot(0, 0, LCD_X_LENGTH, LCD_Y_LENGTH, name) == 0) { printf(""Photo taken\r\n""); } ... tos_knl_irq_leave();",Handle EXTI line0 interrupt for photo capture
"tos_knl_irq_enter(); ... flag_take_photo = 0; flag_server_connect = 0; temp_label_state = 1; printf(""Key cap pressed\r\n""); ... tos_knl_irq_leave();",Handle EXTI line1 interrupt for key press
tos_knl_irq_enter(); ... HAL_TIM_IRQHandler(&htim2); ... tos_knl_irq_leave();,Handle TIM2 global interrupt
tos_knl_irq_enter(); ... HAL_UART_IRQHandler(&huart3); ... tos_knl_irq_leave();,Handle USART3 global interrupt
tos_knl_irq_enter(); ... HAL_SD_IRQHandler(&hsd); ... tos_knl_irq_leave();,Handle SDIO global interrupt
"UART_RxAgain(&huart3, (uint8_t *)recv_buffer, sizeof(recv_buffer)); tos_at_uart_input_byte(recv_buffer[0]);",Process received UART byte
USB_IRQHandler(void) { tud_int_handler(0); },Forward USB interrupt events to TinyUSB IRQ Handler
"GPIO_InitStruct.Pin = LED_PIN; ... HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);",LED
"HAL_GPIO_WritePin(LED_PORT, LED_PIN, state ? LED_STATE_ON : (1-LED_STATE_ON));",Control LED state
"return BUTTON_STATE_ACTIVE == HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN);",Read button state
system_ticks++;,Increment system ticks
SystemClk_Config();,Configure the system clock
uart_0.port = 0; ... hal_uart_init(&uart_0);,Configure UART parameters and initialize
PUTCHAR_PROTOTYPE { ... },Retargets the C library printf function to the USART
GETCHAR_PROTOTYPE { ... },Retargets the C library scanf function to the USART
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_I2C1; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clocks for USART1 and I2C1
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { ... },Period elapsed callback in non blocking mode
if (htim->Instance == TIM1) { HAL_IncTick(); },"Increment a global variable ""uwTick"" used as application time base"
build_font_index();,Initialize font index for display
display_init();,Initialize display
uart_init();,Initialize UART
timer_init();,Initialize timer
input_init();,Initialize input handling
gen_note_table();,Generate note table for audio synthesis
synth_start();,Start audio synthesizer
ui_init();,Initialize user interface
__HAL_PWR_OVERDRIVE_ENABLE();,Enable OverDrive mode for high frequency
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure voltage scaling for maximum performance
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure HSE oscillator and PLL
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | ... ); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);",Select PLL as system clock and configure clock dividers
RealMain();,Call the main application function
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | ... ; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure ADC peripheral clock
void SystemInit(void) { ... },"Setup the microcontroller system. Initialize the Embedded Flash Interface, the PLL and update the SystemFrequency variable"
SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));,Set CP10 and CP11 Full Access for FPU
RCC->CFGR = 0x00000000;,Reset CFGR register
RCC->CR &= (uint32_t)0xFEF6FFFF;,"Reset HSEON, CSSON and PLLON bits"
RCC->PLLCFGR = 0x24003010;,Reset PLLCFGR register
SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET;,Configure the Vector Table location add offset address
void SystemCoreClockUpdate(void) { ... },Update SystemCoreClock variable according to Clock Register Values
BSP_GPIO_Enable();,Activation des pÃ©riphÃ©riques GPIO
SYS_ClockConfig();,Configuration des horloges
Systick_add_callback_function(&process_ms);,ajoute la fonction process_ms Ã  la liste des fonctions Ã  appeler Ã  chaque ms
"BSP_GPIO_PinCfg(GPIOB, GPIO_PIN_12,GPIO_MODE_OUTPUT_PP,GPIO_PULLUP,GPIO_SPEED_FREQ_HIGH); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, 1);",Initialisation des pins Enable des haut-parleurs
"UART_init(UART2_ID,9600);","L'UART 2 est connectÃ© au bluetooth de controle, afin de recevoir les informations du tÃ©lÃ©phone"
"UART_init(UART1_ID,9600);","L'UART 1 n'est finalement pas utilisÃ©, il est connectÃ© au module bluetooth audio"
LED_MATRIX_init();,On initialise le ruban de LEDs
void gps(void) { ... },RÃ©cÃ©ption des donÃ©es GPS et traiement pour Ãªtre envoyÃ©es au tÃ©lÃ©phone
void process_ms(void) { ... },Fonction appelÃ©e toutes les milisecondes. Elle gÃ¨re le clignottement et l'allumage des led
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | ... ); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
STATIC mp_obj_t pyb_millis(void) { ... },return the number of milliseconds since boot
void init_spi_gpio() { ... },Initialize SPI GPIO
void enable_cs() { ... },Enable chip select
void disable_cs() { ... },Disable chip select
void clear_data() { ... },Set data pin low
void spi_delay() { ... },Introduce a short delay for SPI timing
uint8_t send_byte(uint8_t data_in) { ... },"Send a byte over SPI, MSB first"
static int read_data_packet(uint8_t block_buffer[512]) { ... },Read a 512-byte data packet
int send_data(const uint8_t buf[512]) { ... },Send a 512-byte data packet
int init_sd_card() { ... },Initialize SD card
"void read_sector(uint32_t sector, uint8_t buf[512]) { ... }",Read a sector from SD card
fp();,Call function pointer to jump to application code
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
LED1_GPIO_CLK_ENABLE(); LED2_GPIO_CLK_ENABLE(); LED3_GPIO_CLK_ENABLE(); LED4_GPIO_CLK_ENABLE();,Enable GPIO Clock (to be able to program the configuration registers)
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;,Configure IO in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Pin = LED1_PIN; HAL_GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Pin = LED2_PIN; HAL_GPIO_Init(LED2_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Pin = LED3_PIN; HAL_GPIO_Init(LED3_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive external LEDs
"GPIO_InitStruct.Pin = LED4_PIN; HAL_GPIO_Init(LED4_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive external LEDs
HAL_Delay(100);,Insert delay 100 ms
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK) { while(1); },Enable HSE Oscillator and activate PLL with HSE as source
"memset(RxBuf, 0, I2CBUF);",Clear receive buffer
"HAL_I2C_Slave_Receive_IT(&hi2c2, RxBuf, I2CBUF);",Start I2C slave reception in interrupt mode
"HAL_I2C_Master_Transmit(&hi2c1, 0x10<<1, (uint8_t*)TxBuf, I2CBUF, 1000);",Transmit data over I2C master
hi2c2.Instance = I2C2; ... if (HAL_I2C_Init(&hi2c2) != HAL_OK) { Error_Handler(); },I2C2 Initialization
void HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c) { if (hi2c == &hi2c2) { RxDone = 1; } },Callback for I2C slave reception complete
BSP_UART_Init(9600); BSP_VCP_Init();,Initialize UART and Virtual COM Port
"BSP_GSM_ReadADV2(gsmBuf,45);",Read GSM response
__PWR_CLK_ENABLE(); __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure the main internal regulator output voltage
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);",Configure system clock and bus dividers
HAL_TIM_Base_Start_IT(&htim3);,Start timer in interrupt mode
"HAL_ADC_Start_DMA(&hadc1,(uint32_t*)&ADC_data[0],8*sizeof(uint16_t));",Start ADC with DMA
GPIO_Poll(&buttons_state);,Poll GPIO for button states
"report_data[i] = FilterWindow(filter_buf[i], ADC_data[i]);",Apply filter to ADC data
"USBD_HID_SendReport(&hUsbDeviceFS, (uint8_t*) &report_data, (AXIS_NUM + BUTTONS_ENABLED)*sizeof(uint16_t));",Send HID report over USB
"RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Initializes the RCC Oscillators according to the specified parameters
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }","Initializes the CPU, AHB and APB buses clocks"
"PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC|RCC_PERIPHCLK_USB; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Configure peripheral clocks for ADC and USB
"uint16_t FilterWindow (uint32_t * p_buf, uint16_t new_val) { ... }",Apply moving average filter to input data
freq = HAL_RCC_GetHCLKFreq();,Get system clock frequency
"moving_average((float32_t*)&inputSignal[0], (float32_t*)&outputSignal[0], (uint32_t)SIGNAL_LENGHT, (uint32_t)11);",Apply moving average filter
plot_both_signal();,Plot input and output signals
"float32_t signal_mean(float32_t *sig_src_arr, uint32_t sig_length) { ... }",Calculate mean of signal
"void moving_average(float32_t* sig_src_arr, float32_t* sig_out_arr, uint32_t sig_lenght, uint32_t filter_pts) { ... }",Compute moving average of signal
void plot_input_signal(void) { ... },Plot input signal
HAL_IncTick(); HAL_SYSTICK_IRQHandler();,Handle SysTick interrupt
reset_slave();,Reset slave to initialize
network_init();,Init network interface
stm_spi_init(spi_driver_event_handler);,Init SPI driver
"HAL_UART_Transmit(&huart3, (uint8_t *)&ch, 1, 0xFFFF);",Retarget printf to USART
"GPIO_InitStruct.Pin = GPIO_RESET_Pin; ... HAL_GPIO_Init(GPIO_RESET_GPIO_Port, &GPIO_InitStruct);",Configure reset pin
"HAL_GPIO_WritePin(GPIO_RESET_GPIO_Port, GPIO_RESET_Pin, GPIO_PIN_RESET);",Set reset pin low
control_path_init(control_path_event_handler);,Initiate control path
"send_arp_req(sta_handle, get_self_mac_station(), &sta_ip, dst_mac_bytes, &sta_dest_ip);",Send ARP request for station
"send_arp_req(ap_handle, get_self_mac_softap(), &softap_ip, dst_mac_bytes, &softap_dest_ip);",Send ARP request for softap
"HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15, GPIO_PIN_RESET);",Set GPIO pins low
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Configure HSI oscillator and PLL
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }",Configure system clock and bus dividers
"GPIO_InitStruct.Pin = GPIO_PIN_12 | GPIO_PIN_13 | GPIO_PIN_14 | GPIO_PIN_15; ... HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);",Configure GPIO pins
"xTaskCreate(vBlinkTask, ""BlinkTask1"", configMINIMAL_STACK_SIZE, (void *) &pin_toggle[0], tskIDLE_PRIORITY + 1, NULL);",Create FreeRTOS task for blinking LED
"RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Initializes the RCC Oscillators according to the specified parameters
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }","Initializes the CPU, AHB and APB buses clocks"
"PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Configure peripheral clock for USART2
"hal_uart_send(&uart_0, &ch, 1, 30000);",Retarget printf to UART
MX_GPIO_Init(); MX_USART6_UART_Init();,Initialize peripherals
"HAL_UART_Transmit(&huart6, (uint8_t*) buffer, buffer_size, 0xFFFF);",Transmit data over UART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Configure HSI oscillator
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }",Configure system clock and bus dividers
huart6.Instance = USART6; ... if (HAL_UART_Init(&huart6) != HAL_OK) { Error_Handler(); },USART6 Initialization
"HAL_GPIO_WritePin(Led_GPIO_Port, Led_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = Btn_Pin; ... HAL_GPIO_Init(Btn_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : Btn_Pin
"GPIO_InitStruct.Pin = Led_Pin; ... HAL_GPIO_Init(Led_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : Led_Pin
HAL_Delay(500);,Delay 500 ms
"HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_RESET);",Set LED pin low
"HAL_GPIO_WritePin(LD2_GPIO_Port, LD2_Pin, GPIO_PIN_SET);",Set LED pin high
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Configure HSI48 oscillator
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }",Configure system clock and bus dividers
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure peripheral clock for USART2
huart2.Instance = USART2; ... if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); },USART2 Initialization
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { while(1); },"MSI is enabled after System reset at 4Mhz, PLL not used"
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { while(1); }","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE2);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet"
BSP_LED_Init(LED2); BSP_LED_Init(LED3);,Initialize LEDs mounted on NUCLEO-WL55JC RevC board
DMAx_CLK_ENABLE();,Enable DMA1 clock
HAL_DMA_Init(&DMA_Handle);,Initialize the DMA with for Transmission process
"HAL_DMA_RegisterCallback(&DMA_Handle, HAL_DMA_XFER_ERROR_CB_ID, &HAL_TransferError);",Register Error Callback
"HAL_NVIC_SetPriority(DMA1_Channel1_IRQn, 0, 1); HAL_NVIC_EnableIRQ(DMA1_Channel1_IRQn);",NVIC configuration for DMA transfer complete interrupt
"HAL_DMAEx_ConfigMuxRequestGenerator(&DMA_Handle, &dmamux_ReqGenParams);",Configure and enable the DMAMUX Request generator
HAL_DMAEx_EnableMuxRequestGenerator(&DMA_Handle);,Configure and enable the DMAMUX Request generator
"BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);",Configure and enable the User push-button (B1) in EXTI mode used as DMA external request signal
static void HAL_TransferError(DMA_HandleTypeDef *hdma) { ... },This function is executed in case of DMA error occurrence
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
NRF24_init(&hspi2);,Initialize NRF24 module
"HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_1); HAL_TIM_PWM_Start(&htim1, TIM_CHANNEL_2);",Start PWM on TIM1 channels
"NRF24_openReadingPipe(1, rx_pipe_addr);",Configure NRF24 to open reading pipe
NRF24_startListening();,Start NRF24 listening mode
if(NRF24_available()){ ... },Check if NRF24 data is available and process it
"NRF24_read(my_rx_data, PAYLOAD_SIZE);",Read data from NRF24
"HAL_UART_Transmit(&huart2, my_rx_data, PAYLOAD_SIZE + 2, 100);",Transmit received data over UART
BSP_LED_Init(LED1); BSP_LED_Init(LED2); BSP_LED_Init(LED3);,"Initialize LED1, LED2 and LED3"
"EraseInitStruct.TypeErase = FLASH_TYPEERASE_PAGES; ... if (HAL_FLASHEx_Erase(&EraseInitStruct, &PAGEError) != HAL_OK) { ... }",Erase the user Flash area (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR)
"HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, DATA_32)",Program the user Flash area word by word (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR)
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct)!= HAL_OK) { while(1); },Enable MSI Oscillator
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0)!= HAL_OK) { while(1); }","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
PixelInit();,Initialize pixel display
"DisplayString(""5230"");",Display string on the display
"DisplayLed(leds[i], led_state);",Control individual LED state
void HAL_SYSTICK_Callback(void) { DisplayRun(); pixel.h = HAL_GetTick() / 10 % 360; PixelHSV(pixel); },Update display and pixel color in Systick callback
static void MX_TIM1_Init(void) { ... },TIM1 Initialization Function
__GPIOA_CLK_ENABLE(); __GPIOB_CLK_ENABLE(); __GPIOC_CLK_ENABLE(); __GPIOD_CLK_ENABLE(); __GPIOE_CLK_ENABLE();,Enable GPIO clocks
__DMA2_CLK_ENABLE();,Enable DMA clocks
"GPIO_InitStructure.Pin = DCMI_PWDN_PIN; HAL_GPIO_Init(DCMI_PWDN_PORT, &GPIO_InitStructure);",Configure DCMI GPIO
void HAL_I2C_MspInit(I2C_HandleTypeDef *hi2c) { ... },Initialize I2C MSP
SCCB_CLK_ENABLE();,Enable I2C clock
"GPIO_InitStructure.Pin = SCCB_SDA_PIN; HAL_GPIO_Init(SCCB_PORT, &GPIO_InitStructure);",Configure SCCB GPIOs
void HAL_I2C_MspDeInit(I2C_HandleTypeDef *hi2c) { ... },DeInitialize I2C MSP
SCCB_CLK_DISABLE();,Disable I2C clock
void HAL_TIM_PWM_MspInit(TIM_HandleTypeDef *htim) { ... },Initialize TIM PWM MSP
DCMI_TIM_CLK_ENABLE();,Enable DCMI timer clock
void HAL_DCMI_MspInit(DCMI_HandleTypeDef* hdcmi) { ... },Initialize DCMI MSP
__DCMI_CLK_ENABLE();,DCMI clock enable
"for (int i=0; i<NUM_DCMI_PINS; i++) { GPIO_InitStructure.Pin = dcmi_pins[i].pin; HAL_GPIO_Init(dcmi_pins[i].port, &GPIO_InitStructure); }",DCMI GPIOs configuration
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive(),activate the OverDrive to reach the 216 Mhz Frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { Error_Handler(); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
static void MPU_Config(void) { ... },Configure the MPU attributes as Write Through for SRAM1/2
Luos_Init();,Initialize Luos engine
Switcher_Init();,Initialize switcher module
Led_Init();,Initialize LED module
Luos_Loop();,Run Luos engine loop
Switcher_Loop();,Run switcher module loop
Led_Loop();,Run LED module loop
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"GpioInit(&Led1, LED_1, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize LED1 GPIO
"GpioInit(&Led2, LED_2, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize LED2 GPIO
"GpioInit(&Led3, LED_3, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize LED3 GPIO
SX9500Init();,Init SAR
"SX9500Write(SX9500_REG_IRQMSK, 0x10);",Configure SAR interrupt mask
"SX9500Read(SX9500_REG_IRQSRC, &status);",Read SAR interrupt source
"SX9500Read(SX9500_REG_OFFSETMSB, (uint8_t*)&regValue); offset = regValue << 8; SX9500Read(SX9500_REG_OFFSETLSB, (uint8_t*)&regValue); offset |= regValue;",Read 1st sensor offset
JumpToApplication();,Jump to user application
"USBD_RegisterClass(&USBD_Device, USBD_DFU_CLASS);",Add Supported Class
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSI Oscillator and Activate PLL with HSI as source
"RCC_ClkInitStruct.ClockType = ( RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2 ); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE|RCC_OSCILLATORTYPE_LSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_SPDIFRX|RCC_PERIPHCLK_LTDC|RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_USART1|RCC_PERIPHCLK_USART6|RCC_PERIPHCLK_SAI2|RCC_PERIPHCLK_I2C1|RCC_PERIPHCLK_I2C3|RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_CLK48; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { Error_Handler(); },Configure peripheral clocks for multiple peripherals
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode to increment a global variable ""uwTick"" used as application time base"
BSP_LED_Init(LED1); BSP_LED_Init(LED2); BSP_LED_Init(LED3); BSP_LED_Init(LED4);,"Configure LED1, LED2, LED3 and LED4"
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == USER_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback to suspend or resume tick increment based on button state
BSP_LED_Init(LED6); BSP_LED_Init(LED5);,Configure LED6 & LED5
TimHandle.Instance = TIMx; TimHandle.Init.Period = 10000 - 1; TimHandle.Init.Prescaler = uwPrescalerValue; ... if (HAL_TIM_Base_Init(&TimHandle) != HAL_OK) { Error_Handler(); },"Initialize TIMx peripheral with specified period, prescaler, and counter settings"
if (HAL_TIM_Base_Start_IT(&TimHandle) != HAL_OK) { Error_Handler(); },Start the TIM Base generation in interrupt mode
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { while(1) {}; },Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { while(1) {}; }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { BSP_LED_Toggle(LED6); },Period elapsed callback in non blocking mode to toggle LED6
osKernelInitialize(); MX_FREERTOS_Init();,Init scheduler and FreeRTOS objects
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_LPTIM1|RCC_PERIPHCLK_CLK48; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { Error_Handler(); },"Configure peripheral clocks for USART3, LPTIM1, and CLK48"
"HAL_UART_RegisterRxEventCallback(&huart1, UART1_RxEventCallback); HAL_UART_RegisterRxEventCallback(&huart2, UART2_RxEventCallback);",Register UART receive event callbacks
"HAL_UARTEx_ReceiveToIdle_IT(&huart1, uart1_rx, sizeof(uart1_rx));",Start UART1 receive to idle in interrupt mode
"HAL_UARTEx_ReceiveToIdle_IT(&huart2, uart2_rx, sizeof(uart2_rx));",Start UART2 receive to idle in interrupt mode
"if (!circ_bbuf_pop(&uart1_tx, &bdata)) { HAL_UART_Transmit(&huart1, &bdata, 1, 500); }",Transmit data from UART1 circular buffer
"if (!circ_bbuf_pop(&uart2_tx, &bdata)) { HAL_UART_Transmit(&huart2, &bdata, 1, 500); }",Transmit data from UART2 circular buffer
huart1.Instance = USART1; ... if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); },USART1 Initialization
"GPIO_InitStruct.Pin = GPIO_PIN_13; ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC13
"void UART1_RxEventCallback(UART_HandleTypeDef *huart, uint16_t pos) { ... HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); ... }",Callback to handle UART1 receive event and toggle GPIO pin
"void UART2_RxEventCallback(UART_HandleTypeDef *huart, uint16_t pos) { ... HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13); ... }",Callback to handle UART2 receive event and toggle GPIO pin
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_2);",Start PWM on TIM2 Channel 2
"PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_RTC|RCC_PERIPHCLK_TIM2; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }","Configure peripheral clocks for USB, USART3, RTC, and TIM2"
GraphicsInit();,Initialize graphics
GraphicsClear(RED);,Clear display with red color
GraphicsClear(GREEN);,Clear display with green color
GraphicsClear(BLUE);,Clear display with blue color
GraphicsClear(BLACK);,Clear display with black color
"GraphicsVline(10, 20, 400, WHITE);",Draw vertical line
"GraphicsHline(0U, ILI9341_LCD_WIDTH, 50, YELLOW);",Draw horizontal line
"GraphicsRectangle(50, 50, 100, 50, GREEN);",Draw rectangle
"GraphicsStandardString(50, 200, ""Freddy"", PINK);",Draw standard string
"GraphicsStandardStringVert(50, 100, ""Freddy"", CYAN);",Draw vertical standard string
"GraphicsLargeString(50, 180, ""Freddy"", PINK);",Draw large string
"GraphicsLargeStringVert(80, 100, ""Freddy"", CYAN);",Draw vertical large string
"GraphicsFilledCircle(200, 200, 20, PURPLE);",Draw filled circle
"GraphicsColourBitmap(j, j, 101, 135, kitten);",Draw color bitmap
"GraphicsRotateShape(3U, triangleCornersX, triangleCornersY, 45);",Rotate shape
"GraphicsFilledSegment(100, 50, 30, 180, -90, 20U, WHITE);",Draw filled segment
HAL_Delay(200UL);,Delay 200 ms
HAL_Delay(500UL);,Delay 500 ms
hspi1.Instance = SPI1; ... if (HAL_SPI_Init(&hspi1) != HAL_OK) { Error_Handler(); },SPI1 parameter configuration
__HAL_RCC_DMA1_CLK_ENABLE();,DMA controller clock enable
"GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9|GPIO_PIN_10; ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);",Configure GPIO pins : PA8 PA9 PA10
"printf(""Start\r\n"");",Print start message
"printf(""%ld----%ld\r\n"", KEY_0_NUM - last_KEY_0_NUM, KEY_1_NUM - last_KEY_1_NUM);",Print key press counts
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCK_then((SystemCoreClock / 2) / 10000) - 1;,Compute the prescaler value to have TIMx counter clock equal to 10000 Hz
"HAL_NVIC_SetPriority(EXTI2_IRQn, 1, 0); HAL_NVIC_EnableIRQ(EXTI2_IRQn);",EXTI2_IRQn interrupt configuration
"HAL_NVIC_SetPriority(EXTI3_IRQn, 1, 0); HAL_NVIC_EnableIRQ(EXTI3_IRQn);",EXTI3_IRQn interrupt configuration
"int _write(int file, char *ptr, int len) { ... ITM_SendChar(*ptr++); ... }",Redirect printf to ITM
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { HAL_Delay(10); switch (GPIO_Pin) { case KEY_0_Pin: { KEY_0_NUM++; break; } case KEY_1_Pin: { KEY_1_NUM++; break; } default : break; } },Callback to increment key press counters on EXTI interrupt
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM14) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode to increment a global variable ""uwTick"" used as application time base"
"PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Configure peripheral clock for RTC
init_sysclk_216MHz();,we need to initialise the hal library and set up the SystemCoreClock properly
"init_gpio(Yellow, OUTPUT);",initialise the gpio pins
"init_gpio(Green, OUTPUT);",initialise the gpio pins
"write_gpio (Red, HIGH);",turn the red led on
"write_gpio (Yellow, LOW);",turn the Yellow led off
"write_gpio (Green, LOW);",turn the Green led off
HAL_Delay(1500);,delay for 1.5 second
"write_gpio (Yellow, HIGH);",turn the Yellow led on
"write_gpio (Red, LOW);",turn the red led off
"write_gpio (Green, HIGH);",turn the Green led on
HAL_Delay(1000);,delay for 1.5 second
"APP_UART_FIFO_INIT(&comm_params, UART_RX_BUF_SIZE, UART_TX_BUF_SIZE, uart_handler, APP_IRQ_PRIORITY_LOWEST, err_code);","Initialize UART FIFO with communication parameters, buffer sizes, and handler"
"hal_uart_recv(&uart_0, &ch, 1, HAL_WAIT_FOREVER);",Receive character from UART
"void os_hwi_set_handler(uint32_t irq, void *func, uint32_t param) { ... }",Set interrupt handler for specified IRQ
"void print_stack_mem(void* addr,int len) { ... }",Print memory contents of stack
void print_sys_reg(void) { ... },"Print system register values (PSR, IPSR, EPSR, etc.)"
void print_sys_variable(void) { ... },"Print system variables like g_sys_stat, g_sched_lock, etc."
void cpu_hardfault_handle(void) { ... },Handle CPU hard fault by printing stack and system information
void HardFault_Handler(void) { ... },Hard fault handler entry point
cdc_acm_init();,Initialize USB CDC ACM interface
cdc_acm_data_send_with_dtr_test();,Send data over USB CDC ACM with DTR test
HAL_Delay(100);,Delay for 100ms
void usb_dc_low_level_init(void) { ... },Initialize USB device controller low-level settings
__HAL_RCC_USB_CLK_ENABLE();,Peripheral clock enable
"int fputc(int ch, FILE *f) { ... }",Retarget printf to USART1
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure USB peripheral clock
static void MX_USART1_UART_Init(void) { ... },USART1 Initialization Function
static void MX_USB_PCD_Init(void) { ... },USB Initialization Function
static void MX_GPIO_Init(void) { ... },GPIO Initialization Function
usbh_initialize();,Initialize USB host stack
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
static void MX_USB_OTG_HS_HCD_Init(void) { ... },USB_OTG_HS Initialization Function
void mgos_dev_system_restart(void) { ... },Perform system reset
HAL_NVIC_SystemReset();,Perform system reset
void device_get_mac_address(uint8_t mac[6]) { ... },Construct MAC address using device's UID
void HAL_Delay(__IO uint32_t ms) { ... },Delay for specified milliseconds
RCC->AHB2ENR |= RCC_AHB2ENR_RNGEN; RNG->CR = RNG_CR_RNGEN;,Enable RNG peripheral
HAL_IWDG_Init(&hiwdg);,Initialize watchdog timer
void mgos_wdt_feed(void) { ... },Feed watchdog timer
HAL_IWDG_Refresh(&hiwdg);,Refresh watchdog timer
void mgos_wdt_set_timeout(int secs) { ... },Set watchdog timer timeout
uint32_t mgos_get_cpu_freq(void) { ... },Get CPU frequency
__HAL_RCC_LSEDRIVE_CONFIG (RCC_LSEDRIVE_LOW);,Configure LSE Drive Capability
"PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART1 | ... if (HAL_RCCEx_PeriphCLKConfig (&PeriphClkInit) != HAL_OK) { _Error_Handler (__FILE__, __LINE__); }",Configure peripheral clocks
SystemInit ();,Initialize system
HAL_Init ();,Initialize HAL
__HAL_RCC_GPIOA_CLK_ENABLE ();,Enable GPIOA clock
__HAL_RCC_GPIOB_CLK_ENABLE ();,Enable GPIOB clock
__HAL_RCC_GPIOC_CLK_ENABLE ();,Enable GPIOC clock
__HAL_RCC_GPIOH_CLK_ENABLE ();,Enable GPIOH clock
void MX_SDMMC1_SD_Init(void) { ... },SDMMC1 init function
HAL_SD_Init(&hsd1);,Initialize SDMMC1
void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle) { ... },Initialize SDMMC1 MSP
__HAL_RCC_SDMMC1_CLK_ENABLE();,SDMMC1 clock enable
"GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_12; ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",SDMMC1 GPIO Configuration
void HAL_SD_MspDeInit(SD_HandleTypeDef* sdHandle) { ... },Deinitialize SDMMC1 MSP
__HAL_RCC_SDMMC1_CLK_DISABLE();,Peripheral clock disable
"HAL_GPIO_DeInit(GPIOC, GPIO_PIN_8|GPIO_PIN_12);",Deinitialize GPIOC pins
"HAL_GPIO_DeInit(GPIOD, GPIO_PIN_2);",Deinitialize GPIOD pin
__HAL_FLASH_ART_ENABLE();,Configure Flash prefetch and Instruction cache through ART accelerator
HAL_NVIC_SetPriorityGrouping( NVIC_PRIORITYGROUP_4 );,Set Interrupt Group Priority
HAL_MspInit();,Init the low level hardware
prvSystemClockConfig();,Configure the System clock to have a frequency of 200 MHz
__HAL_RCC_GPIOF_CLK_ENABLE();,Enable GPIOF Clock
"GPIO_InitStruct.Pin = GPIO_PIN_10; ... HAL_GPIO_Init( GPIOF, &GPIO_InitStruct );",Configure GPIOF for LED output
"HAL_RCC_MCOConfig( RCC_MCO2, RCC_MCO2SOURCE_SYSCLK, RCC_MCODIV_1 );",MCO2 : Pin PC9
static void prvSystemClockConfig( void ) { ... },Configure the system clock for maximum speed
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void vApplicationMallocFailedHook( void ) { ... },Called if a call to pvPortMalloc() fails because there is insufficient free memory available in the FreeRTOS heap
"void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { ... }",Run time stack overflow checking is performed if configCHECK_FOR_STACK_OVERFLOW is defined to 1 or 2
void vApplicationIdleHook( void ) { ... },This is just a trivial example of an idle hook
void vApplicationTickHook( void ) { ... },The full demo includes a software timer demo/test that requires prodding periodically from the tick interrupt
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
HAL_IncTick();,"Increment a global variable ""uwTick"" used as application time base"
MX_ADC1_Init();,Initialize ADC1 for scope functionality
MX_ADC2_Init();,Initialize ADC2 for scope functionality
MX_ADC3_Init();,Initialize ADC3 for scope functionality
MX_TIM3_Init();,Initialize TIM3 for scope functionality
CalibrateADC();,Calibrate ADC for scope functionality
adcSetDefaultInputs();,Set default ADC inputs for scope functionality
MX_DAC1_Init();,Initialize DAC1 for signal generator functionality
MX_TIM6_Init();,Initialize TIM6 for signal generator functionality
MX_TIM7_Init();,Initialize TIM7 for signal generator functionality
"osKernelStart(NULL, NULL);",Start FreeRTOS scheduler
LED_On();,Turn LED on
osDelay(40);,Delay for 40ms
LED_Off();,Turn LED off
osDelay(400);,Delay for 400ms
sConfigPVD.PVDLevel = PWR_PVDLEVEL_3; sConfigPVD.Mode = PWR_PVD_MODE_IT_RISING_FALLING; HAL_PWR_ConfigPVD(&sConfigPVD);,Configure the PVD Level to 3 and generate an interrupt on rising and falling edges (PVD detection level set to 2.5V)
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
__HAL_FLASH_PREFETCH_BUFFER_ENABLE();,Enable the Flash prefetch
void HAL_SYSTICK_Callback(void) { HAL_IncTick(); },SYSTICK callback
void HAL_PWR_PVDCallback(void) { BSP_LED_Toggle(LED1); },PWR PVD interrupt callback
void Error_Handler(void) { BSP_LED_On(LED3); while(1) { } },This function is executed in case of error occurrence
lcdInitialize(CURSOR_PISCANTE);,Initialize LCD with blinking cursor
PIN_BACKLIGHT_SET;,Enable LCD backlight
"memset(senhaUsuario, 0, sizeof(senhaUsuario)); memset(combinacaoDigitada, 0, sizeof(combinacaoDigitada)); memset(ultimaCombinacaoDigitada, 0, sizeof(ultimaCombinacaoDigitada));",Clear password and combination buffers
void delayUs(int tempo) { while (tempo--) uDelay(); },Delay for specified microseconds
void lcdInitialize(byte estado) { lcdWriteCommand4Bits(3); lcdWriteCommand4Bits(3); lcdWriteCommand4Bits(3); lcdWriteCommand4Bits(2); lcdWriteCommand(0x28); lcdWriteCommand(estado); lcdWriteCommand(0x06); lcdWriteCommand(0x01); },Initialize LCD with specified cursor state
"void lcdGoto(byte x, byte y) { if (y == 0) lcdWriteCommand(0x80 + x); else if (y == 1) lcdWriteCommand(0xC0 + x); else if (y == 2) lcdWriteCommand(0x90 + x); else if (y == 3) lcdWriteCommand(0xD0 + x); }",Set LCD cursor position
void lcdWriteString(byte *str) { while (*str) lcdWriteCharacter(*(str++)); },Write string to LCD
"int fputc(int ch, FILE *f) { lcdWriteCharacter(ch); return ch; }",Redirect printf to LCD
"int getBit(byte valor, byte posicao) { return valor & (1 << posicao); }",Get bit at specified position
"void lcdSendData(byte x) { (getBit(x, 3)) ? D7_1 : D7_0; (getBit(x, 2)) ? D6_1 : D6_0; (getBit(x, 1)) ? D5_1 : D5_0; (getBit(x, 0)) ? D4_1 : D4_0; }",Send 4-bit data to LCD
"int lePotenciometro(void) { int leitura = 0; HAL_ADC_Start(&hadc); HAL_ADC_PollForConversion(&hadc, 1); leitura = HAL_ADC_GetValue(&hadc); HAL_ADC_Stop(&hadc); for (int posicao = 0; posicao < arraySize; posicao++) if (leitura <= valor[posicao]) return posicao; }",Read potentiometer value and map to combination index
"void compararSenhas(void) { if (!strcmp(minhaSenha, senhaUsuario)) combinacaoCorreta(); else limparCombinacao(); }",Compare entered password with stored password
"void combinacaoCorreta(void) { int posicao = 0; lcdWriteCommand(0x01); lcdGoto(0, 0); printf(""ABERTO""); LED_1; RELE_1; HAL_Delay(350); do { for (int cont = 0; cont < 10;) { posicao = lePotenciometro(); if (!strcmp("" 0"", combinacao[posicao])) cont++; else { cont = 0; lcdGoto(14, 0); printf(""%s"", combinacao[posicao]); HAL_Delay(185); } } } while (strcmp("" 0"", combinacao[posicao])); memset(senhaUsuario, 0, sizeof(senhaUsuario)); memset(combinacaoDigitada, 0, sizeof(combinacaoDigitada)); memset(ultimaCombinacaoDigitada, 0, sizeof(ultimaCombinacaoDigitada)); travar(); }","Handle correct combination, open safe, and reset"
"void limparCombinacao(void) { memset(senhaUsuario, 0, sizeof(senhaUsuario)); memset(combinacaoDigitada, 0, sizeof(combinacaoDigitada)); memset(ultimaCombinacaoDigitada, 0, sizeof(ultimaCombinacaoDigitada)); lcdGoto(0, 1); printf(""              ""); confirmarCombinacao(); }",Clear entered combination and reset display
PWR->CR2 |= (PWR_CR2_CWUPF6 | PWR_CR2_CWUPF5 | PWR_CR2_CWUPF4 | PWR_CR2_CWUPF3 | PWR_CR2_CWUPF2 | PWR_CR2_CWUPF1); PWR->CR1 |= PWR_CR1_CSBF;,Clear wakeup flags from GPIOs and clear standby flag
halInit();,"HAL initialization, initializes configured device drivers and performs board-specific initializations"
SwoInit();,Init SWO for output
osKernelInitialize();,The kernel is initialized but not started yet
Watchdog_Init();,Start watchdog
Target_ExternalMemoryInit();,Config and init external memory
hal_spiffs_config();,Config and init SPIFFS
"sduObjectInit(&SDU1); sduStart(&SDU1, &serusbcfg);",Initializes a serial-over-USB CDC driver
"usbDisconnectBus(serusbcfg.usbp); chThdSleepMilliseconds(100); usbStart(serusbcfg.usbp, &usbcfg); usbConnectBus(serusbcfg.usbp);",Activates the USB driver and then the USB bus pull-up on D+
"osThreadCreate(osThread(ReceiverThread), NULL);",Create the receiver thread
"osThreadCreate(osThread(CLRStartupThread), &clrSettings);",Create the CLR Startup thread
"osThreadCreate(osThread(SdCardWorkingThread), NULL);",Creates the SD card working thread
"osThreadCreate(osThread(UsbMsdWorkingThread), NULL);",Create the USB MSD working thread
osKernelStart();,Start kernel
VL53L0X_PROXIMITY_Init();,VL53L0X proximity sensor Initialization
"uint16_t VL53L0X_PROXIMITY_GetDistance(void) { VL53L0X_RangingMeasurementData_t RangingMeasurementData; VL53L0X_PerformSingleRangingMeasurement(&Dev, &RangingMeasurementData); return RangingMeasurementData.RangeMilliMeter; }",Get distance from VL53L0X proximity sensor
"void VL53L0X_PROXIMITY_MspInit(void) { GPIO_InitTypeDef GPIO_InitStruct; GPIO_InitStruct.Pin = VL53L0X_XSHUT_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH; HAL_GPIO_Init(VL53L0X_XSHUT_GPIO_Port, &GPIO_InitStruct); HAL_GPIO_WritePin(VL53L0X_XSHUT_GPIO_Port, VL53L0X_XSHUT_Pin, GPIO_PIN_SET); HAL_Delay(1000); }",VL53L0X proximity sensor Msp Initialization
"void SetupSingleShot(VL53L0X_Dev_t Dev) { ... status=VL53L0X_SetDeviceMode(&Dev, VL53L0X_DEVICEMODE_SINGLE_RANGING); ... }",Setup all detected sensors for single shot mode and setup ranging configuration
VL53L0X_StaticInit(&Dev);,Initialize static settings for VL53L0X
"VL53L0X_PerformRefCalibration(&Dev, &VhvSettings, &PhaseCal);",Perform reference calibration for VL53L0X
"VL53L0X_PerformRefSpadManagement(&Dev, &refSpadCount, &isApertureSpads);",Perform reference SPAD management for VL53L0X
"VL53L0X_SetDeviceMode(&Dev, VL53L0X_DEVICEMODE_SINGLE_RANGING);",Setup in single ranging mode
"VL53L0X_SetLimitCheckEnable(&Dev, VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, 1);",Enable Sigma limit
"VL53L0X_SetLimitCheckEnable(&Dev, VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, 1);",Enable Signal limit
"VL53L0X_SetLimitCheckValue(&Dev, VL53L0X_CHECKENABLE_SIGNAL_RATE_FINAL_RANGE, signalLimit);",Set signal rate limit value
"VL53L0X_SetLimitCheckValue(&Dev, VL53L0X_CHECKENABLE_SIGMA_FINAL_RANGE, sigmaLimit);",Set sigma limit value
"VL53L0X_SetMeasurementTimingBudgetMicroSeconds(&Dev, timingBudget);",Set measurement timing budget
"VL53L0X_SetVcselPulsePeriod(&Dev, VL53L0X_VCSEL_PERIOD_PRE_RANGE, preRangeVcselPeriod);",Set VCSEL pulse period for pre-range
"VL53L0X_SetVcselPulsePeriod(&Dev, VL53L0X_VCSEL_PERIOD_FINAL_RANGE, finalRangeVcselPeriod);",Set VCSEL pulse period for final range
LCDInit();,Initialize LCD
"HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_SET);",Set GPIO pin PC13
"HAL_GPIO_WritePin(GPIOC,GPIO_PIN_13,GPIO_PIN_RESET);",Reset GPIO pin PC13
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },"Initializes the CPU, AHB and APB buses clocks"
DS3231_Init(&hi2c1);,Initialize DS3231 RTC
DS3231_SetTime(&RTC_time_data);,Sets the time
"DS3231_ConfigureAlarm(ALARM_MODE_ONCE_PER_SECOND, &AlarmConf);",Configures alarm 1 to once per second
DS3231_EnableAlarm(ALARM1);,Enables alarm 1
DS3231_ReadTime(&RTC_time_data);,Read current time from DS3231
"HAL_UART_Transmit(&huart2, (uint8_t *)sbuf, sbuflen, 100);",Transmit time data over UART
DS3231_ReadTemp(&temperature);,Read temperature from DS3231
DS3231_ClearAlarmFlag(ALARM1);,Clears alarm flag
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, SET);",Set GPIO pin PC13 for LED flashing
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, RESET);",Reset GPIO pin PC13 for LED flashing
HAL_Delay(50);,Delay 50 ms
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters
hi2c1.Instance = I2C1; ... if (HAL_I2C_Init(&hi2c1) != HAL_OK) { Error_Handler(); },I2C1 Initialization
"if (f_mount(&SDFatFS, (TCHAR const*)SDPath, 0) != FR_OK) { Error_Handler(); } else { scan_files(SDPath); }",Register the file system object to the FatFs module
FATFS_UnLinkDriver(SDPath);,Unlink the micro SD disk I/O driver
"printf(""Done\r\n"");",Print completion message
PUTCHAR_PROTOTYPE { while ((USART1->SR & 0X40) == 0); USART1->DR = (uint8_t) ch; return ch; },Redirect putchar for printf over USART1
"if (HAL_GPIO_ReadPin(B1_GPIO_Port, B1_Pin) == GPIO_PIN_SET) { uint32_t *invalidPtr = (uint32_t*)0xCCCCCCCC; uint32_t notGonnaHappen = *invalidPtr; }",Cause a hardfault on button press
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_8) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
initGPIO();,Initialize GPIO for LED
"xTaskCreate(blinky, ""blinky"", configMINIMAL_STACK_SIZE * 4, NULL, tskIDLE_PRIORITY + 1, NULL);",Create blinky task
"void blinky(void *arg) { for(;;) { vTaskDelay(500); HAL_GPIO_TogglePin(LED_PORT, LED_PIN); } }",Blink LED every 500ms
"platform_write(void *handle, uint8_t Reg, uint8_t *Bufp, uint16_t len) { if (handle == &hi2c1) { HAL_I2C_Mem_Write(handle, slave_address, Reg, I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000); } ... }",Platform-specific write function for LSM6DSOX
"platform_read(void *handle, uint8_t Reg, uint8_t *Bufp, uint16_t len) { if (handle == &hi2c1) { HAL_I2C_Mem_Read(handle, slave_address, Reg, I2C_MEMADD_SIZE_8BIT, Bufp, len, 1000); } ... }",Platform-specific read function for LSM6DSOX
platform_delay(uint32_t timeout) { volatile uint32_t i; for(i = 0; i < timeout; i++); },Function to wait for a timeout
platform_init();,Platform specific initialization
"lsm6dsox_device_id_get(&dev_ctx, &whoamI);",Check device ID
"lsm6dsox_reset_set(&dev_ctx, PROPERTY_ENABLE);",Restore default configuration
"lsm6dsox_i3c_disable_set(&dev_ctx, LSM6DSOX_I3C_DISABLE);",Disable I3C interface
"lsm6dsox_xl_data_rate_set(&dev_ctx, LSM6DSOX_XL_ODR_208Hz);",Set XL Output Data Rate
"lsm6dsox_gy_data_rate_set(&dev_ctx, LSM6DSOX_GY_ODR_104Hz);",Set Gyro Output Data Rate
"lsm6dsox_xl_full_scale_set(&dev_ctx, LSM6DSOX_2g);",Set 2g full XL scale
"lsm6dsox_gy_full_scale_set(&dev_ctx, LSM6DSOX_250dps);",Set 250 dps full Gyro
"lsm6dsox_wkup_dur_set(&dev_ctx, 0x02);",Set duration for Activity detection to 9.62 ms
"lsm6dsox_act_sleep_dur_set(&dev_ctx, 0x02);",Set duration for Inactivity detection to 4.92 s
"lsm6dsox_act_mode_set(&dev_ctx, LSM6DSOX_XL_12Hz5_GY_PD);","Inactivity configuration: XL to 12.5 in LP, gyro to Power-Down"
"lsm6dsox_pin_int1_route_get(&dev_ctx, &int1_route); int1_route.md1_cfg.int1_sleep_change = PROPERTY_ENABLE; lsm6dsox_pin_int1_route_set(&dev_ctx, &int1_route);",Enable interrupt generation on Inactivity INT1 pin
"dummy_handle = osThreadNew(dummy, NULL, &dummy_attributes);",Create dummy task thread
"appMain_handle = osThreadNew(appMain, NULL, &appMain_attributes);",Create application main task thread
osKernelInitialize();,Call init function for freertos objects (in freertos.c)
MX_FREERTOS_Init();,Init scheduler
void my_debug_init() { ... },Initialize UART for debug output
HAL_UART_Init(&debug_huart);,Initialize UART for debug output
"void my_debug(const char *fmt, ...) { ... }",Print debug messages via UART
"HAL_UART_Transmit(&debug_huart, (uint8_t*)str, count, 100);",Transmit debug message over UART
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);",Configure BUTTON_USER
Display_ExampleDescription();,Display main example messages
BSP_LED_On(LED2);,Turn on LED
HAL_FLASH_Unlock();,Allow Access to Flash control registers and user Flash
__HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_OPTVERR);,Clear OPTVERR bit set on virgin samples
HAL_FLASH_OB_Unlock();,Allow Access to option bytes sector
HAL_FLASHEx_OBGetConfig(&OBInit);,Get the Dual boot configuration status
OBInit.OptionType = OPTIONBYTE_USER; OBInit.USERType   = OB_USER_BFB2; ... HAL_FLASHEx_OBProgram (&OBInit);,Enable/Disable dual boot feature
HAL_FLASH_OB_Launch();,Start the Option Bytes programming process
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { while(1); },"MSI is enabled after System reset, activate PLL with MSI as source"
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) { while(1); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
ASK25_DCMotor_Init();,Initialize DCMotor pin
ASK25_DCMotor_Rotate(MotorAntiClockwise);,Rotate motor anticlockwise direction
"trace_printf(""Hello\n"");",Print hello message
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure HSE oscillator and activate PLL
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1 ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);",Configure system clock and peripheral clocks
__HAL_RCC_PWR_CLK_ENABLE();,Enables the PWR Clock and Enables access to the backup domain
HAL_PWR_EnableBkUpAccess();,Enables the PWR Clock and Enables access to the backup domain
__HAL_RCC_BACKUPRESET_FORCE(); __HAL_RCC_BACKUPRESET_RELEASE();,Reset the Back up Domain
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure LSE oscillator
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSE; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct);,Configure RTC peripheral clock
__HAL_RCC_RTC_ENABLE();,Enable RTC Clock
"HAL_NVIC_SetPriority(RTC_IRQn, 0x0F, 0); HAL_NVIC_EnableIRQ(RTC_IRQn);",Configure the NVIC for RTC Alarm
void RTC_Init(void) { ... },Configure RTC prescaler and RTC data registers
HAL_RTC_Init(&RtcHandle);,Initialize RTC
"HAL_RTCEx_BKUPRead(&RtcHandle, RTC_BKP_DR1)",Read the Back Up Register 1 Data
HAL_RTCEx_DeactivateWakeUpTimer(&RtcHandle),if the wakeup timer is enabled then deactivate it to disable the wakeup timer interrupt
"HAL_RTCEx_SetWakeUpTimer_IT(&RtcHandle, 0x0, RTC_WAKEUPCLOCK_CK_SPRE_16BITS);",Setting the Wakeup time to 1 s
"HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_BKP_DR1, WAKEUP_TIMER_ENABLE);",Write 'wakeup timer enabled' tag in RTC Backup data Register 1
"HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BCD);",Begin setting the date and time
"HAL_RTC_GetTime(&RtcHandle, &stimestructureget, RTC_FORMAT_BIN);",Get the RTC current Time
"HAL_RTC_GetDate(&RtcHandle, &sdatestructureget, RTC_FORMAT_BIN);",Get the RTC current Date
"sprintf((char*)aShowTime,""%02d:%02d:%02d"",stimestructureget.Hours, stimestructureget.Minutes, stimestructureget.Seconds);",Display time Format : hh:mm:ss
"HAL_GPIO_WritePin( GPIOC, GPIO_PIN_13, GPIO_PIN_RESET );","LED blink, PC13"
"HAL_GPIO_WritePin( GPIOC, GPIO_PIN_13, GPIO_PIN_SET );","LED blink, PC13"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... if( HAL_RCC_OscConfig( &RCC_OscInitStruct ) != HAL_OK ) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK ... if( HAL_RCC_ClockConfig( &RCC_ClkInitStruct, FLASH_LATENCY_2 ) != HAL_OK ) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL_DIV1_5; if( HAL_RCCEx_PeriphCLKConfig( &PeriphClkInit ) != HAL_OK ) { Error_Handler(); },Configure USB peripheral clock
static void MX_GPIO_Init( void ) { ... },GPIO Initialization Function
"int fputc( int ch, FILE *f ) { ... }","printf retarget function for UART, SWO, or CDC"
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_MSI; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_MSI; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure USB peripheral clock
"HAL_GPIO_WritePin(DW_NSS_GPIO_Port, DW_NSS_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(DW_RESET_GPIO_Port, DW_RESET_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"APP_PPRINTF(""\r\n -------------- Starting GNSE basic bootloader -------------- \r\n"");",Print bootloader start message
Bootloader_Init();,Initialize bootloader
Bootloader_HandleInput();,Handle bootloader input
Bootloader_GetState();,Get bootloader state
"APP_PPRINTF(""\r\n Jumping to application at APP_ADDRESS: 0x%08x \r\n"", APP_ADDRESS);",Print message for jumping to application
"APP_PPRINTF(""\r\n Jumping to ST bootloader at SYSMEM_ADDRESS : 0x%08x \r\n"", ST_BOOTLOADER_SYSMEM_ADDRESS);",Print message for jumping to ST bootloader
"APP_PPRINTF(""\r\n Un-handled bootloader state \r\n"");",Print message for unhandled bootloader state
GNSE_TRACER_DEINIT();,Deinitialize Tracer/Logger
Bootloader_DeInit();,Deinitialize bootloader
Bootloader_Jump();,Jump to application or system bootloader
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3 | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
bool uartInit(void) { ... },Initialize UART module
"bool uartOpen(uint8_t channel, uint32_t baud) { ... }",Open UART channel with specified baud rate
HAL_UART_Init(p_uart->handle);,Initialize UART hardware
"qbufferCreate(&p_uart->qbuffer_rx, p_uart->rx_buf, UART_RX_BUF_LENGTH);",Create receive buffer queue
uartStartRx(channel);,Start UART receive operation
bool uartClose(uint8_t channel) { ... },Close UART channel
HAL_UART_DeInit(p_uart->handle);,Deinitialize UART hardware
void uartStartRx(uint8_t channel) { ... },Start UART receive operation
"HAL_UART_Receive_IT(p_uart->handle, p_uart->rx_buf, 1);",Start UART receive in interrupt mode
"HAL_UART_Receive_DMA(p_uart->handle, (uint8_t *)p_uart->qbuffer_rx.p_buf, p_uart->qbuffer_rx.length);",Start UART receive in DMA mode
uint32_t uartAvailable(uint8_t channel) { ... },Check available data in UART receive buffer
void uartFlush(uint8_t channel) { ... },Flush UART receive buffer
uint8_t uartGetch(uint8_t channel) { ... },Read single character from UART
"HAL_UART_Transmit(p_uart->handle, (uint8_t*)p_data, length, 1000);",Transmit data over UART in polling mode
"HAL_UART_Transmit_DMA(p_uart->handle, p_data, length);",Transmit data over UART in DMA mode
"int32_t uartPrintf(uint8_t channel, const char *fmt, ...) { ... }",Print formatted string to UART
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { ... },"Initialize UART MSP (GPIO, DMA, and clock)"
__HAL_RCC_DMA1_CLK_ENABLE();,Enable DMA1 clock
hdma_usart1_rx.Instance = DMA1_Channel5; ... if (HAL_DMA_Init(&hdma_usart1_rx) != HAL_OK) { Error_Handler(); },USART1 DMA Init
void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle) { ... },Deinitialize UART MSP
"HAL_GPIO_DeInit(GPIOB, GPIO_PIN_6|GPIO_PIN_7);",Deinitialize USART1 GPIO pins
HAL_DMA_DeInit(uartHandle->hdmarx);,USART1 DMA DeInit
LogInit();,Configure uart1 for printf
__HAL_RCC_PCA_CLK_ENABLE();,Enable PCA clock
sPcaHandle.Instance = PCAx; sPcaHandle.Init.ClkSrcSel = PCA_CLOCK_SOURCE_PCLKDIV8; sPcaHandle.Init.RunInIdleMode = PCA_IDLEMODE_DISABLE; HAL_PCA_OC_Init(&sPcaHandle);,Initialize LPTIMx peripheral as follows: Clock = PCLK/8 = 24M/8 = 3MHz
"sPcaOcInit.CompareEnable = PCA_OC_ENABLE; sPcaOcInit.PwmEnable = PCA_PWM_ENABLE; sPcaOcInit.Period = 0x80; HAL_PCA_OC_ConfigChannel(&sPcaHandle, &sPcaOcInit, PCA_CHANNEL_2);","Configure PCA for 50% duty cycle, period = (0x80*2)*(1/3M) = 84us"
"HAL_PCA_OC_Start(&sPcaHandle, PCA_CHANNEL_2);",PCA output compare enable
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HIRC; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure HIRC oscillator
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct);,"Initializes the CPU, AHB and APB buses clocks"
"BSP_PB_Init(BUTTON_WAKEUP, BUTTON_MODE_EXTI);",Configure Joystick sel-button in Interrupt mode
RngHandle.Instance = RNG; ... HAL_RNG_DeInit(&RngHandle);,DeInitialize the RNG peripheral
HAL_RNG_Init(&RngHandle);,Initialize the RNG peripheral
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void Error_Handler(void) { while(1) { BSP_LED_Toggle(LED3); HAL_Delay(500); } },This function is executed in case of error occurrence
GPIOB->BSRR |= GPIO_PIN_10; HAL_Delay(500); GPIOA->BSRR |= GPIO_PIN_5; HAL_Delay(500); GPIOA->BSRR |= GPIO_PIN_0; HAL_Delay(500);,Turn on LEDs sequentially with 500ms delay
GPIOB->BRR |= GPIO_PIN_10; HAL_Delay(500); GPIOA->BRR |= GPIO_PIN_5; HAL_Delay(500); GPIOA->BRR |= GPIO_PIN_0; HAL_Delay(500);,Turn off LEDs sequentially with 500ms delay
"USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, report, 8);",Send USB HID report
"report[0] = 0; report[3] = 0; USBD_CUSTOM_HID_SendReport(&hUsbDeviceFS, report, 8);",Clear report data and send updated HID report
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,"Initializes the CPU, AHB and APB buses clocks"
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);","Initializes the CPU, AHB and APB buses clocks"
"void MX_GPIO_Init(void) { ... HAL_GPIO_Init(GPIOC, &GPIO_InitStruct); ... HAL_GPIO_Init(GPIOA, &GPIO_InitStruct); ... HAL_GPIO_Init(GPIOB, &GPIO_InitStruct); }",GPIO Initialization Function
bool is_appcode_exist() { uint32_t *mem = (uint32_t*)APP_ADDR; if ((mem[0] == 0x00000000 || mem[0] == 0xFFFFFFFF) && (mem[1] == 0x00000000 || mem[1] == 0xFFFFFFFF) && (mem[2] == 0x00000000 || mem[2] == 0xFFFFFFFF) && (mem[3] == 0x00000000 || mem[3] == 0xFFFFFFFF)) { return false; } else { return true; } },Check if valid application code exists at APP_ADDR
void jmp_to_appcode() { uint32_t jump_addr = *((__IO uint32_t*)(APP_ADDR+4u)); HAL_DeInit(); __set_MSP(*(__IO uint32_t*)APP_ADDR); SCB->VTOR = APP_ADDR; ((void (*) (void)) (jump_addr)) (); },Jump to application code
"bool is_button_down() { if (HAL_GPIO_ReadPin(BTN_GPIO_PORT, BTN_GPIO_PIN) == GPIO_PIN_RESET) { HAL_Delay(200); return (HAL_GPIO_ReadPin(BTN_GPIO_PORT, BTN_GPIO_PIN) == GPIO_PIN_RESET); } return false; }",Check if button is pressed with debouncing
LED_ON; HAL_Delay(LED_On_Time); LED_OFF; HAL_Delay(LED_On_Time*3);,Handle LED slow blink pattern
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Initializes the CPU, AHB and APB buses clocks"
toggle_gpio(led); HAL_Delay(5000); toggle_gpio(led2); HAL_Delay(1000); toggle_gpio(led); toggle_gpio(led2); toggle_gpio(led3); HAL_Delay(5000); toggle_gpio(led3); toggle_gpio(led2); HAL_Delay(1000); toggle_gpio(led2); HAL_Delay(50);,Toggle LEDs in a specific sequence with delays
cmd_init();,Initialize command parser
"HAL_UART_Receive_IT(&huart1, (uint8_t *)recv_temp_data, 1);",Enable UART receive interrupt
"void led1_on(void) { HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_RESET); }",Turn on LED1
"void led1_off(void) { HAL_GPIO_WritePin(LED1_GPIO_Port, LED1_Pin, GPIO_PIN_SET); }",Turn off LED1
"void led0_on(void) { HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_RESET); }",Turn on LED0
"void led0_off(void) { HAL_GPIO_WritePin(LED0_GPIO_Port, LED0_Pin, GPIO_PIN_SET); }",Turn off LED0
"void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { ... cmd_parsing(recv_buf); ... HAL_UART_Receive_IT(&huart1, (uint8_t *)recv_temp_data, 1); }",Handle UART receive complete callback and parse received command
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters
"void drvExtiDetachInterrupt(uint8_t ch) { HAL_NVIC_DisableIRQ(drv_exti_tbl[ch].irq_num); HAL_GPIO_DeInit(drv_exti_tbl[ch].port, drv_exti_tbl[ch].pin); ... }",Detach interrupt from EXTI channel
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { switch (GPIO_Pin) { case GPIO_PIN_0: (*drv_exti_tbl[0].callback_func)(drv_exti_tbl[0].func_arg); break; ... } },EXTI line detection callbacks
void EXTI0_IRQHandler(void) { HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_0); },Handle EXTI0 interrupt
Hal_gpio_init();,Initialize GPIO
Hal_uart_init();,Initialize UART
"static bool CheckBootMode(void) { return KeyHw_IsPressed(0, 0); }","Check if HW (0,0) key is pressed to enter boot mode"
static void Jump(uint32_t address) { ... Jump_To_Application(); },Jump to application at specified address
static void Kernel_Init(void) { ... Kernel_task_create(Polling_task); ... },Initialize kernel and create tasks
App_msc_Init();,Initialize MSC application in boot mode
App_hid_Init();,Initialize HID application
Kernel_start();,Start the kernel
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_PLL; HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);,Configure USB peripheral clock
BSP_LCD_GLASS_Init();,Initialize LCD glass display
Button_init();,Initialize button
__HAL_RCC_GPIOA_CLK_ENABLE(); __HAL_RCC_GPIOB_CLK_ENABLE(); __HAL_RCC_GPIOE_CLK_ENABLE();,Enable GPIO port clocks
MX_USART2_UART_Init(); HAL_UART_MspInit(&huart2);,Initialize USART2 and its MSP
ADC_GPIO_Init(); ADC_init(); TIM4_Init();,"Initialize ADC, GPIO, and TIM4 for ADC operation"
HAL_ADC_Start_IT(&adc1h);,Start ADC in interrupt mode
BSP_LED_Init(LED_GREEN);,Initialize green LED
COMP1_Init(); COMP_GPIO_Init(); timer3Config(); HAL_COMP_Start(&hcomp1);,"Initialize comparator, GPIO, timer, and start comparator"
"arm_rfft_fast_init_f32(&data,1024); fft_generate_test_data(input, 1024, frq); arm_rfft_fast_f32(&data, input, output, 0); arm_cmplx_mag_f32(output, realOutput, 1024);",Perform FFT processing on input data
"displayUnit(speed, unit);",Display speed with specified unit
ILI9341_Init();,Initialize LCD
ILI9341_Fill(color[idx++]);,Fill LCD with color
"HAL_GPIO_WritePin(GPIOB, RESET_Pin|LED_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(SPI1_NSS_GPIO_Port, SPI1_NSS_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(DC_GPIO_Port, DC_Pin, GPIO_PIN_SET);",Configure GPIO pin Output Level
"sConfig.Channel = ADCx_CHANNEL; ... if(HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK) { Error_Handler(); }",Configure ADC regular channel
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void led_routine(){ ... },LED control
HAL_TIM_Base_Stop_IT(htim3);,"Triggered by USER_Btn, for calibration purpose only"
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_7);","Triggered by USER_Btn, for calibration purpose only"
"__HAL_TIM_SET_COMPARE(htim2, TIM_CHANNEL_1, 73);",Sets angle of servo to 0 degrees - default position
"sprintf(pos_dist, ""%.02f"", d);",printing real-time position and current setpoint
"LCD_printStr(hlcd1, ""DISTANCE: "");",printing real-time position and current setpoint
"LCD_printStr(hlcd1, pos_dist);",printing real-time position and current setpoint
"LCD_printStr(hlcd1, sp_str);",printing real-time position and current setpoint
"if(HAL_ADC_PollForConversion(&hadc1, 500) == HAL_OK){ sample_in = HAL_ADC_GetValue(&hadc1); }",reading ADC register value and converting it into setpoint value
return abs((sample_in/100) - 20)+10;,reading ADC register value and converting it into setpoint value
"main_loop(&hspi2, &htim2);",Start main application loop
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI|RCC_OSCILLATORTYPE_HSI48; ... if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB; PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure USB peripheral clock
htim2.Instance = TIM2; ... if (HAL_TIM_Base_Init(&htim2) != HAL_OK) { Error_Handler(); },Initialize TIM2 peripheral
"HAL_GPIO_WritePin(GPIOC, LD3_Pin|LD6_Pin|LD4_Pin|LD5_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"RtcHandle.Instance = RTC; ... if (HAL_RTC_Init(&RtcHandle) != HAL_OK) { logPrintf(""RTC     \t\t: Fail\r\n""); return false; }",Configure RTC prescaler and RTC data registers
RTC_CalendarConfig();,Configure RTC Calendar
"rtcWriteBackupData(RTC_CFG_DATA_2, reset_time);",Writes a data in a RTC Backup data Register
time_t rtcGetTime() { ... },Get the RTC current Time
uint32_t rtcGetSecondsFromPower(void) { ... },Calculate seconds since power-on
uint32_t rtcGetSecondsFromReset(void) { ... },Calculate seconds since reset
void rtcSetTime(time_t time_data) { ... },Set RTC time and date
"HAL_RTC_SetDate(&RtcHandle,&sdatestructure,RTC_FORMAT_BIN);",Set RTC date
"HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BIN);",Set RTC time
"time_t rtcMakeTime(RTC_DateTypeDef *p_date, RTC_TimeTypeDef *p_time) { ... }",Assemble time elements into time_t
"void rtcWriteBackupData(uint32_t index, uint32_t data) { HAL_RTCEx_BKUPWrite(&RtcHandle, index, data); }",Write data to RTC backup register
"uint32_t rtcReadBackupData(uint32_t index) { return HAL_RTCEx_BKUPRead(&RtcHandle, index); }",Read data from RTC backup register
static void RTC_CalendarConfig(void) { ... },Configure the current time and date
"HAL_RTC_SetTime(&RtcHandle, &stimestructure, RTC_FORMAT_BCD);",Set Time: 02:00:00
"HAL_RTCEx_BKUPWrite(&RtcHandle, RTC_CFG_DATA_1, 0x32F2);",Writes a data in a RTC Backup data Register1
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc) { ... },Configure RTC MSP
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI; ... if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { },Configure LSE as RTC clock source
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_RTC; PeriphClkInitStruct.RTCClockSelection = RCC_RTCCLKSOURCE_LSI; ... if(HAL_RCCEx_PeriphCLKConfig(&PeriphClkInitStruct) != HAL_OK) { },Configure RTC peripheral clock
void HAL_RTC_MspDeInit(RTC_HandleTypeDef *hrtc) { ... },RTC MSP De-Initialization
__HAL_RCC_RTC_DISABLE();,Disable the Peripheral's clock
HAL_PWR_DisableBkUpAccess();,Disables the PWR Clock and Disables access to the backup domain
"printf(""CONFIGURACION CORRECTA DEL MAESTRO\r\n"");",Print configuration success message
"HAL_GPIO_WritePin(NSS_Master_GPIO_Port, NSS_Master_Pin, GPIO_PIN_SET);",Set NSS pin high
"HAL_GPIO_WritePin(NSS_Master_GPIO_Port, NSS_Master_Pin, GPIO_PIN_RESET);",Set NSS pin low to start SPI communication
"HAL_SPI_TransmitReceive(&hspi1, &i, &RxData, 1, HAL_MAX_DELAY);",Transmit and receive SPI data
"printf(""recibido del esclavo->%d\r\n"", RxData);",Print received SPI data
"HAL_GPIO_WritePin(NSS_Master_GPIO_Port, NSS_Master_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
BSP_LED_Init(LED_GREEN);,Initialize STM32F429I-DISCO's LEDs
BSP_LED_Toggle(LED_GREEN);,Toggle LED
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_6);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
init_usartdata();,Initialize USART data buffers
usartdata_start_receive();,Start UART receive operation
"printf(""\r\ninit ok"");",Print initialization success message
usartdata_process();,Process received UART data
"printf(""\r\nreceived len %d"", current_buffer->valid_len);",Print length of received data
"printf(""\r\nreceived data:"");",Print received data
"set_databuffer_owner(current_buffer, USED_BY_DMA);",Mark buffer as used by DMA
"int fputc(int ch, FILE *f) { ... }",Retargets the C library printf function to the USART
RCC_OscInitTypeDef oscinitstruct = {0}; ... if (HAL_RCC_OscConfig(&oscinitstruct)!= HAL_OK) { while(1); },Enable HSI and activate PLL with HSi_DIV2 as source
"printf(""Started! \n\r"");",Print startup message
"HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5);",Toggle the LED between on and off
"printf(""Received value %ld \n\r"", adc_val);","Outputting the sensor value via UART, if value is more than 1"
"printf(""Too low %ld \n\r"", adc_val);",Output low word string if value is lower or equal to 1
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK ... if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_ADC; PeriphClkInit.AdcClockSelection = RCC_ADCPCLK2_DIV2; ... if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Configure ADC peripheral clock
int __io_putchar(int ch) { ... },Retargets printf to UART
mainEntry();,Start main application entry
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { BSP_Background(); },Period elapsed callback in non blocking mode
void HAL_TIM_Base_MspInit(TIM_HandleTypeDef *htim) { ... },TIM MSP Initialization
"HAL_NVIC_SetPriority(TIM3_IRQn, 0, 1); HAL_NVIC_EnableIRQ(TIM3_IRQn);",Configure the NVIC for TIMx
void BSP_Config(void) { ... },Initializes the STM32F429I-DISCO's LCD and LEDs resources
BSP_LED_Init(LED3);,Initialize STM32F429I-DISCO's LEDs
"BSP_TS_Init(240, 320);",Initialize the Touch screen
"HAL_UART_Receive_IT(&huart3, &rx_data,1);",Enable UART receive interrupt
"void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart->Instance == USART3) { if(rx_data=='t') { sprintf(number, ""%d"", num++); HAL_UART_Transmit(&huart3,(uint8_t *)number,3,10); } HAL_UART_Receive_IT(&huart3, &rx_data,1); } }","Handle UART receive complete callback, transmit incremental number on receiving 't'"
void Error_Handler(void) { __disable_irq(); while (1) { } },This function is executed in case of error occurrence
MX_IPCC_Init();,IPCC initialisation
BSP_LED_Init(LED_BLUE); BSP_LED_Init(LED_GREEN); BSP_LED_Init(LED_RED);,"Initialize the LEDs (by convention, this is only done by CPU1)"
"HAL_IPCC_ActivateNotification(&hipcc, ChannelId, IPCC_CHANNEL_DIR_TX, Simplex_Send_callback);",Configure a user callback. The callback is triggered when the other cpu has finished to handle the message. (IPCC_CHANNEL_DIR_TX)
"memset((char*)sharedBuffer, '\0', BUFFER_SIZE);",Initialize the content of the sharedBuffer
"snprintf((char*)sharedBuffer, BUFFER_SIZE, ""cpu1->cpu2:%04lu"", (long unsigned int) index++);",Write communication data to memory
"HAL_IPCC_NotifyCPU(&hipcc, ChannelId, IPCC_CHANNEL_DIR_TX);",Notify remote cpu of the on-going transaction
"HAL_IPCC_DeActivateNotification(&hipcc, ChannelId, IPCC_CHANNEL_DIR_TX);",Remove the callback management. (No more interrupt are triggered on message reception)
BSP_LED_On(LED_BLUE);,"At the end of this example, set the Led On"
"void Simplex_Send_callback(struct __IPCC_HandleTypeDef *hipcc, uint32_t ChannelIndex, IPCC_CHANNELDirTypeDef ChannelDir) { Simplex_Send = 1; }",Callback to set Simplex_Send flag when CPU2 handles the message
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK2|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);","Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
void Error_Handler(void) { BSP_LED_On(LED_RED); while(1) { } },This function is executed in case of error occurrence
"BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);",Configure User push-button
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == TAMPER_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback
init_sysclk_216MHz();,Configure the stm32f7 discovery board to operate at 216MHz
configure_gpio();,Initialise the gpio pins
"HAL_GPIO_TogglePin(LED_PORT, LED_PIN);",Toggle the led on the gpio pin
HAL_Delay(1000);,Wait for 1 second
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure power settings on the chip
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Configure the oscillator and phase-locked loops so the chip runs at 168MHz
HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 216 MHz frequency
"HAL_GPIO_Init(LED_PORT, &gpio_init_structure);",Complete initialisation
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable MSI Oscillator
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0);","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
CrypHandle.Init.DataType = CRYP_DATATYPE_8B; CrypHandle.Init.KeySize = CRYP_KEYSIZE_128B; CrypHandle.Init.pKey = aTDESKey; HAL_CRYP_Init(&CrypHandle);,Set the CRYP parameters
"HAL_CRYP_TDESECB_Encrypt_DMA(&CrypHandle, aPlaintext, 48, aEncryptedtext);",Start the TDES encryption in ECB chaining mode
"void StepMotorDriver_Iint(TIM_HandleTypeDef *htim) { ... __HAL_TIM_SET_PRESCALER(htim, PWM_PSC); }","Initialize step motor driver, configure direction, enable pin, microstep resolution, and timer prescaler"
"HAL_GPIO_WritePin(GPIOB, PB13_MS1_Pin, GPIO_PIN_SET);","StepMotor microstep MS1 , HIGH"
"void StepMotor_Control(TIM_HandleTypeDef *htim, double angular_velocity, uint8_t motor) { ... HAL_TIM_PWM_Start_IT(htim, TIM_CHANNEL_1); }","Control step motor speed and direction based on angular velocity, configure PWM for specified motor"
"void StepMotor_Stop(TIM_HandleTypeDef *htim) { HAL_TIM_PWM_Stop_IT(htim, TIM_CHANNEL_1); }",Stop PWM output for step motor
static void i2c_start(void) { ... I2C_SIOC_L(); delay(); },The start of data transmission occurs when SIO_D is driven low while SIO_C is high
static void i2c_stop(void) { ... I2C_SIOD_H(); delay(); },The stop of data transmission occurs when SIO_D is driven high while SIO_C is high
"int soft_i2c_read_bytes(uint8_t slv_addr, uint8_t *buf, int len, bool stop) { ... return ret; }",Read multiple bytes from I2C slave
"int soft_i2c_write_bytes(uint8_t slv_addr, uint8_t *buf, int len, bool stop) { ... return ret; }",Write multiple bytes to I2C slave
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2|RCC_PERIPHCLK_USART3|RCC_PERIPHCLK_LPUART1|RCC_PERIPHCLK_SAI2|RCC_PERIPHCLK_I2C2|RCC_PERIPHCLK_I2C3|RCC_PERIPHCLK_I2C4|RCC_PERIPHCLK_USB|RCC_PERIPHCLK_SDMMC1|RCC_PERIPHCLK_ADC; ... HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit);,Configure peripheral clocks
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/8000);,Configure the Systick interrupt time
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK_DIV8);,Configure the Systick
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_RESET);",Turn on PA5 and turn off PB14
HAL_Delay(1000);,Delay 1s
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET); HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14, GPIO_PIN_SET);",Turn off PA5 and turn on PB14
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Initializes the RCC Oscillators according to the specified parameters
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4);","Initializes the CPU, AHB and APB buses clocks"
init_random();,Initialize random number generator
uint32_t rnd = (get_random_int() % 6) + 1;,Generate random number between 1 and 6 for dice roll
"if(rnd == 1){ write_gpio(ledUL, LOW); ... write_gpio(ledBR, LOW); }",Display dice roll of 1 on LEDs
"else if (rnd == 2){ write_gpio(ledUL, HIGH); ... write_gpio(ledBR, HIGH); }",Display dice roll of 2 on LEDs
"else if (rnd == 3){ write_gpio(ledUL, HIGH); ... write_gpio(ledBR, HIGH); }",Display dice roll of 3 on LEDs
"else if (rnd == 4){ write_gpio(ledUL, HIGH); ... write_gpio(ledBR, HIGH); }",Display dice roll of 4 on LEDs
"else if (rnd == 5){ write_gpio(ledUL, HIGH); ... write_gpio(ledBR, HIGH); }",Display dice roll of 5 on LEDs
"else if (rnd == 6) { write_gpio(ledUL, HIGH); ... write_gpio(ledBR, HIGH); }",Display dice roll of 6 on LEDs
"HAL_UART_Receive_IT(&huart2, buffer, 1);",Enable UART receive interrupt
"HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1); ... HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_4);",Start PWM on TIM4 channels
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { ... },Handle UART receive complete callback
if(buffer[0] == 'a') { ... },Process received UART data starting with 'a' for PWM control
"__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_1, angle_num*64000/360);",Set PWM compare value for channel 1 based on angle
"__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_2, angle_num*64000/360);",Set PWM compare value for channel 2 based on angle
"__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_3, angle_num*64000/360);",Set PWM compare value for channel 3 based on angle
"__HAL_TIM_SET_COMPARE(&htim4, TIM_CHANNEL_4, angle_num*64000/360);",Set PWM compare value for channel 4 based on angle
bool uartInit(void) { ... },Initialize UART driver
"bool uartOpen(uint8_t ch, uint32_t baud) { ... }",Open UART channel with specified baud rate
bool uartFlush(uint8_t ch) { ... },Flush UART buffer
uint32_t uartGetBaud(uint8_t ch) { ... },Get UART baud rate
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle) { ... },"Configure UART MSP (GPIO, DMA, clocks)"
Init_OLED();,Initialize OLED display
LifeGame();,Run the Game of Life application
app_main( void ) { ... },Main application entry point
HAL_UART_Init(&GLOBAL_UART_HANDLE);,Initialize UART for communication
"HAL_UART_PRINTF(""FreeRTOS!"");",Print FreeRTOS startup message
"if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13) != 0){ BIOS_START(); }",Start BIOS if button is pressed
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);",Toggle the green LED
"void vApplicationStackOverflowHook( TaskHandle_t pxTask, char *pcTaskName ) { ... }",Handle stack overflow in FreeRTOS
void vApplicationMallocFailedHook( void ) { ... },Handle malloc failure in FreeRTOS
"void vApplicationGetIdleTaskMemory( StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize ) { ... }",Provide memory for FreeRTOS idle task
"void vApplicationGetTimerTaskMemory( StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize ) { ... }",Provide memory for FreeRTOS timer task
xmodem_app_init();,Initialize XModem application
"if(HAL_GPIO_ReadPin(BTN_GPIO_Port, BTN_Pin) == SET) { xmodem_app_unit_test(); }",Run XModem unit test if button is pressed
"HAL_GPIO_TogglePin(LD1_GPIO_Port, LD1_Pin);",Toggle LED
"HAL_GPIO_TogglePin(LD4_GPIO_Port, LD4_Pin);",Toggle LED
MX_I2C2_Init();,Initialize I2C2 peripheral
"micronet_set_descriptor(""RPower 2.0"");",Set Micronet descriptor
board_init();,Initialize board components
void micronet_handler() { ... },Handle Micronet requests
BSP_LED_Init(LED2); BSP_LED_Init(LED1); BSP_LED_Init(LED3);,"Configure LED2, LED1, LED3"
if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != 0x00u) { ... },Check if the system has resumed from IWDG reset
__HAL_RCC_CLEAR_RESET_FLAGS();,Clear reset flags in any cases
GetLSIFrequency();,Get the LSI frequency: TIM17 is used to measure the LSI frequency
"BSP_PB_Init(BUTTON_SW1, BUTTON_MODE_EXTI);",Configure User push-button (B1)
HAL_IWDG_Refresh(&hiwdg);,Refresh IWDG: reload counter
void HAL_TIM_IC_CaptureCallback(TIM_HandleTypeDef *htim) { ... },Input Capture callback in non blocking mode
MX_I2C1_Init();,Initialize I2C1
MX_I2C2_Init();,Initialize I2C2
LCD_Clear(WHITE);,Clear LCD with white background
"LCD_Show_Image(0,0,240,93,gImage_Bossaylogo);",Display Bossay logo on LCD
"LCD_ShowString(20, 130, 240, 16, 16, ""Powered by Huawei LiteOS!"");",Display text on LCD
"LCD_ShowString(2, 170, 240, 16, 16, ""System intializing......"");",Display system initializing message
void delay_us(uint32_t nus) { ... },Microsecond delay function
void delay_ms(uint16_t nms) { ... },Millisecond delay function
BSP_LED_Init(LED3); BSP_LED_Init(LED4);,Configure LED3 and LED4 on STM32F0308-Discovery
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);",Initialize User_Button on STM32F0308-Discovery
BlinkSpeed = 1;,Initiate Blink Speed variable
if(BSP_PB_GetState(BUTTON_USER) == GPIO_PIN_SET) { ... BlinkSpeed++; if(BlinkSpeed == 3) { BlinkSpeed = 0; } },"Check if the user button is pressed, increment BlinkSpeed and reset to 0 if it reaches 3"
BSP_LED_On(LED4); HAL_Delay(1000); BSP_LED_Off(LED4);,"Turn on LD4 Blue LED during 1s each time User button is pressed, then turn off after 1s"
if(BlinkSpeed == 2) { BSP_LED_Toggle(LED3); HAL_Delay(100); },LED3 toggles each 100 ms when BlinkSpeed is 2
else if(BlinkSpeed == 1) { BSP_LED_Toggle(LED3); HAL_Delay(200); },LED3 toggles each 200 ms when BlinkSpeed is 1
else { BSP_LED_Off(LED3); },LED3 Off when BlinkSpeed is 0
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; ... HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and Activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1); ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1);",Select PLL as system clock source and configure the HCLK and PCLK1 clocks dividers
if(__HAL_PWR_GET_FLAG(PWR_FLAG_SB) != RESET) { __HAL_PWR_CLEAR_FLAG(PWR_FLAG_SB); ETH_PhyExitFromPowerDownMode(); ... },Check and handle if the system was resumed from Standby mode
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_GPIO);",Configure USER Button
ETH_PhyEnterPowerDownMode();,Ethernet PHY must be in low power mode in order to have the lowest current consumption
StopMode_Measure();,"STOP Mode Entry: RTC Clocked by LSI, Regulator in LP mode, HSI, HSE OFF and LSI OFF if not used as RTC Clock source, No IWDG, FLASH in deep power down mode, Automatic Wake-up using RTC clocked by LSI (after ~20s)"
void Error_Handler(void) { BSP_LED_On(LED2); while(1) { } },This function is executed in case of error occurrence
void HAL_RTCEx_WakeUpTimerEventCallback(RTC_HandleTypeDef *hrtc) { uwCounter = 1; },Wake Up Timer callback
COM_Init();,Configure Communication module
BSP_LED_Init(LED3);,Initialize LED on board
BSP_LED_On(LED3);,Turn LED3 on to signify end of test with success status
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK3|RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; ... HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2);","Configure the SYSCLKSource, HCLK, PCLK1 and PCLK2 clocks dividers"
"GPIO_PinState pin_state = HAL_GPIO_ReadPin(GPIOA, GPIO_PIN_3); if (pin_state == GPIO_PIN_RESET) { HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET); HAL_IWDG_Refresh(&hiwdg); }",switch led on and kick watchdog if PA3 is low
"HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Configure GPIO pin : PC13
LED_Init();,???LED
"LCD_ShowString(30, 50, 200, 16, 16, ""WarShip STM32 ^_^"");",Display string on LCD
LED0 = !LED0; delay_ms(500);,Toggle LED0 every 500ms
port_main();,jump to BTstack port
prvSetupHardware();,Set up the clocks and memory interface
vTaskStartScheduler();,Start the scheduler
"static void prvBlinkTask( void *pvParameters ) { ... HAL_GPIO_TogglePin(LED1_GPIO_PORT, LED1_PIN); }",Toggle LED1 in a FreeRTOS task
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; ... HAL_RCC_OscConfig(&oscinitstruct);,Enable HSI and activate PLL with HSI_DIV2 as source
"clkinitstruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); ... HAL_RCC_ClockConfig(&clkinitstruct, FLASH_LATENCY_2);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
LED1_GPIO_CLK_ENABLE();,Enable GPIO Clock (to be able to program the configuration registers)
"HAL_GPIO_Init(LED1_GPIO_PORT, &GPIO_InitStruct);",Configure IO in output push-pull mode to drive external LEDs
"uint8_t uart1_init(uint32_t baud_rate) { ... HAL_UART_Init(&g_uart1_handle); ... HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t *)&g_uart1_buffer, 1); }","uart1 init with 8 data bits, 1 stop bit and no parity"
uint8_t uart1_deinit(void) { HAL_UART_DeInit(&g_uart1_handle); ... },uart1 deint
"uint8_t uart1_write(uint8_t *buf, uint16_t len) { ... HAL_UART_Transmit_IT(&g_uart1_handle, (uint8_t *)buf, len); ... }",uart1 write data
"uint16_t uart1_read(uint8_t *buf, uint16_t len) { ... memcpy(buf, g_uart1_rx_buffer, read_len); g_uart1_point = 0; ... }",uart1 read data
uint8_t uart2_deinit(void) { HAL_UART_DeInit(&g_uart2_handle); ... },uart2 deint
"HAL_RCC_MCOConfig(RCC_MCO1, RCC_MCO1SOURCE_HSI48, RCC_MCODIV_2);",Configure MCO output
"void SPIWriteProcRamFifo(spiCTX* ctx) { ... SPIWriteRegisterDirect(ctx, ECAT_PRAM_WR_ADDR_LEN, (0x00001200 | (((uint32_t)TOT_BYTE_NUM_IN) << 16))); ... HAL_SPI_Transmit(ctx->spi, ctx->bIn->Byte, FST_BYTE_NUM_ROUND_IN, SPI_TIMEOUT_MAX); ... }",Write to process RAM FIFO via SPI
"void SPIReadProcRamFifo(spiCTX* ctx) { ... SPIWriteRegisterDirect (ctx, ECAT_PRAM_RD_ADDR_LEN, (0x00001000 | (((uint32_t)TOT_BYTE_NUM_OUT) << 16))); ... HAL_SPI_Receive(ctx->spi, ctx->bOut->Byte, FST_BYTE_NUM_ROUND_OUT, SPI_TIMEOUT_MAX); ... }",Read from process RAM FIFO via SPI
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_LSI|RCC_OSCILLATORTYPE_HSE;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.HSEState = RCC_HSE_ON;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.LSIState = RCC_LSI_ON;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLM = 25;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLN = 432;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_OscInitStruct.PLL.PLLQ = 9;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
if (HAL_PWREx_EnableOverDrive() != HAL_OK),Activate the Over-Drive mode
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4;,"Initializes the CPU, AHB and APB buses clocks"
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Initializes the CPU, AHB and APB buses clocks"
if (htim->Instance == TIM6) { HAL_IncTick(); },"This function is called  when TIM6 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
"void assert_failed(uint8_t *file, uint32_t line)",Reports the name of the source file and the source line number where the assert_param error has occurred.
void analogWrite(uint16_t Res),analogWrite
void net_init(void),net_init
"IP4_ADDR(&ipaddr, IP_ADDRESS[0], IP_ADDRESS[1], IP_ADDRESS[2], IP_ADDRESS[3]);",IP addresses initialization without DHCP (IPv4)
"IP4_ADDR(&netmask, NETMASK_ADDRESS[0], NETMASK_ADDRESS[1] , NETMASK_ADDRESS[2], NETMASK_ADDRESS[3]);",IP addresses initialization without DHCP (IPv4)
"IP4_ADDR(&gw, GATEWAY_ADDRESS[0], GATEWAY_ADDRESS[1], GATEWAY_ADDRESS[2], GATEWAY_ADDRESS[3]);",IP addresses initialization without DHCP (IPv4)
"(void)netif_add(&gnetif, &ipaddr, &netmask, &gw, NULL, ethernetif_init, tcpip_input);",add the network interface (IPv4/IPv6) without RTOS
if (netif_is_link_up(&gnetif)) { gnetif.flags |= NETIF_FLAG_LINK_UP; netif_set_up(&gnetif); } else { netif_set_down(&gnetif); },When the netif is fully configured this function must be called
return (uint32_t)LOS_TickCountGet();,HAL_GetTick
"void _Error_Handler(char *file, int line)",This function is executed in case of error occurrence.
void SystemClock_Config(void),SystemClock_Config
void hieth_hw_init(void),hieth_hw_init
void atiny_usleep(unsigned long usec),atiny_usleep
"int atiny_random(void *output, size_t len)",atiny_random
void atiny_reboot(void),atiny_reboot
HAL_NVIC_SystemReset();,atiny_reboot
void MX_MEMS_Init(void),Initialize the peripherals and the MEMS components
void MX_IKS01A2_LSM6DSL_6DOrientation_Init(void),Initialize the LSM6DSL 6D Orientation application
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Initialize button
void BSP_PB_Callback(Button_TypeDef Button),BSP Push Button callback
PushButtonDetected = 1;,BSP Push Button callback
void MX_IKS01A2_LSM6DSL_6DOrientation_Process(void),Process of the LSM6DSL 6D Orientation application
SendOrientationRequest  = 1;,Request to send actual 6D orientation
static void Send_Orientation(void),Send actual 6D orientation to UART
bool is_appcode_exist(),is_appcode_exist
void jmp_to_appcode(),jmp_to_appcode
uint32_t jump_addr = *((__IO uint32_t*)(APP_ADDR+4u));,Function pointer to the address of the user application.
__set_MSP(*(__IO uint32_t*)APP_ADDR);,Change the main stack pointer.
SCB->VTOR = APP_ADDR;,jmp_to_appcode
bool is_button_down(),is_button_down
"return (HAL_GPIO_ReadPin(BTLDR_EN_GPIO_Port, BTLDR_EN_Pin) == GPIO_PIN_RESET);",is_button_down
HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1 Judah);,Configure the main internal regulator output voltage
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_I2C1;,Initializes the peripherals clocks
PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;,Initializes the peripherals clocks
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;,Initializes the peripherals clocks
void SystemClock_Config(void),Setup the system clock
void LedBlinky_Task(void *pvParameters),Task for blinking an LED every second
"HAL_GPIO_TogglePin(LED1_PORT, LED1_PIN);",Task for blinking an LED every second
vTaskDelay(1000/portTICK_PERIOD_MS);,Task for blinking an LED every second
"int fputc(int ch, FILE *f) { uint8_t temp[1] = {ch} ; HAL_UART_Transmit(&huart2, temp, 1, 50) ; return(ch) ; }",Retargets the C library printf function to the USART.
"MX_USART2_UART_Init(void) { huart2.Instance = USART2; huart2.Init.BaudRate = 9600; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart2) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); } }",USART2 init function
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency (see datasheet).
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
if (HAL_PWREx_EnableOverDrive () != HAL_OK) { Error_Handler (); },Activate the Over-Drive mode
"int _write (int file,char*ptr,int len) { int DataIdx; for (DataIdx = 0; DataIdx < len; DataIdx++) { ITM_SendChar (*ptr++); } return len; }",Retargets the C library printf function to ITM
uint32_t get_encoder_value () { return TIM5->CNT; },Returns the current encoder counter value
uint8_t get_encoder_dir () { return TIM5->CR1 >> 4; },Returns the encoder direction from timer control register
"void step_run (uint8_t dir,uint16_t speed,uint32_t steps) { paulse_setting = steps; stepper_state = 1; __HAL_TIM_SET_AUTORELOAD(&htim8, speed); __HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, speed / 2); HAL_GPIO_WritePin (DIR_GPIO_Port, DIR_Pin, dir); HAL_GPIO_WritePin (EN_GPIO_Port, EN_Pin, 0); HAL_TIM_PWM_Start_IT (&htim8, TIM_CHANNEL_1); }","Runs the stepper motor with specified direction, speed, and number of steps"
"void step_set_dir (uint16_t dir) { HAL_GPIO_WritePin (DIR_GPIO_Port, DIR_Pin, dir); }",Sets the stepper motor direction
"void step_set_speed (uint16_t speed) { __HAL_TIM_SET_AUTORELOAD(&htim8, speed); __HAL_TIM_SET_COMPARE(&htim8, TIM_CHANNEL_1, speed / 2); }",Sets the stepper motor speed by adjusting PWM timer
void step_set_steps (uint32_t steps) { paulse_setting = steps; },Sets the number of steps for the stepper motor
"void step_start () { HAL_TIM_PWM_Start_IT (&htim8, TIM_CHANNEL_1); }",Starts the stepper motor PWM
JDQ_Init();,JDQ_Init
Body_Init();,Body_Init
void UART_Config(void),UART_Config
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable clock to UART2
__HAL_RCC_USART2_CLK_ENABLE();,Enable clock to UART2
uartHandle.Init.BaudRate = 115200;,UART Configuration
uartHandle.Init.Mode = UART_MODE_TX_RX;,UART Configuration
uartHandle.Init.WordLength = UART_WORDLENGTH_8B;,UART Configuration
uartHandle.Init.StopBits = UART_STOPBITS_1;,UART Configuration
uartHandle.Init.OverSampling = UART_OVERSAMPLING_16;,UART Configuration
HAL_UART_Init(&uartHandle);,UART Configuration
void DMA_Config(void),DMA_Config
__HAL_RCC_DMA1_CLK_ENABLE();,Enable clock to DMA
dmaHandle.Init.Channel = DMA_CHANNEL_4;,DMA Configuration
dmaHandle.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;,DMA Configuration
dmaHandle.Init.Mode = DMA_CIRCULAR;,DMA Configuration
dmaHandle.Init.Priority = DMA_PRIORITY_LOW;,DMA Configuration
void DMA1_Stream5_IRQHandler(void),DMA1_Stream5_IRQHandler
HAL_DMA_IRQHandler(&dmaHandle);,DMA1_Stream5_IRQHandler
GPIO_InitStruct.Pin = BTLDR_EN_Pin;,GPIO Initialization
GPIO_InitStruct.Pull = LL_GPIO_PULL_UP;,GPIO Initialization
"LL_GPIO_Init(BTLDR_EN_GPIO_Port, &GPIO_InitStruct);",GPIO Initialization
static void MX_I2C1_Init(void),I2C1 Initialization Function
HAL_I2C_Init(&hi2c1);,I2C1 Initialization
"HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE);",Configure Analogue filter
static void MX_LPUART1_UART_Init(void),LPUART1 Initialization Function
hlpuart1.Instance = LPUART1;,LPUART1 Initialization
hlpuart1.Init.BaudRate = 115200;,LPUART1 Initialization
hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;,LPUART1 Initialization
hlpuart1.Init.StopBits = UART_STOPBITS_1;,LPUART1 Initialization
hlpuart1.Init.Parity = UART_PARITY_NONE;,LPUART1 Initialization
hlpuart1.Init.Mode = UART_MODE_TX_RX;,LPUART1 Initialization
hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;,LPUART1 Initialization
hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;,LPUART1 Initialization
HAL_UART_Init(&hlpuart1);,LPUART1 Initialization
GPIO_InitStruct.Pin = B1_Pin;,Configure GPIO pin : B1_Pin
GPIO_InitStruct.Pin = LD2_Pin;,Configure GPIO pin : LD2_Pin
void st77xx_demo(),st77xx_demo
"pin_device_create(&dcPin, GPIOE, GPIO_PIN_13, PIN_DEVICE_STATUS_INVERSE_NORMAL);",Create DC pin device
"spi_device_create(&spi4Dev, &hspi4, 4);",Create SPI device
"spi_with_pins_device_create(&spi4pDev, &spi4Dev, NULL, NULL, &dcPin);",Create SPI with pins device
"st7735_create(&st7735, (Command *)&st7735_cmd);",Create ST7735 display
static void test05_init(),Initialize test05 configuration
st7735.xOffset = 1;,Set X offset for ST7735
st7735.yOffset = 26;,Set Y offset for ST7735
st7735.width = 160;,Set width for ST7735
st7735.height = 80;,Set height for ST7735
st7735.colorMode = ST7735_COLOR_MODE_16BIT;,Set color mode for ST7735
st7735.orientation = ST7735_DISPLAY_DIRECTION_XY_EXCHANGE_Y_MIRROR | ST7735_DISPLAY_COLOR_DIRECTION_BGR | ST7735_DISPLAY_REFRESH_ORDER_T2B_L2R;,Set orientation for ST7735
st7735_reset(&st7735);,Reset ST7735 display
static void thread_0_entry(ULONG thread_input),Entry function for thread 0
tx_thread_sleep(1000 + (uint32_t)(num * 100));,Sleep for 1000 ticks
GPIO_InitStruct.Pin = LED1_PIN;,GPIO Initialization for LED
USART1_Config();,USART1 as debug serial port
USART2_Config();,USART2 for connecting ESP8266 module
Hal_I2C_Init();,I2C initialization for connecting temperature and humidity sensor
"Duoji_Init(9999,143);",Servo initialization
"USART2_Write(USART2, (unsigned char *)(HTTP_Buf), len);",Packet transmission
net_main ();,Run Network
net_initialize ();,Run Network
HAL_UART_Init(&huart2);,USART2 init function
"HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : B1_Pin
HAL_SYSTICK_Config(SystemCoreClock/RHINO_CONFIG_TICKS_PER_SECOND);,Configure the SysTick to have interrupt in 1ms time basis
"HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0U);",Configure the SysTick IRQ priority
if(TFT_ShieldDetect() != SHIELD_DETECTED),"Check the availability of adafruit 1.8"" TFT shield on top of STM32NUCLEO board."
HAL_PWREx_EnableVddUSB();,Enable USB power on Pwrctrl CR2 register
HID_InitApplication();,Init HID Application
"USBH_Init(&hUSBHost, USBH_UserProcess, 0);",Init Host Library
USBH_Process(&hUSBHost);,USB Host Background task
HID_MenuProcess();,HID Menu Process
HID_Joysticky();,HID Joystick
static void HID_InitApplication(void),HID application Init
BSP_LCD_Init();,Initialize the LCD
BSP_JOY_Init();,Configure Joystick in EXTI mode
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_EXTI);",Configure KEY Button
BSP_LED_Init(LED1);,Configure the LED1
BSP_LED_Init(LED2);,Configure the LED2
BSP_LED_Init(LED3);,Configure the LED3
LCD_LOG_Init();,Init the LCD Log module
HID_MenuInit();,Start HID Interface
void Toggle_Leds(void),Toggles LEDs to show user input state.
BSP_LED_Toggle(LED1);,Toggles LED1
BSP_LED_Toggle(LED2);,Toggles LED2
BSP_LED_Toggle(LED3);,Toggles LED3
NUCLEO_ADCx_GPIO_CLK_ENABLE();,Enable GPIO clock
__HAL_RCC_PWR_CLK_ENABLE();,Enable voltage range 1 boost mode for frequency above 80 Mhz
RCC_OscInitStruct.HSEState = RCC_HSE_ON;,Enable HSE Oscillator and activate PLL with HSE as source
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable HSE Oscillator and activate PLL with HSE as source
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_USB;,Select PLLSAI output as USB clock source
PeriphClkInitStruct.UsbClockSelection = RCC_USBCLKSOURCE_PLLSAI1;,Select PLLSAI output as USB clock source
static void Error_Handler(void),Executes in case of error occurrence.
void HAL_MspInit( void ),Enable clock for system configuration and power
__HAL_RCC_SYSCFG_CLK_ENABLE();,Enable clock for SYSCFG configuration and power
__HAL_RCC_PWR_CLK_ENABLE();,Enable clock for system configuration and power
__HAL_RCC_GPIOF_CLK_ENABLE();,Enable clock for GPIOF configuration and power
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable clock for GPIOA configuration and power
__HAL_RCC_GPIOB_CLK_ENABLE();,Enable clock for GPIOB configuration and power
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Configure external clock with HSE
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;, Configure HSI48 oscillator
RCC_OscInitStruct.HSI48State = RCC_HSI48_ON;,Enable the internal 48 MHz HSI48 oscillator.
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI48;, Use HSI48 as the system clock source
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock equal to system clock
RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;,Set APB1 clock equal to AHB clock
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USB|RCC_PERIPHCLK_I2C1;,Configure USB and I2C1 peripheral clocks manually
PeriphClkInit.UsbClockSelection = RCC_USBCLKSOURCE_HSI48;,Configure internal clock with USB SOF sync
PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_HSI;,Configure internal clock with USB SOF sync
pInit.Source = RCC_CRS_SYNC_SOURCE_USB;,Use USB SOF as CRS synchronization source
pInit.Polarity = RCC_CRS_SYNC_POLARITY_RISING;,Set CRS sync trigger on rising edge
"pInit.ReloadValue = __HAL_RCC_CRS_RELOADVALUE_CALCULATE( 48000000, 1000 );",Set CRS reload for 48 MHz and 1 kHz SOF
pInit.ErrorLimitValue = RCC_CRS_ERRORLIMIT_DEFAULT;,Set default allowed frequency error for CRS sync
void SysTick_Handler( void ),Increment system tick
xcan_usb_init();,Initialize USB
xcan_led_init();,Initialize LED
xcan_timestamp_init();,Initialize timestamp
xcan_protocol_init();,Initialize protocol
xcan_usb_poll();,Poll USB
xcan_led_poll();,Poll LED
xcan_protocol_poll();,Poll protocol
"BSP_ADC_Init(&hadc_bsp1,ADC_IN0,1,Dual_Mode_REGSIMULT);",Initialize ADC
HAL_ADC_Start(&hadc_bsp2);,Start ADC2
"HAL_ADCEx_MultiModeStart_DMA(&hadc_bsp1, ConvertedValue,1);",Start ADC1 with DMA
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Set voltage regulator output to Scale 1 for high performance
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Select HSE (High-Speed External) as oscillator source
RCC_OscInitStruct.PLL.PLLM = 5;,Set PLL input divider to 5
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* hadc),Define ADC conversion complete callback function
ConvertedValue = HAL_ADCEx_MultiModeGetValue(&hadc_bsp1);,Read combined ADC value in multi-mode
if(HAL_ICACHE_ConfigAssociativityMode(ICACHE_1WAY) != HAL_OK),Enable Instruction cache (default 2-ways set associative cache)
if(HAL_ICACHE_Enable() != HAL_OK),Enable Instruction cache (default 2-ways set associative cache)
"BSP_PB_Init(BUTTON_USER, BUTTON_MODE_GPIO);",User push-button will be used to exit from Low Power Run mode
CurrentPowerMode = HAL_PWREx_SMPS_GetEffectiveMode();,Get current power mode
HAL_Delay(5000);,Insert 5 seconds delay.
SystemClock_Decrease();,Reduce the System clock
if (HAL_PWREx_SMPS_SetMode(PWR_SMPS_BYPASS) != HAL_OK),Get current power mode
BSP_LED_DeInit(LED1);,De-init LED1
HAL_PWREx_EnableLowPowerRunMode();,Enter LP RUN Mode
if (HAL_PWREx_DisableLowPowerRunMode() != HAL_OK),Disable low power run mode and reset the clock to initialization configuration
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;,Select MSI as the oscillator source
RCC_OscInitStruct.MSIState = RCC_MSI_ON;,Enable the MSI internal oscillator
RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT;,Set MSI calibration to default factory value
RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;,Set MSI frequency range to level 6
RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;,Enable PLL (Phase-Locked Loop) output
RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;,Use MSI as PLL input clock source
RCC_OscInitStruct.PLL.PLLM = 1;, Set PLL input divider (M) to 1
RCC_OscInitStruct.PLL.PLLN = 55;,Multiply PLL input by 55 (N factor)
RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;,Set PLL P output divider to 7
RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;,Set PLL Q output divider to 2
RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;,Set PLL R output divider to 2
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;,"Select clocks to configure: HCLK, SYSCLK, PCLK1, PCLK2"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Use PLL output as the system clock source
RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;,Set AHB clock (HCLK) equal to system clock
"dprintf(""SystemCoreClock freq is: %d Hz\r\n"", (int)HAL_RCC_GetHCLKFreq());",Print system core clock frequency
"dprintf(""GPIO latency test application...\r\n"");",Indicate the application purpose
"dprintf(""Enter frequency in kHz...\r\n"");",Prompt user to input frequency
g_num_samples = 8192;,Set default number of samples
"dprintf(""x - freq, y - duty, z - num_samples\r\n"");",Explain input parameters
"scanf(""%d,%d,%d"", &freq, &duty_cycle, &g_num_samples);","Read frequency, duty cycle, and number of samples from user input"
"dprintf(""Press any key to continue...\r\n"");",Prompt user to press a key to proceed
"dprintf(""Starting TIM1 (%d kHz square wave)...\r\n"", freq);",Indicate start of TIM1 with specified frequency square wave
"MX_TIM1_Init(freq, duty_cycle);",Initialize TIM1 with frequency and duty cycle
HAL_TIM_Base_Start(&htim1);,Start TIM1 base
"HAL_TIM_PWM_Start_IT(&htim1, TIM_CHANNEL_1);",Start TIM1 PWM with interrupt on channel 1
while(!g_record_finished);,Wait until recording is finished
HAL_TIM_Base_Stop_IT(&htim1);,Stop TIM1 base with interrupt
HAL_TIM_Base_Stop(&htim4);,Stop TIM4 base
dump_sample_times();,Dump recorded sample times
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2;,Initializes the peripherals clocks
PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;,Initializes the peripherals clocks
if (htim->Instance == TIM17) { HAL_IncTick(); },"This function is called when TIM17 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
"if(HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1) != HAL_OK)",Start PWM signal generation in DMA mode
"HAL_TIM_DMABurst_WriteStart(&htim2, TIM_DMABASE_ARR, TIM_DMA_UPDATE, (uint32_t*)aSRC_Buffer, TIM_DMABURSTLENGTH_3TRANSFERS);",Start DMA Burst transfer
htim2.Init.Prescaler = PRESCALER;,"To get TIM2 counter clock at 8 MHz, the prescaler is computed as follows: Prescaler = (TIM2CLK / TIM2 counter clock) - 1"
htim2.Init.Period = 0xFFFF;,The TIM2 Frequency = TIM2 counter clock/(ARR + 1) = 8 MHz / 4096 = 1.95 KHz
sConfigOC.Pulse = 0xFFF;,TIM2 Channel1 duty cycle = (TIM2_CCR1/ TIM2_ARR)* 100 = 33.33%
__HAL_RCC_DMAMUX1_CLK_ENABLE();,DMA controller clock enable
HAL_NVIC_EnableIRQ(DMA1_Channel2_IRQn);,DMA interrupt init
USART2_Init();,Initialize USART2
SystemClockConfig();,Configure clock as required
SYSTICK_ReConfig();,"AS HCLK is changed, Reconfigure the SYSTICK."
USART2_Init();,Reinitialize USART2 as Clock(APB1) frequency changed. (Baud rate depends on Peripheral Bus clock frequency.)
OSC_Init.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Select High-Speed External (HSE) oscillator as clock source
OSC_Init.HSEState = RCC_HSE_BYPASS;,Use HSE oscillator in bypass mode for clock input
CLK_Init.AHBCLKDivider = RCC_SYSCLK_DIV2;,Divide system clock by 2 for AHB bus clock
CLK_Init.APB1CLKDivider = RCC_HCLK_DIV2;,Divide AHB clock by 2 for APB1 bus clock
CLK_Init.APB2CLKDivider = RCC_HCLK_DIV2;,Divide AHB clock by 2 for APB2 bus clock
CLK_Init.SYSCLKSource = RCC_SYSCLKSOURCE_HSE;,Set system clock (SYSCLK) source to HSE oscillator
__HAL_RCC_HSI_DISABLE();,Disable HSI oscillator
UART2Handler.Init.BaudRate = 115200;,Configure USART2 baud rate
"sprintf(msg,""SYSCLK : %ldHz\r\n"",HAL_RCC_GetSysClockFreq());",Format and send SYSCLK frequency
"HAL_UART_Transmit(&UART2Handler,(uint8_t*)msg,strlen(msg),HAL_MAX_DELAY);",Transmit data via USART2
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,"we have changed the clock source and its frequency, so we have to reconfigure the SYSTICK according to that."
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,SYSCLK prescalar config
BSP_LED_Init(LED1);,Initialize BSP Led for LED1 and LED3
BSP_LED_Init(LED3);,Initialize BSP Led for LED1 and LED3
RNG_Init();,Initialize the RNG peripheral
LCD_LOG_Init();,Initialize the LCD log
"LCD_LOG_SetHeader((uint8_t*)""SSL Server Application"");",Set LCD log header
"LCD_UsrLog(""\r\n Starting Main Thread...\n"");",Log start of main thread
osThreadTerminate(NULL);,Delete the start Thread
if (HAL_RNG_DeInit(&RngHandle) != HAL_OK),DeInitialize the RNG peripheral
if (HAL_RNG_Init(&RngHandle) != HAL_OK),Initialize the RNG peripheral
BSP_LED_Toggle(LED3);,Toggle LED3 to indicate error
BSP_LED_Init(LED3);,"Configure LED3, LED4, LED5 and LED6"
BSP_LED_Toggle(LED5);,Toggle LED5
if(GPIO_Pin == KEY_BUTTON_PIN) { ... },Handle KEY_BUTTON_PIN interrupt
RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
if (HAL_GetREVID() == 0x1001) { __HAL_FLASH_PREFETCH_BUFFER_ENABLE(); },STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported
CurrentTankWeight = GetScaleWeight();,Get current tank weight
CurrentPressureValue = BSP_PSENSOR_ReadPressure();,this is the only place we read pressure
"UART_TxMessageIntValue(PressureMessage, sizeof(PressureMessage), (long)CurrentPressureValue);",Transmit pressure value via UART
"UART_TxMessage(CrLf, sizeof(CrLf));",Transmit carriage return and line feed
"UART_TxMessageIntValue(WeightMessage, sizeof(WeightMessage), CurrentTankWeight);",Transmit weight value via UART
osDelay(xDelay);,Delay task execution
switch (LED_GetMode()) { ... },Handle different LED modes
LED_ON();,Turn LED on
STATE_LED_ON();,"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);"
osDelay((TickType_t)(555 / portTICK_PERIOD_MS));,Delay for blinking
STATE_LED_OFF();,"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);"
LED_SetMode(IsBlinking);,Set default LED mode to blinking
HAL_Delay(300);,Delay 300 ms
huart1.Init.BaudRate = 115200;,Configure USART1 baud rate
GPIO_InitStruct.Pin = GPIO_PIN_13;,Set GPIO pin : PC13
GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;,Configure GPIO pin as push-pull output
"HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);",Initialize GPIO pin on port C with settings
HAL_SYSTICK_Config(SystemCoreClock / 1000U);,Configure SYSTICK
BSP_LED_Init(LED_BLUE);,Configure LED_BLUE
"USBD_RegisterClass(&USBD_Device, USBD_CDC_RNDIS_CLASS);",Register USB CDC RNDIS class
"USBD_CDC_RNDIS_RegisterInterface(&USBD_Device, &USBD_CDC_RNDIS_fops);",Register USB CDC RNDIS interface
lwip_init();,Initialize lwIP stack
Netif_Config();,Configure the Network interface
while (dhcpSrvInit() != ERR_OK) ;,Initialize DHCP server
User_notification(&gNetif);,Notify user about the network interface config
ethernetif_input(&gNetif);,Read a received packet from the Ethernet buffers and send it to the lwIP for handling
sys_check_timeouts();,Handle timeouts
"udp_bind(srx_pcb,IP_ADDR_ANY,0xabcd);",Bind UDP PCB to any IP and port 0xabcd
"netif_add(&gNetif, &ipaddr, &netmask, &gw, NULL, &ethernetif_init, &ethernet_input);",Add the network interface
netif_set_default(&gNetif);,Registers the default network interface.
else { netif_set_down(&gNetif); },When the netif link is down this function must be called
"netif_set_link_callback(&gNetif, ethernetif_update_config);","Set the link callback function, this function is called on change of link status"
PeriphClkInitStruct.PeriphClockSelection = RCC_PERIPHCLK_CK48;,Select PLLSAI output as USB clock source
PeriphClkInitStruct.Clk48ClockSelection = RCC_CK48CLKSOURCE_PLLI2SQ;,Select PLLSAI output as USB clock source
MX_LWIP_Process();,Process lwIP stack
HAL_Delay(1);,Delay 1 ms
HAL_MPU_Disable();,Disables the MPU
HAL_MPU_ConfigRegion(&MPU_InitStruct);,Initializes and configures the Region and the memory to be protected
__HAL_RCC_GPIOG_CLK_ENABLE();,GPIO Port G Clock Enable
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet"
ret = HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 180 MHz Frequency
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
SystemClockConfig(SYS_CLK_FREQ_50MHz);,Configure system clock to 50 MHz
UART2_Init();,Initialize USART2
CAN1_Init();,Initialize CAN1
CAN_Filter_Config();,Configure CAN filter
"HAL_UART_Transmit(&huart2, (uint8_t*) sent_data, sent_data_length, HAL_MAX_DELAY);",Transmit data via UART2
HAL_CAN_Start(&hcan1);,Start CAN1
CAN1_Tx();,Transmit CAN message
CAN1_Rx();,Receive CAN message
osc_init.OscillatorType = RCC_OSCILLATORTYPE_HSI | RCC_OSCILLATORTYPE_LSE;,Configure HSI and LSE oscillators
clk_init.ClockType = RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;,"Configure system, HCLK, PCLK1, and PCLK2 clocks"
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Configure SysTick interrupt time
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Configure SysTick clock source
ledgpio.Pin = GPIO_PIN_5;,Configure GPIO pin PA5 as output
huart2.Init.BaudRate = 115200;,Configure UART2 baud rate
hcan1.Init.Mode = CAN_MODE_LOOPBACK;,Configure CAN1 in loopback mode
TxHeader.DLC = 5;,Set CAN message data length code
"HAL_CAN_AddTxMessage(&hcan1, &TxHeader, msgTx, &TxMailbox);",Add CAN message to transmit
"HAL_CAN_GetRxMessage(&hcan1, CAN_RX_FIFO0, &RxHeader, msgRx);",Receive CAN message from FIFO0
can1_filter_init.FilterActivation = ENABLE;,Enable CAN filter
state = STATE_IDLE;,Initialize state machine to idle
xFrequency = 20;,Set task frequency to 200 ms (20 ticks)
u8g2_ClearBuffer(&u8g2);,Clear OLED display buffer
"u8g2_SetFont(&u8g2, u8g2_font_helvB10_tr);",Set OLED font
"u8g2_DrawStr(&u8g2, 55, 15, ""Idle"");","Display ""Idle"" on OLED"
temp = tc_getAverageTemperature();,Get average thermocouple temperature
"sprintf(displaybuf, ""CTemp %d.%d C"", temp, fracTemp);",Format current temperature for display
u8g2_SendBuffer(&u8g2);,Send data to OLED display
"btnState = HAL_GPIO_ReadPin(BTN_START_GPIO_Port,BTN_START_Pin);",Read start button state
"HAL_UART_Transmit_IT(&huart1, &uBuffer, 13);",Transmit PID parameters via UART
pid_setTargetTemperature(tc_getAverageTemperature()/10);,Set initial PID target temperature
state = STATE_HEAT;,Switch to heating state
pid_enable();,Enable PID controller
aval = HAL_ADC_GetValue(&hadc1);,Get ADC value
pid_disable();,Disable PID controller
"HAL_GPIO_TogglePin(GPIOB, LED2_Pin);",Toggle LED2
pid_setTargetTemperature(tempProfile[cSec]);,Set PID target temperature from profile
"sprintf(displaybuf, ""TTemp %d.%d C"", temp, fracTemp);",Format target temperature for display
"sprintf(displaybuf, ""Time %d"", sTime);",Format elapsed time for display
"sprintf(displaybuf, ""Power %d %%"", pid_getCurOutputPower());",Format PID output power for display
"vTaskDelayUntil( &xLastWakeTime, xFrequency );",Delay task until next cycle
BSP_IO_Init();,Initialize IO expander
"USBD_Init(&USBD_Device, &HID_Desc, 0);",Init Device Library
"USBD_CUSTOM_HID_RegisterInterface(&USBD_Device, &USBD_CustomHID_fops);",Add Custom HID callbacks
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_SET);",Turn LED on
"HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13, GPIO_PIN_RESET);",Turn LED off
"obj_run(root, ""uart.setName('com1')"");",Set UART name to 'com1'
"obj_run(root, ""uart.send('My name is:')"");",Send UART message
"obj_run(root, ""uart.printName()"");",Print UART name
MX_CAN1_Init();,Initialize CAN1
MX_WWDG_Init();,Initialize Window Watchdog
ASK25_LED_Init(ALEDALL);,Initialize GPIOE.8 to GPIOE.15 as output pin to blink LEDs on ASK25
ASK25_LED_On(array[j]);,Turn on LED according to pattern
"trace_printf(""Hello\n"");","Print ""Hello"" via UART"
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);,Configure voltage scaling
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Initializes the RCC Oscillators according to the specified parameters
huart2.Init.BaudRate = 115200;,Configure USART2 baud rate
"hal_uart_send(&uart_0, &ch, 1, 30000);",Send character via UART
"hal_uart_recv_II(&uart_0, &ch, 1, &recv_size, HAL_WAIT_FOREVER);",Receive character via UART
MX_USART3_UART_Init();,Initialize USART3
"HAL_GPIO_WritePin(GPIOB, GRN_LED_Pin, GPIO_PIN_SET);",Turn on green LED
"HAL_UART_Transmit( &huart3, (uint8_t *) &""Booted.\r\n"", 9, 1000);",Transmit boot message via UART3
"HAL_UART_Transmit_DMA( &huart3, (uint8_t*) uart_buffer, strlen(uart_buffer) );",Transmit counter value via DMA
"HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 1, 0);",Configure DMA interrupt
HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);,Enable DMA interrupt
"HAL_NVIC_SetPriority(USART3_IRQn, 1, 0);",Configure USART3 interrupt
HAL_NVIC_EnableIRQ(USART3_IRQn);,Enable USART3 interrupt
void HAL_UART_TxCpltCallback (UART_HandleTypeDef *huart),DMA transmission complete callback
dma_complete = 1;,Set DMA complete flag
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == KEY_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback.
uwIncrementState = 1;,Change the Push button state
__HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE2);,"The voltage scaling allows optimizing the power consumption when personally clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet."
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICALibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 400; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSI Oscillator and activate PLL with HSI as source
"while (1) { if ( esp8266_tencent_firmware_join_ap(WIFI_SSID, WIFI_PASSWD) == 0) { printf(""module WIFI connect success\n""); break; } printf(""module WIFI connect fail\n""); tos_sleep_ms(2000); }",module WIFI connect
"while (1) { if (tos_tf_module_mqtt_conn(init_params) == 0) { printf(""module mqtt connect success\n""); break; } printf(""module mqtt connect fail\n""); tos_sleep_ms(5000); }",module mqtt connect
HAL_NVIC_DisableIRQ(USART3_4_IRQn);,Disable USART3_4 interrupt
pm2d5_parser_init(),pm2d5 parser init
if (report_error_count >= 6) { HAL_NVIC_SystemReset(); },Reset system after 6 failed reports
BSP_LED_Init(LED9); BSP_LED_Init(LED10);,Initialize LEDs
"THREAD1Handle = osThreadNew(LED_Thread1, NULL, &THREAD1_attributes);",creation of THREAD1
"THREAD2Handle = osThreadNew(LED_Thread2, NULL, &THREAD2_attributes);",creation of THREAD2
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 55; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
while (count > osKernelGetTickCount()) { BSP_LED_Toggle(LED9); osDelay(200); },Toggle LED9 every 200 ms for 5 s
BSP_LED_Off(LED9);,Turn off LED9
OsStatus = osThreadSuspend(THREAD1Handle);,Suspend Thread 1
while (count > osKernelGetTickCount()) { BSP_LED_Toggle(LED9); osDelay(500); },Toggle LED9 every 500 ms for 5 s
OsStatus = osThreadResume(THREAD2Handle);,Resume Thread 2
while (count > osKernelGetTickCount()) { BSP_LED_Toggle(LED10); osDelay(500); },Toggle LED10 every 500 ms for 10 s
BSP_LED_Off(LED10);,Turn off LED10
OsStatus = osThreadResume(THREAD1Handle);,Resume Thread 1
OsStatus = osThreadSuspend(THREAD2Handle);,Suspend Thread 2
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if (htim->Instance == TIM6) { HAL_IncTick(); } },"Period elapsed callback in non blocking mode This function is called when TIM6 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
if (htim->Instance == TIM6) { HAL_IncTick(); },Increment the global tick variable
__HAL_RCC_GPIOC_CLK_ENABLE();,Enable the GPIOC clock
"GPIO_InitStructure.Pin = GPIO_PIN_13; GPIO_InitStructure.Mode = GPIO_MODE_INPUT; GPIO_InitStructure.Pull = GPIO_NOPULL; GPIO_InitStructure.Speed = GPIO_SPEED_LOW; HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);",Initialise the button (PC13)
"if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_13)) { BSP_LED_Toggle(LED2); }",Toggle LED2 when button is pressed
BSP_LED_Init(LED3);,Initialize LED3
NbOfPages = (FLASH_USER_END_ADDR - FLASH_USER_START_ADDR + 1) >> 7;,Get the number of sector to erase from 1st sector
"if (HAL_FLASHEx_Erase(&EraseInitStruct, &PageError) != HAL_OK) { Error_Handler(); }",Erase the user Flash area (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR)
"while (Address < FLASH_USER_END_ADDR) { if (HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD, Address, DATA_32) == HAL_OK) { Address = Address + 4; } else { Error_Handler(); } }",Program the user Flash area word by word (area defined by FLASH_USER_START_ADDR and FLASH_USER_END_ADDR)
Address = FLASH_USER_START_ADDR; MemoryProgramStatus = 0x0; while (Address < FLASH_USER_END_ADDR) { data32 = *(__IO uint32_t*)Address; if (data32 != DATA_32) { MemoryProgramStatus++; } Address = Address + 4; },Check if the programmed data is OK MemoryProgramStatus = 0: data programmed correctly MemoryProgramStatus != 0: number of words not programmed correctly
CPU_CACHE_Enable();,Enable CPU cache
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Initialize the push button
"if (BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_AUTO, VOLUME, SAMPLE_RATE) != 0) { Error_Handler(); }",Initialize the audio output
"tinymt32_init(&rng, 0x12345678);",Initialize the random number generator
initSequencer();,Initialize the sequencer
initAudio();,Initialize audio
"while (1) { uint32_t tick = HAL_GetTick(); updateAllTracks(&synth, tracks, 2, tick); updateAudioBuffer(&synth); }",Main loop to update tracks and audio buffer
"static void initSynth() { ct_math_init(); ct_synth_init(&synth, NUM_VOICES); synth.lfo[0] = ct_synth_osc(""lfo1"", ct_synth_process_osc_sin, 0.0f, HZ_TO_RAD(1 / 24.0f), 0.6f, 1.0f); synth.numLFO = 1; for (uint8_t i = 0; i < synth.numStacks; i++) { initStack(&synth.stacks[i], 110.0f); } ct_synth_collect_stacks(&synth); }",Initialize the synthesizer
"void initAudio(void) { initSynth(); if (BSP_AUDIO_OUT_Init(OUTPUT_DEVICE_AUTO, VOLUME, SAMPLE_RATE) != 0) { Error_Handler(); } BSP_AUDIO_OUT_SetAudioFrameSlot(CODEC_AUDIOFRAME_SLOT_02); BSP_AUDIO_OUT_Play((uint16_t*) &audioBuffer[0], AUDIO_DMA_BUFFER_SIZE); }",Initialize audio
"static void renderAudio(int16_t *ptr, uint32_t frames) { ct_synth_update_mix_stereo_i16(&synth, frames, ptr); }",Render audio to the buffer
"void updateAudioBuffer(CT_Synth *synth) { if (bufferState == BUFFER_OFFSET_HALF) { int16_t *ptr = (int16_t*) &audioBuffer[0]; renderAudio(ptr, AUDIO_DMA_BUFFER_SIZE8); bufferState = BUFFER_OFFSET_NONE; } if (bufferState == BUFFER_OFFSET_FULL) { int16_t *ptr = (int16_t*) &audioBuffer[0] + AUDIO_DMA_BUFFER_SIZE4; renderAudio(ptr, AUDIO_DMA_BUFFER_SIZE8); bufferState = BUFFER_OFFSET_NONE; } }",Update the audio buffer
void HAL_GPIO_EXTI_Callback(uint16_t pin) { if (pin == KEY_BUTTON_PIN) { if (!isPressed) { BSP_LED_Toggle(LED_GREEN); transposeID = (transposeID + 1) % 8; tracks[0]->direction *= -1; tracks[1]->direction *= -1; isPressed = 1; } else { isPressed = 0; } } },Handle button press to toggle LED and change transpose
void BSP_AUDIO_OUT_HalfTransfer_CallBack(void) { bufferState = BUFFER_OFFSET_HALF; },Callback for half transfer of audio buffer
void BSP_AUDIO_OUT_TransferComplete_CallBack(void) { bufferState = BUFFER_OFFSET_FULL; },Callback for complete transfer of audio buffer
void BSP_AUDIO_OUT_Error_CallBack(void) { BSP_LED_On(LED_GREEN); while (1) { } },Handle audio output error
__HAL_RCC_GPIOG_CLK_ENABLE();,Enable GPIOG Clock (to be able to program the configuration registers)
"GPIO_InitStruct.Pin = (GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_10 | GPIO_PIN_12); GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FAST; HAL_GPIO_Init(GPIOG, &GPIO_InitStruct);","Configure PG.6, PG.7, PG10 and PG.12 IOs in output push-pull mode to drive external LEDs"
"HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_6);",Toggle PG.6
"HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_7);",Toggle PG.7
"HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_10);",Toggle PG.10
"HAL_GPIO_TogglePin(GPIOG, GPIO_PIN_12);",Toggle PG.12
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSE Oscillator and activate PLL with HSE as source
"HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_0 | GPIO_PIN_1 | GPIO_PIN_2);","Toggle GPIOD pins 0, 1, and 2"
HAL_Delay(10000);,Delay for 10 seconds
"static void MX_NVIC_Init(void) { HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI0_IRQn); HAL_NVIC_SetPriority(EXTI1_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI1_IRQn); HAL_NVIC_SetPriority(EXTI2_IRQn, 0, 0); HAL_NVIC_EnableIRQ(EXTI2_IRQn); }",NVIC Configuration.
BSP_LED_Init(LED3); BSP_LED_Init(LED4);,Configure LED3 & LED4
uwPrescalerValue = (uint32_t)(SystemCoreClock / 10000) - 1;,Compute the prescaler value to have TIMx counter clock equal to 10000 Hz
TimHandle.Init.Period = 10000 - 1; TimHandle.Init.Prescaler = uwPrescalerValue; TimHandle.Init.ClockDivision = 0; TimHandle.Init.CounterMode = TIM_COUNTERMODE_UP; TimHandle.Init.RepetitionCounter = 0; TimHandle.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;,Initialize TIMx peripheral as follows: + Period = 10000 - 1 + Prescaler = (SystemCoreClock/10000) - 1 + ClockDivision = 0 + Counter direction = Up
if (HAL_TIM_Base_Init(&TimHandle) != HAL_OK) { Error_Handler(); },Initialize the TIM Base peripheral
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { BSP_LED_Toggle(LED3); },Period elapsed callback in non blocking mode
oscinitstruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; oscinitstruct.HSEState = RCC_HSE_ON; oscinitstruct.HSEPredivValue = RCC_HSE_PREDIV_DIV5; oscinitstruct.Prediv1Source = RCC_PREDIV1_SOURCE_PLL2; oscinitstruct.PLL.PLLState = RCC_PLL_ON; oscinitstruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; oscinitstruct.PLL.PLLMUL = RCC_PLL_MUL9; oscinitstruct.PLL2.PLL2State = RCC_PLL2_ON; oscinitstruct.PLL2.PLL2MUL = RCC_PLL2_MUL8; oscinitstruct.PLL2.HSEPrediv2Value = RCC_HSE_PREDIV2_DIV5;,Enable HSE Oscillator and activate PLL with HSE as source
setUartHandle(&huart2);,Set UART handle for ACS
void MX_FREERTOS_Init(void),FreeRTOS initialization
"osSemaphoreWait(bSem01Handle, osWaitForever);",Infinite loop
void PeriodicTask(void const * argument),Function implementing the Periodic thread.
osSemaphoreRelease(bSemFilledHandle);,??bSemFilledHandle??
osSemaphoreRelease(bSemEmptyHandle);,??bSemEmptyHandle ??
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
void MX_USART1_UART_Init(void),USART1 Initialization Function
void MX_GPIO_Init(void),GPIO Initialization Function
void SERIAL_send_one_char(char c),USART - serial comms
while (!LL_USART_IsActiveFlag_TXE(USART2));,Wait for TXE flag to be raised
while (!LL_USART_IsActiveFlag_TC(USART2));,Wait for TC flag to be raised for last char
void SERIAL_init(void),This function configures USART2 Instance.
LL_IOP_GRP1_EnableClock(LL_IOP_GRP1_PERIPH_GPIOA);,Enable the peripheral clock of GPIO Port
"LL_GPIO_SetPinMode(GPIOA, GPIO_PIN_9, LL_GPIO_MODE_ALTERNATE);","Configure Tx Pin as : Alternate function, High Speed, Push pull, Pull up"
"LL_GPIO_SetPinMode(GPIOA, GPIO_PIN_10, LL_GPIO_MODE_ALTERNATE);","Configure Rx Pin as : Alternate function, High Speed, Push pull, Pull up"
LL_APB1_GRP1_EnableClock(LL_APB1_GRP1_PERIPH_USART2);,Enable USART peripheral clock and clock source
LL_RCC_SetUSARTClockSource(LL_RCC_USART2_CLKSOURCE_PCLK1);,Set clock source
"LL_USART_SetTransferDirection(USART2, LL_USART_DIRECTION_TX_RX);",TX/RX direction
"LL_USART_ConfigCharacter(USART2, LL_USART_DATAWIDTH_8B, LL_USART_PARITY_NONE, LL_USART_STOPBITS_1);","8 data bit, 1 start bit, 1 stop bit, no parity"
"LL_USART_SetBaudRate(USART2, SystemCoreClock, LL_USART_OVERSAMPLING_16, 115200);",Set Baudrate to 115200 using APB frequency set to 16000000 Hz
LL_USART_Enable(USART2);,Enable USART
while((!(LL_USART_IsActiveFlag_TEACK(USART2))) || (!(LL_USART_IsActiveFlag_REACK(USART2)))),Polling USART initialisation
__HAL_RCC_GPIOA_CLK_ENABLE();,Configure USB DM/DP pins
void default_message_handler(mqtt_message_t* msg),callback:
if (pm2d5_parser_init() == -1),pm2d5 parser init fail
"if (tos_tf_module_mqtt_publ(report_topic_name, QOS0, payload) != 0)",module mqtt publ fail
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI;,Enable HSI Oscillator and activate PLL with HSI as source
void Clear_Leds(),Clear_Leds
void Leds_Off(),Leds_Off
void Green_Led_On(),Green Led On
void Blue_Led_On(),Blue Led On
void Red_Led_On(),Red Led On
"BSP_DAC_Init(DAC_CHANNEL_2, DAC_TRIGGER_NONE);",Initialize and Start DAC conversion
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;,"Initializes the CPU, AHB and APB buses clocks"
if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK),Configure the main internal regulator output voltage
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;,Enable MSI Oscillator
RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2);,"Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void COMP_Config(void),Configure COMP
HAL_COMPEx_EnableVREFINT();,Enable the Vrefint
if(HAL_COMP_Start(&hcomp1) != HAL_OK),Start the COMP1 and enable the interrupt
void HAL_SYSTICK_Callback(void),SYSTICK callback
void HAL_COMP_TriggerCallback(COMP_HandleTypeDef *hcomp),COMP1 interrupt callback
BSP_LED_Init(LED4); BSP_LED_Init(LED5);,Configure LED4 and LED5
CrcHandle.Instance = CRC; CrcHandle.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_DISABLE; CrcHandle.Init.GeneratingPolynomial = CRC_POLYNOMIAL_8B; CrcHandle.Init.CRCLength = CRC_POLYLENGTH_8B; CrcHandle.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE; CrcHandle.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE; CrcHandle.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE; CrcHandle.InputDataFormat = CRC_INPUTDATA_FORMAT_WORDS; if (HAL_CRC_Init(&CrcHandle) != HAL_OK) { Error_Handler(); },Configure the CRC peripheral
"uwCRCValue = HAL_CRC_Calculate(&CrcHandle, (uint32_t *)&aDataBuffer, BUFFER_SIZE);","Compute the CRC of ""aDataBuffer"""
if (uwCRCValue != uwExpectedCRCValue) { Error_Handler(); } else { BSP_LED_On(LED5); },Compare the CRC value to the Expected one
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6; RCC_OscInitStruct.MSICalibrationValue = RCC_MSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { while(1); },"MSI is enabled after System reset at 4Mhz, PLL not used"
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_MSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { while(1); }","Select MSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
if(HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE2) != HAL_OK) { while(1); },"The voltage scaling allows optimizing the power consumption when the device is clocked below the maximum system frequency, to update the voltage scaling value regarding system frequency refer to product datasheet."
MX_GPIO_Init();,Initialize all configured GPIO peripherals
MX_TIM2_Init();,Initialize Timer 2 with configured settings
"HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1);",Start PWM signal generation
user_pwm_setvalue(pwm_value);,Set the PWM value
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI; RCC_OscInitStruct.MSIState = RCC_MSI_ON; RCC_OscInitStruct.MSICalibrationValue = 0; RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI; RCC_OscInitStruct.PLL.PLLM = 1; RCC_OscInitStruct.PLL.PLLN = 40; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7; RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2; RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
htim2.Instance = TIM2; htim2.Init.Prescaler = 200 - 1; htim2.Init.CounterMode = TIM_COUNTERMODE_UP; htim2.Init.Period = 2000 - 1; htim2.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1; htim2.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE; if (HAL_TIM_PWM_Init(&htim2) != HAL_OK) { Error_Handler(); },Configure the TIM2 peripheral for PWM
"void user_pwm_setvalue(uint16_t value) { TIM_OC_InitTypeDef sConfigOC; HAL_TIM_OC_Stop(&htim2, TIM_CHANNEL_1); sConfigOC.OCMode = TIM_OCMODE_PWM1; sConfigOC.Pulse = value; sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH; sConfigOC.OCFastMode = TIM_OCFAST_DISABLE; HAL_TIM_PWM_ConfigChannel(&htim2, &sConfigOC, TIM_CHANNEL_1); HAL_TIM_PWM_Start(&htim2, TIM_CHANNEL_1); }",Set the PWM value
MX_LPUART1_UART_Init();,Initialize LPUART1 with configured settings
HAL_Delay(1000);,Insert delay of 1000 ms
hlpuart1.Instance = LPUART1; hlpuart1.Init.BaudRate = 115200; hlpuart1.Init.WordLength = UART_WORDLENGTH_8B; hlpuart1.Init.StopBits = UART_STOPBITS_1; hlpuart1.Init.Parity = UART_PARITY_NONE; hlpuart1.Init.Mode = UART_MODE_TX_RX; hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; hlpuart1.Init.ClockPrescaler = UART_PRESCALER_DIV1; hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; hlpuart1.FifoMode = UART_FIFOMODE_DISABLE; if (HAL_UART_Init(&hlpuart1) != HAL_OK) { Error_Handler(); },Configure LPUART1 peripheral
"int fputc (int ch, FILE *f) { HAL_UART_Transmit(&hlpuart1, (uint8_t *) &ch, 1, 0xFFF); return ch; }",Retarget printf to LPUART1
"osThreadDef(wifiControl, StartWifiTask, osPriorityNormal, 0, 128); wifiControlHandle = osThreadCreate(osThread(wifiControl), NULL);",definition and creation of wifiControl
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { if(huart->Instance == USART3) { } },Handle UART receive complete callback
"HAL_GPIO_TogglePin(LED_GREEN_GPIO_Port, LED_GREEN_Pin); HAL_GPIO_TogglePin(LED_RED_GPIO_Port, LED_RED_Pin); rt_thread_mdelay(500);",Toggle LED pins with 500ms delay
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 6; RCC_OscInitStruct.PLL.PLLN = 180; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 4; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
MX_USART2_UART_Init();,Initialize USART2 with configured settings
DMX_Init();,Initialize DMX512 protocol
DMX_Demo_Init();,Initialize DMX demo
DMX_Demo();,Run DMX demo
"HAL_GPIO_TogglePin(LED3_GPIO_Port,LED3_Pin);",Toggle LED3
HAL_Delay(100);,Insert delay of 100 ms
"void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin==SW1_Pin) { HAL_GPIO_TogglePin(LED2_GPIO_Port,LED2_Pin); } }",Handle external interrupt callback for switch
UART2_Init();,Init the UART2
"if(HAL_UART_Transmit(&huart2, (uint8_t *)user_data, strlen(user_data), HAL_MAX_DELAY) != HAL_OK) Error_handler();",Send data in blocking mode
"while(reception_state != RECEPTION_COMPLETE) HAL_UART_Receive_IT(&huart2, &received_data, 1);",Receive data in Interrupt Mode
"void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart) { static uint32_t count = 0; data_buffer[count++] = received_data; if(received_data == '\r') { reception_state = RECEPTION_COMPLETE; HAL_UART_Transmit(huart, (uint8_t *)data_buffer, strlen(data_buffer), HAL_MAX_DELAY); } }",Handle UART receive complete callback
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.Mode = UART_MODE_TX_RX; if(HAL_UART_Init(&huart2) != HAL_OK) { Error_handler(); },Configure UART2 peripheral
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_NONE; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Enable HSI Oscillator (16 MHz)
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_HSI; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_0) != HAL_OK) { Error_Handler(); }","Select HSI as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
UART_Init();,Initialize UART
"printf(""UART Printf Example: retarget the C library printf function to the UART\r\n"");",Output a message on Hyperterminal using printf function
WaveRecorderProcess();,Process wave recorder
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Enable HSI Oscillator and activate PLL with HSI as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"void LED_On(uint16_t GPIO_Pin) { HAL_GPIO_WritePin(GPIOB, GPIO_Pin, GPIO_PIN_RESET); HAL_Delay(500); }",Turn on specified LED and delay 500ms
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins : PB0 PB1 PB2
"if (tos_tf_module_mqtt_sub(report_reply_topic_name, QOS0, default_message_handler) != 0)",module mqtt sub fail
if (ch20_parser_init() == -1),ch20 parser init fail
"if (tos_tf_module_mqtt_pub(report_topic_name, QOS0, payload) != 0)",module mqtt pub fail
OLED_Init();,???OLED
"static THD_FUNCTION(Thread1, arg)","Red LED blinker thread, times are in milliseconds."
halInit();,System initializations.
chSysInit();,System initializations.
"sdStart(&SD3, &sercfg);",Activates the USB driver and then the USB bus pull-up on D+.
usbDisconnectBus(&USBD1);,Activates the USB driver and then the USB bus pull-up on D+.
"usbStart(&USBD1, &usbcfg);",Activates the USB driver and then the USB bus pull-up on D+.
ramdiskObjectInit(&ramdisk);,start RAM disk
"ramdiskStart(&ramdisk, ramdisk_storage, RAMDISK_BLOCK_SIZE, RAMDISK_BLOCK_CNT, false);",start RAM disk
msdObjectInit(&USBMSD1);,start mass storage
"msdStart(&USBMSD1, &USBD1, (BaseBlockDevice *)&ramdisk, blkbuf, NULL, NULL);",start mass storage
void mgos_dev_system_restart(void),HAL_NVIC_SystemReset();
void device_get_mac_address(uint8_t mac[6]),Construct MAC address by using a Locally Administered Address OUI 12:34:... and a unique suffix obtained from hashing the device's UID.
void mgos_msleep(uint32_t msecs),mgos_usleep(msecs * 1000);
void mgos_usleep(uint32_t usecs),delay_cycles(remainder * (SystemCoreClock / 1000000));
RCC->AHB2ENR |= RCC_AHB2ENR_RNGEN;,PLL must be enabled for RNG to work
RNG->CR = RNG_CR_RNGEN;,PLL must be enabled for RNG to work
uint32_t sys_now(void),"LwIP time function, returns timestamp in milliseconds."
void Delay(unsigned int time),TimmingDelay = time;
if (HAL_GetREVID() == 0x1001),STM32F405x/407x/415x/417x Revision Z devices: prefetch is supported
GPIOA->ODR = 1<<6;,PA6 defined as Outputs
GPIOA->BSRR = 1<<6;,turn off PA6
void prvSetupHardware( void ),Configure the hardware
void plain_log_uart_init(void),UART hardware initialization for log output
"hal_pinmux_set_function(HAL_GPIO_0, HAL_GPIO_0_UART1_RTS_CM4);",Set Pinmux to UART
"hal_pinmux_set_function(HAL_GPIO_34, HAL_GPIO_34_IR_RX);","Call hal_pinmux_set_function to set GPIO pinmux, if EPT tool was not used to configure the related pinmux"
"hal_irrx_receive_pwd_start(&format, (hal_irrx_callback_t)receive_code_pwd, &us);",IRRX receive PWD data started.
void MX_I2C1_Init(void),I2C1 init function
GPIO_InitStruct.Pin = USER_LED_Pin;,Configure GPIO pin : USER_LED_Pin
"void _Error_Handler(char * file, int line)",This function is executed in case of error occurrence.
"BSP_PB_Init(BUTTON_KEY,BUTTON_MODE_EXTI);",initialize on board switch
BSP_LED_Init(LED5);,initialize on baord LED 4 and LED 5
if(__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST) != RESET),Check if the system has resumed from WWDG reset
BSP_IWDG_Init(2000);,Initialize and start IWDG
HAL_IWDG_Refresh(&hiwdg_bsp);,Refresh the IWDG reload count value
hal_uart_init(&uart_0);,default uart init
PUTCHAR_PROTOTYPE,Retargets the C library printf function to the USART.
"hal_uart_send(&uart_0, &ch, 1, 30000);",Retargets the C library printf function to the USART.
GETCHAR_PROTOTYPE,Retargets the C library scanf function to the USART.
void usart_setup(int baud),"usart_set_baudrate(USART2, baud);"
void hal_send_str(const char* in),send_USART_str(in);
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_SET);",Configure GPIO pin Output Level
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5, GPIO_PIN_RESET);",Configure GPIO pin Output Level
HAL_IncTick();,This function handles System tick timer.
"BSP_PB_Init(BUTTON_TAMPER, BUTTON_MODE_EXTI);",Configure Tamper push-button
HAL_Delay(1000);,Insert a Delay of 1000 ms
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if(GPIO_Pin == TAMPER_BUTTON_PIN) { if (uwIncrementState == 0) { HAL_SuspendTick(); uwIncrementState = 1; } else { HAL_ResumeTick(); uwIncrementState = 0; } } },EXTI line detection callback.
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 6; ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"BSP_PB_Init(BUTTON_KEY, BUTTON_MODE_EXTI);",Configure Key Button
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
void delay(void) { volatile int d = 500000; while(d--); },hardcoded delay
SystemClock_Config_HSE(SYS_CLOCK_FREQ_72_MHZ);,Config. the clock
GPIO_AnalogConfig();,Analog config for GPIOs to reduce power
HAL_TIM_Base_Start_IT(&timer2_handle);,Start timer
HAL_PWR_EnableSleepOnExit();,Enable sleep on exit
__HAL_RCC_USART2_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE();,"Enable the clock for the USART2 peripheral and GPIOA (on other microcontrollers, RCC may have a register to configure automatic disable for each peripheral clock in low power mode whenever MCU goes to sleep)"
"HAL_UART_Transmit(&huart2, (uint8_t *)message, sizeof(message), HAL_MAX_DELAY);",Send data received back to the sender
__HAL_RCC_USART2_CLK_DISABLE(); __HAL_RCC_GPIOA_CLK_DISABLE();,Disable the clock for the USART2 peripheral and GPIOA (before processor enters sleep mode).
timer2_handle.Instance = TIM2; timer2_handle.Init.CounterMode = TIM_COUNTERMODE_UP; timer2_handle.Init.Period = 100 - 1; timer2_handle.Init.Prescaler = 7200 - 1; if(HAL_TIM_Base_Init(&timer2_handle) != HAL_OK) Error_handler();,Initialize the TIMER2 time base (10ms)
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_8B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.Mode = UART_MODE_TX; huart2.Init.OverSampling = UART_OVERSAMPLING_16; if(HAL_UART_Init(&huart2) != HAL_OK) { Error_handler(); },Configure UART2 peripheral
"GpioA.Pin = GPIO_PIN_All ^ GPIO_PIN_2; GpioA.Mode = GPIO_MODE_ANALOG; GpioA.Pull = GPIO_NOPULL; GpioA.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOA, &GpioA);",Configure GPIO pins in analog mode to reduce power consumption
HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq()/1000);,Systick configuration
HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);,Systick configuration
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle) { uhADCxConvertedValue = HAL_ADC_GetValue(AdcHandle); },Conversion complete callback in non blocking mode
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 200; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 2; ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4; RCC_OscInitStruct.PLL.PLLQ = 7; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },"Enable HSE Oscillator, select it as PLL source and finally activate the PLL"
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) { Error_Handler(); }","Select the PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
__set_PSP((uint32_t)PSPMemAlloc + SP_PROCESS_SIZE);,Set Process stack value
__set_CONTROL(SP_PROCESS);,Select Process Stack as Thread mode Stack
__ISB();,Execute ISB instruction to flush pipeline as recommended by Arm
__set_CONTROL(THREAD_MODE_UNPRIVILEGED | SP_PROCESS);,Thread mode has unprivileged access
__SVC();,"Generate a system call exception, and in the ISR switch back Thread mode to privileged"
BSP_LED_On(LED1);,Turn ON LED once test finished
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 25; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9; RCC_OscInitStruct.PLL.PLLR = 7; ret = HAL_RCC_OscConfig(&RCC_OscInitStruct);,Enable HSE Oscillator and activate PLL with HSE as source
HAL_PWREx_EnableOverDrive();,Activate the OverDrive to reach the 216 MHz Frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; ret = HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7);","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
hspi1.Instance = SPI1; hspi1.Init.Mode = SPI_MODE_MASTER; hspi1.Init.Direction = SPI_DIRECTION_2LINES; hspi1.Init.DataSize = SPI_DATASIZE_8BIT; hspi1.Init.CLKPolarity = SPI_POLARITY_LOW; hspi1.Init.CLKPhase = SPI_PHASE_1EDGE; hspi1.Init.NSS = SPI_NSS_SOFT; hspi1.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2; hspi1.Init.FirstBit = SPI_FIRSTBIT_MSB; hspi1.Init.TIMode = SPI_TIMODE_DISABLE; hspi1.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE; hspi1.Init.CRCPolynomial = 10; if (HAL_SPI_Init(&hspi1) != HAL_OK) { Error_Handler(); },SPI1 parameter configuration
huart1.Instance = USART1; huart1.Init.BaudRate = 115200; huart1.Init.WordLength = UART_WORDLENGTH_8B; huart1.Init.StopBits = UART_STOPBITS_1; huart1.Init.Parity = UART_PARITY_NONE; huart1.Init.Mode = UART_MODE_TX_RX; huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart1.Init.OverSampling = UART_OVERSAMPLING_16; if (HAL_UART_Init(&huart1) != HAL_OK) { Error_Handler(); },Configure USART1 peripheral
BSP_LED_Init(LED1);,Initialize the LEDs used by CPU1
BSP_LED_Init(LED3);,Initialize the LEDs used by CPU1
"if(HAL_HSEM_Take(HSEM_ID, HSEM_PROCESS_1) == HAL_OK)",Take the HW Semaphore with Process1 ID (using 2-Step method)
BSP_LED_On(LED1);,Emulation of CPU1 Process1 execution start: Turn on LED1
HAL_Delay(5000);,Wait 5 sec
BSP_LED_Off(LED1);,Emulation of CPU1 Process1 execution end: Turn off LED1
"HAL_HSEM_Release(HSEM_ID, HSEM_PROCESS_1);",Release the HW Semaphore
void App_Gpio_Init(void),Configure the GPIO pin
__HAL_RCC_GPIOA_CLK_ENABLE();,Enable the GPIO_LED Clock
__HAL_RCC_GPIOB_CLK_ENABLE();,Enable the GPIO_LED Clock
__HAL_RCC_GPIOC_CLK_ENABLE();,Enable the GPIO_LED Clock
"HAL_GPIO_Init(GPIOA, &gpioinitstruct);",Configure the GPIO pin
"HAL_GPIO_WritePin(GPIOA,GPIO_PIN_1, GPIO_PIN_RESET);",Reset PIN to switch off the LED
"HAL_RCC_MCOConfig(RCC_MCO, RCC_MCOSOURCE_LXT, RCC_MCODIV_1);",Default MCO ouput clock at Pin PC4
void all_rcc_clk_enable(void),"enable all LED, Button, Uart, USB clock"
"HAL_GPIO_Init(LED_PORT, &GPIO_InitStruct);",LED
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI48;,Select HSI48 Oscillator as PLL source
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,Select PLL as system clock source and configure the HCLK and PCLK1 clocks dividers
void board_led_write(bool state),"HAL_GPIO_WritePin(LED_PORT, LED_PIN, state ? LED_STATE_ON : (1-LED_STATE_ON));"
uint32_t board_button_read(void),"return BUTTON_STATE_ACTIVE == HAL_GPIO_ReadPin(BUTTON_PORT, BUTTON_PIN);"
void SysTick_Handler(void),system_ticks++;
__HAL_RCC_GPIOA_CLK_DISABLE();,Disable GPIOs clock
__HAL_RCC_GPIOB_CLK_DISABLE();,Disable GPIOs clock
__HAL_RCC_GPIOC_CLK_DISABLE();,Disable GPIOs clock
__HAL_RCC_GPIOH_CLK_DISABLE();,Disable GPIOs clock
"HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_4);",Toggle GPIO pin
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0);",Toggle GPIO pin
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_1);",Toggle GPIO pin
"HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_0|GPIO_PIN_1);",Toggle multiple GPIO pins
htim14.Instance->CCR1 = count;,Set PWM compare value
htim3.Instance->CCR3 = count;,Set PWM compare value
htim3.Instance->CCR4 = count;,Set PWM compare value
"HAL_SPI_Receive_IT(&hspi1, spi_recv_buf, SPI_BUF_SIZE);",Restart SPI receive in interrupt mode
set_pwm(spi_recv_buf);,Set PWM based on received SPI data
"HAL_SPI_TransmitReceive_DMA(&hspi1, test, spi_recv_buf, SPI_BUF_SIZE);",Transmit and receive SPI data using DMA
"HAL_SPI_Transmit_DMA(&hspi1, test, SPI_BUF_SIZE);",Transmit SPI data using DMA
"HAL_SPI_Receive_DMA(&hspi1, spi_recv_buf, SPI_BUF_SIZE);",Receive SPI data using DMA
while(HAL_SPI_GetState(&hspi1) != HAL_SPI_STATE_READY);,Wait for SPI to be ready
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;,"MSI is enabled after System reset, activate PLL with MSI as source"
RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;,"Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
void can_init(void),Initialize CAN peripheral
"HAL_GPIO_Init(GPIOA, &gpio_init);",Configure GPIO for CAN
HAL_CAN_Init(&hcan);,Initialize CAN peripheral
void can_malvink_send(mavlink_message_t * msg),Send MAVLink message over CAN
"HAL_CAN_Transmit(&hcan, 100);",Transmit CAN frame
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin),Handle button press for bootloader
*bootloader_flag = BOOTLOADER_FLAG_VALUE;,Set the boot flag and reset the mcu. The bootloader will detect the flag and stay in dfu mode.
HAL_NVIC_SystemReset();,Set the boot flag and reset the mcu. The bootloader will detect the flag and stay in dfu mode.
"HAL_GPIO_TogglePin(LED_GPIO_Port, LED_Pin);",Toggle LED
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;,Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure.
GPIO_InitStruct.Pin = BTN_Pin;,Configure GPIO pin : BTN_Pin
"HAL_NVIC_SetPriority(EXTI0_IRQn, 0, 0);",EXTI interrupt init
HAL_NVIC_EnableIRQ(EXTI0_IRQn);,EXTI interrupt init
Debug_USART1_UART_Init();,Initialize the UART for debug
hal_rng_config();,Configure the random number generator
dwt_delay_init(SystemCoreClock);,Initialize DWT delay based on system core clock
"I2cInit(&I2c, I2C_SCL, I2C_SDA);",Initialize I2C peripheral
"GpioInit(&UsbDetect, USB_ON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 0);",Initialize USB detect GPIO
"GpioInit(&DcDcEnable, DC_DC_EN, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize DC-DC enable GPIO
"GpioInit(&RadioPushButton, RADIO_PUSH_BUTTON, PIN_INPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize Radio push button GPIO
"GpioInit(&Led4, LED_4, PIN_OUTPUT, PIN_PUSH_PULL, PIN_NO_PULL, 1);",Initialize LED4 GPIO
HAL_PCD_IRQHandler(&hpcd);,Handle USB PCD interrupt
HAL_Delay(ms);,Delay for specified milliseconds
SystemCoreClockUpdate();,Update system core clock
UartHandle.Instance = USARTx; UartHandle.Init.BaudRate = 9600; UartHandle.Init.WordLength = UART_WORDLENGTH_8B; UartHandle.Init.StopBits = UART_STOPBITS_1; UartHandle.Init.Parity = UART_PARITY_ODD; UartHandle.Init.HwFlowCtl = UART_HWCONTROL_NONE; UartHandle.Init.Mode = UART_MODE_TX_RX; UartHandle.Init.OverSampling = UART_OVERSAMPLING_16; if(HAL_UART_Init(&UartHandle) != HAL_OK) { Error_Handler(); },Configure the UART peripheral
"HAL_UART_Transmit(&UartHandle, (uint8_t *)&ch, 1, 0xFFFF);",Retargets the C library printf function to the USART
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = 0x10; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLM = 16; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; RCC_OscInitStruct.PLL.PLLR = 6; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Enable HSI Oscillator and activate PLL with HSI as source
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_5) != HAL_OK) { Error_Handler(); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_USART2; PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1; if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK) { Error_Handler(); },Initializes the peripherals clocks
huart2.Instance = USART2; huart2.Init.BaudRate = 115200; huart2.Init.WordLength = UART_WORDLENGTH_7B; huart2.Init.StopBits = UART_STOPBITS_1; huart2.Init.Parity = UART_PARITY_NONE; huart2.Init.Mode = UART_MODE_TX_RX; huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE; huart2.Init.OverSampling = UART_OVERSAMPLING_16; huart2.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE; huart2.Init.ClockPrescaler = UART_PRESCALER_DIV1; huart2.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT; if (HAL_UART_Init(&huart2) != HAL_OK) { Error_Handler(); },Configure USART2 peripheral
"HAL_UARTEx_SetTxFifoThreshold(&huart2, UART_TXFIFO_THRESHOLD_1_8);",Set UART TX FIFO threshold
"HAL_UARTEx_SetRxFifoThreshold(&huart2, UART_RXFIFO_THRESHOLD_1_8);",Set UART RX FIFO threshold
HAL_UARTEx_DisableFifoMode(&huart2);,Disable UART FIFO mode
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"HAL_I2C_Master_Sequential_Transmit_IT(dev, ((uint16_t)addr << 1U), (uint8_t*)i2c1TxBuffer, 0U, I2C_FIRST_AND_LAST_FRAME);",Initiate I2C master sequential transmit with interrupt
"HAL_I2C_Master_Sequential_Transmit_IT(dev, ((uint16_t)addr << 1U), (uint8_t*) i2c1TxBuffer, min((1U + count), I2C_TXBUFSIZE), I2C_FIRST_AND_LAST_FRAME);",Initiate I2C master sequential transmit with interrupt
"HAL_I2C_Master_Sequential_Transmit_IT(dev, (uint16_t) (addr << 1U), (uint8_t*) i2c1TxBuffer, min(i2cRegLen, I2C_TXBUFSIZE), I2C_LAST_FRAME_NO_STOP);",Initiate I2C master sequential transmit with interrupt
"HAL_I2C_Master_Sequential_Receive_IT(dev, (uint16_t) (addr << 1U), (uint8_t*) i2c1RxBuffer, min(readLen, I2C_RXBUFSIZE), I2C_LAST_FRAME);",Initiate I2C master sequential receive with interrupt
OSInit(&os_err);,Initialize uC/OS-III
"OSTaskCreate((OS_TCB *)&AppTaskStartTCB, (CPU_CHAR *)""App Task Start"", (OS_TASK_PTR)AppTaskStart, (void *)0, (OS_PRIO)APP_TASK_START_PRIO, (CPU_STK *)&AppTaskStartStk[0], (CPU_STK_SIZE)APP_TASK_START_STK_SIZE / 10, (CPU_STK_SIZE)APP_TASK_START_STK_SIZE, (OS_MSG_QTY)5u, (OS_TICK)0u, (void *)0, (OS_OPT)(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR), (OS_ERR *)&os_err);",Create application start task
OSStart(&os_err);,Start Multitasking
"OSTaskCreate((OS_TCB *)&LEDGreenTaskTCB, (CPU_CHAR *)""LED Green Task"", (OS_TASK_PTR)LEDGreenTask, (void *)0, (OS_PRIO)LED_GREEN_TASK_PRIO, (CPU_STK *)&LEDGreenTaskStk[0], (CPU_STK_SIZE)LED_GREEN_TASK_STK_SIZE / 10, (CPU_STK_SIZE)LED_GREEN_TASK_STK_SIZE, (OS_MSG_QTY)5u, (OS_TICK)0u, (void *)0, (OS_OPT)(OS_OPT_TASK_STK_CHK | OS_OPT_TASK_STK_CLR), (OS_ERR *)&os_err);",Create LED Green task
BSP_LED_GREEN_Toggle();,Toggle Green LED
BSP_LED_RED_Toggle();,Toggle Red LED
"HAL_UART_Transmit(&huart2, MSG, sizeof(MSG), 100);",Transmit message over UART
"OSTimeDlyHMSM(0, 0, 5, 0, OS_OPT_TIME_HMSM_STRICT, &os_err);",Delay task for 5 seconds
"OSTimeDlyHMSM(0, 0, 0, 500, OS_OPT_TIME_HMSM_STRICT, &os_err);",Delay task for 500 milliseconds
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSI; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.HSICalibrationValue = RCC_HSICALIBRATION_DEFAULT; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSI; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; RCC_OscInitStruct.PLL.PLLDIV = RCC_PLL_DIV3; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
"HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_12);",Toggle GPIO pin PD12
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7; if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Initializes the RCC Oscillators according to the specified parameters in the RCC_OscInitTypeDef structure
"HAL_GPIO_WritePin(GPIOD, GPIO_PIN_12, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = GPIO_PIN_12; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);",Configure GPIO pin : PD12
"HAL_UART_Receive_IT(&huart1, (uint8_t *)RX1_buff, 1);",Enable UART receive interrupt
HAL_Delay(500);,Delay for 500 milliseconds
USART3_UART_Init();,"Not directly commented, but contextually initializes UART3 for communication"
"los_nb_report(""22"", 2);",Report Data to Server( NB Report )
"los_nb_report(""23"", 1);",Report Data to Server( NB Report )
at_api_register(&at_interface);,Register AT interface for agent_tiny_entry
agent_tiny_entry();,Entry point for agent tiny demo
hieth_hw_init();,Initialize Ethernet hardware
net_init();,Initialize network
LOS_Start();,Start LiteOS kernel
uart_init();,this uart used for the pppos interface
"task_create(""main_ppp"", main_ppp, 0x800, NULL, NULL, 0);",Create PPP task
sota_init(&flash_op);,Initialize SOTA (Software Over The Air)
"at.oob_register(""+NNMI:"", strlen(""+NNMI:""), sota_callback,sota_cmd_match);",Register SOTA callback
hal_init_ota();,Initialize OTA (Over The Air) update
ledInit();,Initialize LEDs
ledOn(uint8_t ch);,Turn on LED
ledToggle(uint8_t ch);,Toggle LED
"cmdifAdd(""led"", ledCmdif);",Add LED command interface
"HAL_GPIO_Init(led_port_tbl[i].port, &GPIO_InitStruct);",Configure GPIO for LED
"HAL_GPIO_WritePin(led_port_tbl[ch].port, led_port_tbl[ch].pin_number, led_port_tbl[ch].on_state);",Set GPIO pin to turn on LED
"HAL_GPIO_WritePin(led_port_tbl[ch].port, led_port_tbl[ch].pin_number, led_port_tbl[ch].off_state);",Set GPIO pin to turn off LED
"HAL_GPIO_TogglePin(led_port_tbl[ch].port, led_port_tbl[ch].pin_number);",Toggle GPIO pin for LED
"app_kms_encrypt_decrypt_aes_cbc(sizeof(clear_buffer), clear_buffer);",Launch the test to encrypt/decrypt a message using AES CBC algorithm with an embedded AES secret key
"app_kms_encrypt_decrypt_aes_gcm(sizeof(clear_buffer), clear_buffer);",Launch the test to encrypt/decrypt a message using AES GCM algorithm with an embedded AES secret key
initialize();,Initialize system (custom function)
MX_USB_DEVICE_Init();,Initialize USB MIDI device
HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);,Enable USB interrupt
loop();,Main application loop (custom function)
"HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);",Configure GPIO pins
"HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15|GPIO_PIN_9, GPIO_PIN_RESET);",Configure GPIO pin Output Level
hrtc.Instance = RTC;,Initialize RTC Only
HAL_SD_Init(&hsd);,Initialize SDIO peripheral
"HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B);",Configure SDIO for 4-bit wide bus operation
"int fputc(int ch, FILE *f)","HAL_UART_Transmit(&huart1, (uint8_t *)&ch, 1, 0xFFFF); (context: redirect printf to UART)"
"int _write(int fd, char *ptr, int len)","HAL_UART_Transmit(&huart1, (uint8_t *)ptr, len, 0xFFFF); (context: redirect write to UART)"
board_init();,"Initialize board peripherals (HAL, clock, GPIO, UART)"
MX_LCD_Init();,Initialize LCD
LCD_GLASS_Clear();,Clear LCD display
"LCD_GLASS_DisplayString(""HELLO"");",Display string on LCD
delay_ms(1000);,delay milliseconds function
HAL_TIM_Base_Start_IT(&htim2);,Start TIM2 in interrupt mode
Start_PWM_Motor_Z(&motor1);,Start PWM for motor 1
Start_PWM_Motor_Z(&motor2);,Start PWM for motor 2
Start_PWM_Motor_Z(&motor3);,Start PWM for motor 3
IMU_Initialize(&hi2c1);,Initialize DFROBOT_IMU
Encoder_Start(&encoder_z);,Start timer for encoder
"Euler_Data(&hi2c1, &x, &y, &z);",Read Euler data from IMU
"Speed_Motor(&motor1, 1, (uint16_t)out_roll);",Set speed and rotation direction for MOTOR
"HAL_UART_Transmit_IT(&huart2, data, size);",Wysylanie informacji do zewnetrznego urzadzenia (Send information to external device)
"HAL_GPIO_TogglePin(GPIOD, GPIO_PIN_14);",Toggle GPIO pin
MX_DMA2D_Init();,Initialize DMA2D
MX_FMC_Init();,Initialize FMC
MX_I2C3_Init();,Initialize I2C3
MX_LTDC_Init();,Initialize LTDC
MX_SPI5_Init();,Initialize SPI5
MX_USB_OTG_HS_HCD_Init();,Initialize USB OTG HS
HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim),"This function is called when TIM6 interrupt took place, inside HAL_TIM_IRQHandler(). It makes a direct call to HAL_IncTick() to increment a global variable ""uwTick"" used as application time base."
ltdc_init();,Initialize LTDC and DSI for LCD
"ltdc_layer_init(0, (uint32_t)lcd.info.framebuffer);",Initialize LTDC layer
__HAL_RCC_LTDC_CLK_ENABLE();,Enable LTDC clock
__HAL_RCC_DSI_CLK_ENABLE();,Enable DSI clock
"HAL_NVIC_SetPriority(LTDC_IRQn, 3, 0);",Set LTDC interrupt priority
HAL_NVIC_EnableIRQ(LTDC_IRQn);,Enable LTDC interrupt
"HAL_DSI_Init(&hdsi, &dsi_pll);",Initialize DSI peripheral
"HAL_DSI_ConfigVideoMode(&hdsi, &hdsi_video);",Configure DSI video mode
"HAL_DSI_ConfigPhyTimer(&hdsi, &dsi_phy);",Configure DSI PHY timer
HAL_LTDC_Init(&hltdc);,Initialize LTDC peripheral
HAL_DSI_Start(&hdsi);,Start DSI peripheral
stm32_mipi_lcd_config(RTGRAPHIC_PIXEL_FORMAT_ARGB888);,Configure MIPI LCD
stm32_mipi_display_on();,Turn on MIPI display
stm32_mipi_display_off();,Turn off MIPI display
"rt_device_register(&lcd.parent, ""lcd"", RT_DEVICE_FLAG_RDWR);",Register LCD device
"HAL_LTDC_ConfigLayer(&hltdc, &layer_cfg, index);",Configure LTDC layer
HAL_LTDC_IRQHandler(&hltdc);,Handle LTDC interrupt
static ShieldStatus TFT_ShieldDetect(void);,Private function prototypes
static void Error_Handler(void);,Private function prototypes
static void CPU_CACHE_Enable(void);,Private function prototypes
if(TFT_ShieldDetect() != SHIELD_DETECTED) { Error_Handler(); },"Check the availability of adafruit 1.8"" TFT shield on top of STM32NUCLEO board. This is done by reading the state of IO PF.03 pin (mapped to JoyStick available on adafruit 1.8"" TFT shield). If the state of PF.03 is high then the adafruit 1.8"" TFT shield is available."
USBH_Start(&hUSBHost);,Start Host Process
while (1) { USBH_Process(&hUSBHost); HID_MenuProcess(); HID_Joysticky(); },Run Application (Blocking mode)
"LCD_LOG_SetHeader((uint8_t *)""OTG FS HID Host"");",Set LCD log header
"static void USBH_UserProcess(USBH_HandleTypeDef *phost, uint8_t id) { switch(id) { case HOST_USER_SELECT_CONFIGURATION: break; case HOST_USER_DISCONNECTION: Appli_state = APPLICATION_DISCONNECT; break; case HOST_USER_CLASS_ACTIVE: Appli_state = APPLICATION_READY; break; case HOST_USER_CONNECTION: Appli_state = APPLICATION_START; break; default: break; } }",User Process
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS; RCC_OscInitStruct.HSIState = RCC_HSI_OFF; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 432; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 9; RCC_OscInitStruct.PLL.PLLR = 7; if(HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) { Error_Handler(); },Enable HSE Oscillator and activate PLL with HSE as source
if(HAL_PWREx_EnableOverDrive() != HAL_OK) { Error_Handler(); },Activate the OverDrive to reach the 216 Mhz Frequency
"RCC_ClkInitStruct.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2; if(HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_7) != HAL_OK) { Error_Handler(); }","Select PLL as system clock source and configure the HCLK, PCLK1 and PCLK2 clocks dividers"
"static ShieldStatus TFT_ShieldDetect(void) { GPIO_InitTypeDef GPIO_InitStruct; NUCLEO_ADCx_GPIO_CLK_ENABLE(); GPIO_InitStruct.Pin = NUCLEO_ADCx_GPIO_PIN; GPIO_InitStruct.Mode = GPIO_MODE_INPUT; GPIO_InitStruct.Pull = GPIO_PULLDOWN; HAL_GPIO_Init(NUCLEO_ADCx_GPIO_PORT, &GPIO_InitStruct); if(HAL_GPIO_ReadPin(NUCLEO_ADCx_GPIO_PORT, NUCLEO_ADCx_GPIO_PIN) != 0) { return SHIELD_DETECTED; } else { return SHIELD_NOT_DETECTED; } }","Check the availability of adafruit 1.8"" TFT shield on top of STM32NUCLEO board. This is done by reading the state of IO PF.03 pin (mapped to JoyStick available on adafruit 1.8"" TFT shield). If the state of PF.03 is high then the adafruit 1.8"" TFT shield is available."
static void CPU_CACHE_Enable(void) { SCB_EnableICache(); SCB_EnableDCache(); },CPU L1-Cache enable.
void NMI_Handler(void) { },This function handles Non maskable interrupt.
void HardFault_Handler(void) { while (1) { } },This function handles Hard fault interrupt.
void BusFault_Handler(void) { while (1) { } },"This function handles Prefetch fault, memory access fault."
void UsageFault_Handler(void) { while (1) { } },This function handles Undefined instruction or illegal state.
void DebugMon_Handler(void) { },This function handles Debug monitor.
void SysTick_Handler(void) { osSystickHandler(); },This function handles System tick timer.
void DMA1_Channel7_IRQHandler(void) { HAL_DMA_IRQHandler(&hdma_usart2_tx); },This function handles DMA1 channel7 global interrupt.
void TIM1_UP_IRQHandler(void) { HAL_TIM_IRQHandler(&htim1); },This function handles TIM1 update interrupt.
"void USART1_IRQHandler(void) { HAL_UART_IRQHandler(&huart1); HAL_UART_Receive_IT(&huart1, &in_char, 1); rx_buff_in[head] = in_char; ++head; head %= CIRC_BUFF_SIZE; }",This function handles USART1 global interrupt.
"HAL_UART_Receive_IT(&huart1, &in_char, 1); rx_buff_in[head] = in_char; ++head; head %= CIRC_BUFF_SIZE;",Receive and buffer incoming UART data
void USART2_IRQHandler(void) { HAL_UART_IRQHandler(&huart2); },This function handles USART2 global interrupt.
static uint8_t printf_thread_stack[DEMO_STACK_SIZE];,Private variables
"void tx_application_define(void *first_unused_memory) { tx_thread_create(&led_thread, ""led thread"", led_thread_entry, 0, led_thread_stack, DEMO_STACK_SIZE, 1, 1, TX_NO_TIME_SLICE, TX_AUTO_START); tx_thread_create(&printf_thread, ""printf thread"", printf_thread_entry, 0, printf_thread_stack, DEMO_STACK_SIZE, 2, 2, TX_NO_TIME_SLICE, TX_AUTO_START); }",Create the led thread and printf thread
"tx_thread_create(&led_thread, ""led thread"", led_thread_entry, 0, led_thread_stack, DEMO_STACK_SIZE, 1, 1, TX_NO_TIME_SLICE, TX_AUTO_START);",Create the led thread.
"tx_thread_create(&printf_thread, ""printf thread"", printf_thread_entry, 0, printf_thread_stack, DEMO_STACK_SIZE, 2, 2, TX_NO_TIME_SLICE, TX_AUTO_START);",Create the printf thread.
tx_kernel_enter();,Enter ThreadX kernel
"static void MX_GPIO_Init(void) { GPIO_InitTypeDef GPIO_InitStruct = {0}; __HAL_RCC_GPIOE_CLK_ENABLE(); __HAL_RCC_GPIOA_CLK_ENABLE(); HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET); GPIO_InitStruct.Pin = GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOE, &GPIO_InitStruct); }",GPIO Initialization Function
"HAL_GPIO_WritePin(GPIOE, GPIO_PIN_7, GPIO_PIN_RESET);",Configure GPIO pin Output Level
GPIO_InitStruct.Pin = GPIO_PIN_7; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;,Configure GPIO pin : PE7
void Error_Handler(void) { },This function is executed in case of error occurrence.
extern UART_HandleTypeDef huart2;,External private variables
"if(PROCESS == 0x22) { if(COMMAND == 0x00) { sprintf(transmit_buffer, ""%s receive function is enabled.\n"", usarts[peripheralID]); CDC_Transmit_FS((uint8_t *)&transmit_buffer, strlen(transmit_buffer)); USART_R[peripheralID] = 1; } else { sprintf(transmit_buffer, ""%s receive function is disabled.\n"", usarts[peripheralID]); CDC_Transmit_FS((uint8_t *)&transmit_buffer, strlen(transmit_buffer)); USART_R[peripheralID] = 0; } }",Receive
"if(COMMAND == 0x00) { sprintf(transmit_buffer, ""%s receive function is enabled.\n"", usarts[peripheralID]); CDC_Transmit_FS((uint8_t *)&transmit_buffer, strlen(transmit_buffer)); USART_R[peripheralID] = 1; }",Enable Receive
__PWR_CLK_ENABLE();,Enable power control clock
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 336; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Configure HSE oscillator and PLL
RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_SYSCLK|RCC_CLOCKTYPE_PCLK1 |RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV4; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV2;,Configure system clock source and bus clocks
static void BSP_Config(void);,Private function prototypes
static void SystemClock_Config(void);,Private function prototypes
BSP_Config();,Initialize LCD and LEDs
TIM3_Init();,Initialize TIM3
GUI_Initialized = 1;,Set GUI initialized flag
WM_SetCreateFlags(WM_CF_MEMDEV);,Activate the use of memory device feature
DoHvacSimpleMode();,Run HVAC control\monitoring\auto-defrost
DoUartServer();,Run UART server to receive commands from MQTT or other remote device
"if(t_txmode == 0) { if( ctldata_s.bModeCool == TRUE && HAL_GPIO_ReadPin(DI_ACMODELED_GPIO_Port,DI_ACMODELED_Pin) == GPIO_PIN_SET) { bSendPwr =TRUE; sprintf(dbglog,""Sent Power ON Cnt %d bCool %d ACLED%s"",++pwrtxcnt,ctldata_s.bModeCool,HAL_GPIO_ReadPin(DI_ACMODELED_GPIO_Port,DI_ACMODELED_Pin) == GPIO_PIN_RESET ? ""AC ON"" : ""AC OFF""); } else if( ctldata_s.bModeCool == FALSE && HAL_GPIO_ReadPin(DI_ACMODELED_GPIO_Port,DI_ACMODELED_Pin) == GPIO_PIN_RESET) { bSendPwr = TRUE; sprintf(dbglog,""Sent Power OFF Cnt %d bCool %d ACLED%s"",++pwrtxcnt,ctldata_s.bModeCool,HAL_GPIO_ReadPin(DI_ACMODELED_GPIO_Port,DI_ACMODELED_Pin) == GPIO_PIN_RESET ? ""AC ON"" : ""AC OFF""); } }",If AC should be ON but is OFF trigger Mode button press event / If AC should be OFF but is ON trigger Mode button press event
if(t_txmode !=0 && (HAL_GetTick() > t_txmode + 5000)) { t_txmode=0; },"Keep in this state for 5000 Seconds after PWR BTN command tx, stops AC ON\OFF from being checked"
BSP_LED_Init(LED3); BSP_LED_Init(LED4);,Initialize STM32F429I-DISCO's LEDs
__HAL_RCC_CRC_CLK_ENABLE();,"Enable the CRC Module VK, this unlocks STemWin to be used under free ST license"
"void BSP_Pointer_Update(void) { GUI_PID_STATE TS_State; static TS_StateTypeDef prev_state; TS_StateTypeDef ts; uint16_t xDiff, yDiff; BSP_TS_GetState(&ts); TS_State.Pressed = ts.TouchDetected; xDiff = (prev_state.X > ts.X) ? (prev_state.X - ts.X) : (ts.X - prev_state.X); yDiff = (prev_state.Y > ts.Y) ? (prev_state.Y - ts.Y) : (ts.Y - prev_state.Y); if(ts.TouchDetected) { if((prev_state.TouchDetected != ts.TouchDetected )|| (xDiff > 3 )|| (yDiff > 3)) { prev_state = ts; TS_State.Layer = 0; TS_State.x = ts.X; TS_State.y = ts.Y; GUI_TOUCH_StoreStateEx(&TS_State); } } }",Provide the GUI with current state of the touch screen
RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; RCC_OscInitStruct.PLL.PLLM = 8; RCC_OscInitStruct.PLL.PLLN = 360; RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV2; RCC_OscInitStruct.PLL.PLLQ = 7;,Enable HSE Oscillator and activate PLL with HSE as source
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pin) { if (GPIO_Pin == KEY_BUTTON_PIN) { ubKeyPressed = SET; } },EXTI line detection callbacks.
void HAL_SYSTICK_Callback(void) { static uint16_t ticks=1000; if(--ticks==0) { ticks=1000; calc_uptime(time_s.time++); } },Systick callback for my application use (non system)
Potentiometer_Init();,Initialize potentiometer
while (1) { Luos_Loop(); Potentiometer_Loop(); },Infinite loop
"osThreadDef(ReceiverThread, osPriorityHigh, 2048, ""ReceiverThread"");",need to declare the Receiver thread here
if (!IsToRemainInBooter()) { if (CheckValidCLRImage((uint32_t)&__nanoImage_end__)) { LaunchCLR((uint32_t)&__nanoImage_end__); } },check if there is a request to remain on nanoBooter / check for valid CLR image at address contiguous to nanoBooter / there seems to be a valid CLR image / launch nanoCLR
BlockStorageList_Initialize(); BlockStorage_AddDevices();,initialize block storage list and devices / in CLR this is called in nanoHAL_Initialize() / for nanoBooter we have to init it in order to provide the flash map for Monitor_FlashSectorMap command
for(int i = 0; i < 2000; i+=50) { TIM2->CCR2 = i; HAL_Delay(30); },Increment PWM duty cycle
"if(flag) { uint16_t size = sprintf((char *)tx_buffer, ""hola mundo %d \n"", contador++); HAL_UART_Transmit(&huart1, (uint8_t *)tx_buffer, size, 100); flag = 0; }","Transmit ""hola mundo"" with counter"
"void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { if(htim->Instance == TIM2) { flag = 1; HAL_GPIO_TogglePin(USER_LED_GPIO_Port, USER_LED_Pin); } }",Toggle LED on timer period elapsed
TIMER6_Init();,Initialize Timer 6
HAL_TIM_Base_Start_IT(&htimer6);,Starting a timer in interrupt mode
void TIMER6_Init(void) { htimer6.Instance = TIM6; htimer6.Init.Prescaler = 24; htimer6.Init.Period = 64000-1; if( HAL_TIM_Base_Init(&htimer6) != HAL_OK ) { Error_Handler(); } },Initialize Timer 6
"void GPIO_Init(void) { __HAL_RCC_GPIOA_CLK_ENABLE(); GPIO_InitTypeDef ledgpio; ledgpio.Pin = GPIO_PIN_5; ledgpio.Mode = GPIO_MODE_OUTPUT_PP; ledgpio.Pull = GPIO_NOPULL; HAL_GPIO_Init(GPIOA, &ledgpio); }",Initialize GPIO
"void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) { HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_5); }",Toggle GPIO pin on timer period elapsed
"HAL_GPIO_TogglePin(GPIOC, GPIO_PIN_13);",Toggle the state of GPIO pin PC13
static void MX_TIM2_Init(void),TIM2 Initialization Function
UartContext_t UartContext[UART_COUNT];,Context structure for UART instances
"void UartMcuInit( Uart_t *obj, uint8_t uartId, PinNames tx, PinNames rx )","Initialize UART MCU with specified UART ID, TX, and RX pins"
__HAL_RCC_USART1_FORCE_RESET( ); __HAL_RCC_USART1_RELEASE_RESET( ); __HAL_RCC_USART1_CLK_ENABLE( );,Reset and enable USART1 clock
"GpioInit( &obj->Tx, tx, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_UP, GPIO_AF7_USART1 ); GpioInit( &obj->Rx, rx, PIN_ALTERNATE_FCT, PIN_PUSH_PULL, PIN_PULL_UP, GPIO_AF7_USART1 );",Configure TX and RX pins for USART1
"void UartMcuConfig( Uart_t *obj, UartMode_t mode, uint32_t baudrate, WordLength_t wordLength, StopBits_t stopBits, Parity_t parity, FlowCtrl_t flowCtrl )","Configure UART MCU with mode, baud rate, word length, stop bits, parity, and flow control"
"FifoInit( &obj->FifoRx, UART_RxBuffer, FIFO_RX_SIZE );",Initialize RX FIFO for UART1
handle->Init.BaudRate = baudrate;,Set UART baud rate
handle->Init.Mode = UART_MODE_TX;,Configure UART for TX only mode
handle->Init.Mode = UART_MODE_RX;,Configure UART for RX only mode
handle->Init.Mode = UART_MODE_TX_RX;,Configure UART for TX and RX mode
handle->Init.WordLength = UART_WORDLENGTH_8B;,Set UART word length to 8 bits
handle->Init.StopBits = UART_STOPBITS_2;,Set UART stop bits to 2
handle->Init.Parity = UART_PARITY_NONE;,Set UART parity to none
handle->Init.HwFlowCtl = UART_HWCONTROL_NONE;,Disable hardware flow control
handle->Init.OverSampling = UART_OVERSAMPLING_16;,Set UART oversampling to 16
"HAL_NVIC_SetPriority( irq, 8, 0 ); HAL_NVIC_EnableIRQ( irq );",Configure NVIC priority and enable IRQ for UART
"HAL_UART_Receive_IT( handle, &UartContext[obj->UartId].RxData, 1 );",Enable UART receive interrupt
void UartMcuDeInit( Uart_t *obj ),Deinitialize UART MCU
__HAL_RCC_USART1_CLK_DISABLE( );,Disable USART1 clock
"GpioInit( &obj->Tx, obj->Tx.pin, PIN_ANALOGIC, PIN_PUSH_PULL, PIN_NO_PULL, 0 ); GpioInit( &obj->Rx, obj->Rx.pin, PIN_ANALOGIC, PIN_PUSH_PULL, PIN_NO_PULL, 0 );",Deinitialize TX and RX pins
"uint8_t UartMcuPutBuffer( Uart_t *obj, uint8_t *buffer, uint16_t size )",Transmit buffer over UART using interrupt
"uint8_t UartMcuPutChar( Uart_t *obj, uint8_t data )",Transmit single character over UART
"FifoPush( &obj->FifoTx, data );",Push data to TX FIFO
"__HAL_UART_ENABLE_IT( &UartContext[obj->UartId].UartHandle, USART_IT_TXE );",Trig UART Tx interrupt to start sending the FIFO contents
"uint8_t UartMcuGetChar( Uart_t *obj, uint8_t *data )",Receive single character from UART
*data = FifoPop( &obj->FifoRx );,Pop data from RX FIFO
void HAL_UART_TxCpltCallback( UART_HandleTypeDef *handle ),Callback for UART transmission complete
"HAL_UART_Transmit_IT( handle, &data, 1 );",Write one byte to the transmit data register
HAL_NVIC_DisableIRQ( irqn );,Disable the USART Transmit interrupt
uart->IrqNotify( UART_NOTIFY_TX );,Notify TX completion
void HAL_UART_RxCpltCallback( UART_HandleTypeDef *handle ),Callback for UART reception complete
uart->IrqNotify( UART_NOTIFY_RX );,Notify RX completion
"HAL_UART_Receive_IT( &UartContext[uartId].UartHandle, &UartContext[uartId].RxData, 1 );",Restart UART receive interrupt
void HAL_UART_ErrorCallback( UART_HandleTypeDef *handle ),Callback for UART error handling
void USART3_IRQHandler( void ),USART3 interrupt handler
"PUTCHAR_PROTOTYPE { HAL_UART_Transmit(&UartContext[UART_1].UartHandle, (uint8_t *)&ch, 1, 0xFFFF); return ch; }",Retargets the C library printf function to the USART
int e_printchar(char ch),Transmit a character over UART
void uartStartRx(uint8_t channel),Start UART reception
"HAL_UART_Receive_IT(p_uart->handle, p_uart->rx_buf, 1);",Enable UART receive interrupt for interrupt mode
"HAL_UART_Receive_DMA(p_uart->handle, (uint8_t *)p_uart->qbuffer_rx.p_buf, p_uart->qbuffer_rx.length);",Enable UART receive DMA for DMA mode
bool uartInit(void),Initialize UART driver
"bool uartOpen(uint8_t channel, uint32_t baud)",Open UART channel with specified baud rate
"qbufferCreate(&p_uart->qbuffer_rx, p_uart->rx_buf, UART_RX_BUF_LENGTH);",Create receive queue buffer
HAL_UART_DeInit(p_uart->handle); HAL_UART_Init(p_uart->handle);,Deinitialize and reinitialize UART
"void uartSetTxDoneISR(uint8_t channel, void (*func)(void))",Set callback for transmission done interrupt
bool uartClose(uint8_t channel),Close UART channel
void uartFlush(uint8_t channel),Flush receive buffer
"int32_t uartPrintf(uint8_t channel, const char *fmt, ...)",Formatted print to UART
void uartRxHandler(uint8_t channel),Handle UART receive interrupt
"qbufferWrite(&p_uart->qbuffer_rx, &p_uart->rx_buf[0], 1);",Write received byte to queue buffer
__HAL_UNLOCK(p_uart->handle); uartStartRx(channel);,Unlock UART handle and restart reception
uint32_t uartGetErrCnt(uint8_t channel),Get UART error count
void uartResetErrCnt(uint8_t channel),Reset UART error count
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle),UART MSP Initialization
__HAL_RCC_USART3_CLK_ENABLE();,USART3 clock enable
"GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9; GPIO_InitStruct.Mode = GPIO_MODE_AF_PP; GPIO_InitStruct.Pull = GPIO_PULLUP; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH; GPIO_InitStruct.Alternate = GPIO_AF7_USART3; HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);",USART3 GPIO Configuration PD8 ------> USART3_TX PD9 ------> USART3_RX
void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle),UART MSP DeInitialization
__HAL_RCC_USART3_CLK_DISABLE();,Peripheral clock disable
"HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9);",USART3 GPIO Configuration PD8 ------> USART3_TX PD9 ------> USART3_RX
HAL_NVIC_DisableIRQ(USART3_IRQn);,USART3 interrupt Deinit
static void MX_USART2_UART_Init(void),USART2 Initialization Function
"GPIO_InitStruct.Pin = B1_Pin; GPIO_InitStruct.Mode = GPIO_MODE_IT_RISING; GPIO_InitStruct.Pull = GPIO_NOPULL; HAL_GPIO_Init(B1_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : B1_Pin
void MPU_Config(void),Configure the MPU attributes
static void CPU_CACHE_Enable(void),CPU L1-Cache enable
AdcHandle.Instance = ADCx; AdcHandle.Init.ClockPrescaler = ADC_CLOCKPRESCALER_PCLK_DIV4; AdcHandle.Init.Resolution = ADC_RESOLUTION_12B; AdcHandle.Init.ScanConvMode = DISABLE; AdcHandle.Init.ContinuousConvMode = ENABLE; AdcHandle.Init.DiscontinuousConvMode = DISABLE; AdcHandle.Init.NbrOfDiscConversion = 0; AdcHandle.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE; AdcHandle.Init.ExternalTrigConv = ADC_EXTERNALTRIGCONV_T1_CC1; AdcHandle.Init.DataAlign = ADC_DATAALIGN_RIGHT; AdcHandle.Init.NbrOfConversion = 1; AdcHandle.Init.DMAContinuousRequests = ENABLE; AdcHandle.Init.EOCSelection = DISABLE; if (HAL_ADC_Init(&AdcHandle) != HAL_OK) { Error_Handler(); },Configure the ADC peripheral
"sConfig.Channel = ADC_CHANNEL_8; sConfig.Rank = 1; sConfig.SamplingTime = ADC_SAMPLETIME_3CYCLES; sConfig.Offset = 0; if (HAL_ADC_ConfigChannel(&AdcHandle, &sConfig) != HAL_OK) { Error_Handler(); }",Configure ADC regular channel
void HAL_ADC_ConvCpltCallback(ADC_HandleTypeDef* AdcHandle),Conversion complete callback in non blocking mode
"RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2; RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1; RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2; RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1; if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Initializes the CPU, AHB and APB buses clocks"
void tud_mount_cb(void),Invoked when device is mounted
void tud_umount_cb(void),Invoked when device is unmounted
void tud_resume_cb(void),Invoked when usb bus is resumed
"bool tud_vendor_control_xfer_cb(uint8_t rhport, uint8_t stage, tusb_control_request_t const * request)",Invoked when a control transfer occurred on an interface of this class
void cdc_task(void),Handle CDC serial communication
"void tud_cdc_line_state_cb(uint8_t itf, bool dtr, bool rts)",Invoked when cdc when line state changed e.g connected/disconnected
static void MX_FDCAN1_Init(void),FDCAN1 Initialization Function
void flashBoardID(void),Flash board infos into the previous page on the flash starting at 0x08003800
"FLASH_If_Erase(FLASH_USER_START_ADDR-FLASH_PAGE_SIZE,FLASH_USER_START_ADDR-1); HAL_FLASH_Unlock(); HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, FLASH_USER_START_ADDR-FLASH_PAGE_SIZE, CAN_ID_64); HAL_FLASH_Lock();",Flash board ID to specified flash address
void deInitAll(void),Deinitialize all peripherals and system resources
"if (HAL_PWREx_EnableOverDrive() != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }",Activate the Over-Drive mode
HAL_NVallerback(TIM_HandleTypeDef *htim),Timer period elapsed callback
"HAL_GPIO_TogglePin(LD2_GPIO_Port, LD2_Pin);",Toggle LD2 pin
"HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_RESET);",Configure GPIO pin Output Level
"GPIO_InitStruct.Pin = SPI1_CS_Pin; GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP; GPIO_InitStruct.Pull = GPIO_NOPULL; GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(SPI1_CS_GPIO_Port, &GPIO_InitStruct);",Configure GPIO pin : SPI1_CS_Pin
"HAL_GPIO_WritePin(SPI1_CS_GPIO_Port, SPI1_CS_Pin, GPIO_PIN_SET);",SPI CS UP
"HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6, GPIO_PIN_RESET);",SPI CS UP
void BME280_Handler(),Handle BME280 sensor operations
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_HSE; rccOscInit.HSEState = RCC_HSE_ON; rccOscInit.HSEPredivValue = RCC_HSE_PREDIV_DIV1; rccOscInit.PLL.PLLState = RCC_PLL_ON; rccOscInit.PLL.PLLSource = RCC_PLLSOURCE_HSE; rccOscInit.PLL.PLLMUL = RCC_PLL_MUL9; if (HAL_RCC_OscConfig(&rccOscInit) != HAL_OK) { Error_Handler(); },Configure HSE and PLL
"rccClkInit.ClockType = (RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2); rccClkInit.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK; rccClkInit.AHBCLKDivider = RCC_SYSCLK_DIV1; rccClkInit.APB2CLKDivider = RCC_HCLK_DIV1; rccClkInit.APB1CLKDivider = RCC_HCLK_DIV2; if (HAL_RCC_ClockConfig(&rccClkInit, FLASH_LATENCY_2) != HAL_OK) { Error_Handler(); }","Configure SYSCLK, HCLK, PCLK1, and PCLK2"
void GPIO_Output_Config(void),GPIO configuration
"gpioInit.Pin = GPIO_PIN_6 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9; gpioInit.Mode = GPIO_MODE_OUTPUT_PP; gpioInit.Speed = GPIO_SPEED_FREQ_LOW; HAL_GPIO_Init(GPIOB, &gpioInit);",Configure GPIO
rtcHandle.Instance = RTC; rtcHandle.Init.AsynchPrediv = RTC_AUTO_1_SECOND; rtcHandle.Init.OutPut = RTC_OUTPUTSOURCE_NONE; if (HAL_RTC_Init(&rtcHandle) != HAL_OK) { Error_Handler(); },Configure RTC
void HAL_RTC_MspInit(RTC_HandleTypeDef *hrtc),RTC MSP configuration callback
rccOscInit.OscillatorType = RCC_OSCILLATORTYPE_LSI; rccOscInit.PLL.PLLState = RCC_PLL_NONE; rccOscInit.LSIState = RCC_LSI_ON; if(HAL_RCC_OscConfig(&rccOscInit) != HAL_OK) { Error_Handler(); },Configure LSI
rccPeriphCLKInit.PeriphClockSelection = RCC_PERIPHCLK_RTC; rccPeriphCLKInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSI; if(HAL_RCCEx_PeriphCLKConfig(&rccPeriphCLKInit) != HAL_OK) { Error_Handler(); },Configure RCC peripheral
__HAL_RCC_RTC_ENABLE();,Enable RTC clock
__HAL_RCC_BKP_CLK_ENABLE();,Configure RCC for backup registers
